LAB1
1.   A client sends to the server an array of numbers. Server returns the sum of the numbers.
--tcp
--no threads

server.py

import socket
import struct

HOST = "0.0.0.0"
PORT = 1234

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    print("Connected client:", addr)

    try:
        # Receive number of elements (uint16)
        data = client_socket.recv(2)
        if len(data) < 2:
            client_socket.close()
            continue

        n = struct.unpack("!H", data)[0]

        numbers = []
        for _ in range(n):
            num_data = client_socket.recv(2)
            num = struct.unpack("!H", num_data)[0]
            numbers.append(num)

        total_sum = sum(numbers)
        print("Sum =", total_sum)

        # Send sum back
        client_socket.sendall(struct.pack("!H", total_sum))

    except Exception as e:
        print("Error:", e)

    client_socket.close()


client.py

import socket
import struct

HOST = "127.0.0.1"
PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

n = int(input("How many numbers? "))
numbers = []

for i in range(n):
    num = int(input(f"Number {i+1}: "))
    numbers.append(num)

# Send number of elements
client.sendall(struct.pack("!H", n))

# Send each number
for num in numbers:
    client.sendall(struct.pack("!H", num))

# Receive sum
data = client.recv(2)
result = struct.unpack("!H", data)[0]

print("Sum =", result)

client.close()


--threads

server.py
import socket
import struct
import threading

HOST = "0.0.0.0"
PORT = 1234

def recv_exact(sock, size):
    data = b""
    while len(data) < size:
        chunk = sock.recv(size - len(data))
        if not chunk:
            raise ConnectionError("Client disconnected")
        data += chunk
    return data

def handle_client(client_socket, addr):
    print("Connected:", addr)
    try:
        data = recv_exact(client_socket, 4)
        n = struct.unpack("!I", data)[0]

        numbers = []
        for _ in range(n):
            num_data = recv_exact(client_socket, 4)
            num = struct.unpack("!I", num_data)[0]
            numbers.append(num)

        total = sum(numbers)
        print(f"{addr} -> sum = {total}")

        client_socket.sendall(struct.pack("!I", total))

    except Exception as e:
        print("Error:", e)

    finally:
        client_socket.close()
        print("Disconnected:", addr)

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    threading.Thread(
        target=handle_client,
        args=(client_socket, addr),
        daemon=True
    ).start()


client.py
import socket
import struct

HOST = "127.0.0.1"   # âœ… FIX
PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

n = int(input("How many numbers? "))
numbers = []

for i in range(n):
    numbers.append(int(input(f"Number {i+1}: ")))

# Send n (uint32)
client.sendall(struct.pack("!I", n))

# Send numbers
for num in numbers:
    client.sendall(struct.pack("!I", num))

# Receive sum (uint32)
data = client.recv(4)
result = struct.unpack("!I", data)[0]

print("Sum =", result)

client.close()


--udp

server.py
import socket
import struct

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("", 1234))

print("UDP server listening on port 1234...")

while True:
    data, addr = sock.recvfrom(2)
    n = struct.unpack("!H", data)[0]

    numbers = []
    for _ in range(n):
        data, _ = sock.recvfrom(2)
        num = struct.unpack("!H", data)[0]
        numbers.append(num)

    total = sum(numbers)
    sock.sendto(struct.pack("!H", total), addr)


client.py
import socket
import struct

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 1234)

n = int(input("How many numbers? "))
sock.sendto(struct.pack("!H", n), server)

for i in range(n):
    x = int(input(f"Number {i+1}: "))
    sock.sendto(struct.pack("!H", x), server)

data, _ = sock.recvfrom(2)
print("Sum =", struct.unpack("!H", data)[0])



2.A client sends to the server a string. The server returns the count of spaces in the string.
--tcp
--no threads

server.py
import socket
import struct

HOST = "0.0.0.0"
PORT = 1234

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    print("Connected client:", addr)

    try:
        # receive string length (uint16)
        data = client_socket.recv(2)
        if len(data) != 2:
            client_socket.close()
            continue

        length = struct.unpack("!H", data)[0]

        # receive string
        buffer = b""
        while len(buffer) < length:
            buffer += client_socket.recv(length - len(buffer))

        text = buffer.decode()

        # count spaces
        spaces = text.count(' ')
        print(f"Received: '{text}' -> spaces = {spaces}")

        # send result
        client_socket.sendall(struct.pack("!H", spaces))

    except Exception as e:
        print("Error:", e)

    client_socket.close()


client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

text = input("Enter a string: ")
data = text.encode()

# send length
client.sendall(struct.pack("!H", len(data)))

# send string
client.sendall(data)

# receive space count
result = client.recv(2)
spaces = struct.unpack("!H", result)[0]

print("Number of spaces:", spaces)

client.close()


--threads

server.py
import socket
import struct
import threading

HOST = "0.0.0.0"
PORT = 4321

def handle_client(client_socket, addr):
    print("Connected:", addr)

    try:
        # receive length
        data = client_socket.recv(2)
        if len(data) != 2:
            return

        length = struct.unpack("!H", data)[0]

        # receive string
        buffer = b""
        while len(buffer) < length:
            buffer += client_socket.recv(length - len(buffer))

        text = buffer.decode()

        # count spaces
        spaces = text.count(' ')
        print(f"Client {addr}: {spaces} spaces")

        # send result
        client_socket.sendall(struct.pack("!H", spaces))

    except Exception as e:
        print("Error:", e)

    finally:
        client_socket.close()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Threaded server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    threading.Thread(
        target=handle_client,
        args=(client_socket, addr),
        daemon=True
    ).start()


client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 4321

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

text = input("Enter a string: ")
data = text.encode()

# send length
client.sendall(struct.pack("!H", len(data)))

# send string
client.sendall(data)

# receive space count
result = client.recv(2)
spaces = struct.unpack("!H", result)[0]

print("Number of spaces:", spaces)

client.close()


--udp

server.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("", 5000))

print("UDP Server waiting on port 5000...")

while True:
    data, addr = sock.recvfrom(1024)
    text = data.decode()
    spaces = text.count(" ")
    sock.sendto(str(spaces).encode(), addr)

client.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

msg = input("Enter string: ")
sock.sendto(msg.encode(), server)

data, _ = sock.recvfrom(1024)
print("Number of spaces:", data.decode())



3.   A client sends to the server a string. The server returns the reversed string to the client (characters from the end to begging)
--tcp
--no threads

server.py
import socket
import struct

HOST = "0.0.0.0"
PORT = 1234

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    print("Connected client:", addr)

    try:
        # receive length (uint16)
        data = client_socket.recv(2)
        if len(data) != 2:
            client_socket.close()
            continue

        length = struct.unpack("!H", data)[0]

        # receive string
        buffer = b""
        while len(buffer) < length:
            buffer += client_socket.recv(length - len(buffer))

        text = buffer.decode()
        print("Received:", text)

        # reverse string
        reversed_text = text[::-1].encode()

        # send reversed string
        client_socket.sendall(reversed_text)

    except Exception as e:
        print("Error:", e)

    client_socket.close()

client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

text = input("Enter a string: ")
data = text.encode()

# send length
client.sendall(struct.pack("!H", len(data)))

# send string
client.sendall(data)

# receive reversed string
buffer = b""
while len(buffer) < len(data):
    buffer += client.recv(len(data) - len(buffer))

print("Reversed array:", buffer.decode())

client.close()


--threads
server.py
import socket
import struct
import threading

HOST = "0.0.0.0"
PORT = 4321

def handle_client(client_socket, addr):
    print("Connected:", addr)

    try:
        # receive length
        data = client_socket.recv(2)
        if len(data) != 2:
            return

        length = struct.unpack("!H", data)[0]
        if length == 0:
            length = 1

        # receive string
        buffer = b""
        while len(buffer) < length:
            buffer += client_socket.recv(length - len(buffer))

        text = buffer.decode()
        print("Received:", text)

        # reverse
        reversed_text = text[::-1].encode()

        # send reversed string
        client_socket.sendall(reversed_text)

        print("Client handled, string reversed.")

    except Exception as e:
        print("Error:", e)

    finally:
        client_socket.close()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Threaded server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    threading.Thread(
        target=handle_client,
        args=(client_socket, addr),
        daemon=True
    ).start()

client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 4321

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

text = input("Enter a string: ")
data = text.encode()

# send length
client.sendall(struct.pack("!H", len(data)))

# send string
client.sendall(data)

# receive reversed string
buffer = b""
while len(buffer) < len(data):
    buffer += client.recv(len(data) - len(buffer))

print("Reversed array:", buffer.decode())

client.close()

--udp

server.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("", 5000))

print("Server ready on port 5000")

while True:
    data, addr = sock.recvfrom(1024)
    text = data.decode()
    reversed_text = text[::-1]
    sock.sendto(reversed_text.encode(), addr)

client.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

msg = input("Enter string: ")
sock.sendto(msg.encode(), server)

data, _ = sock.recvfrom(1024)
print("Reversed:", data.decode())


4.   The client sends to the server two sorted array of chars. The server will merge sort the two arrays and return the result to the client.
--tcp
--no threads

server.py
import socket
import struct

HOST = "0.0.0.0"
PORT = 1234

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    print("Connected client:", addr)

    try:
        # receive first length
        len1 = struct.unpack("!H", client_socket.recv(2))[0]

        buf1 = b""
        while len(buf1) < len1:
            buf1 += client_socket.recv(len1 - len(buf1))

        # receive second length
        len2 = struct.unpack("!H", client_socket.recv(2))[0]

        buf2 = b""
        while len(buf2) < len2:
            buf2 += client_socket.recv(len2 - len(buf2))

        s1 = buf1.decode()
        s2 = buf2.decode()

        # merge sorted strings
        i = j = 0
        merged = []

        while i < len1 and j < len2:
            if s1[i] < s2[j]:
                merged.append(s1[i])
                i += 1
            else:
                merged.append(s2[j])
                j += 1

        merged.extend(s1[i:])
        merged.extend(s2[j:])

        result = "".join(merged).encode()

        client_socket.sendall(result)

    except Exception as e:
        print("Error:", e)

    client_socket.close()

client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

s1 = input("Enter an ordered string: ")
s2 = input("Enter another ordered string: ")

b1 = s1.encode()
b2 = s2.encode()

client.sendall(struct.pack("!H", len(b1)))
client.sendall(b1)

client.sendall(struct.pack("!H", len(b2)))
client.sendall(b2)

merged_len = len(b1) + len(b2)
buffer = b""
while len(buffer) < merged_len:
    buffer += client.recv(merged_len - len(buffer))

print("Ordered array:", buffer.decode())

client.close()


--threads

server.py
import socket
import struct
import threading

HOST = "0.0.0.0"
PORT = 4321

def handle_client(client_socket, addr):
    print("Connected:", addr)

    try:
        len1 = struct.unpack("!H", client_socket.recv(2))[0]
        buf1 = b""
        while len(buf1) < len1:
            buf1 += client_socket.recv(len1 - len(buf1))

        len2 = struct.unpack("!H", client_socket.recv(2))[0]
        buf2 = b""
        while len(buf2) < len2:
            buf2 += client_socket.recv(len2 - len(buf2))

        s1 = buf1.decode()
        s2 = buf2.decode()

        i = j = 0
        merged = []

        while i < len1 and j < len2:
            if s1[i] < s2[j]:
                merged.append(s1[i])
                i += 1
            else:
                merged.append(s2[j])
                j += 1

        merged.extend(s1[i:])
        merged.extend(s2[j:])

        client_socket.sendall("".join(merged).encode())

        print("Client handled, arrays merged.")

    except Exception as e:
        print("Error:", e)

    finally:
        client_socket.close()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Threaded server listening on port", PORT)

while True:
    client_socket, addr = server.accept()
    threading.Thread(
        target=handle_client,
        args=(client_socket, addr),
        daemon=True
    ).start()

client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 4321

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

s1 = input("Enter an ordered string: ")
s2 = input("Enter another ordered string: ")

b1 = s1.encode()
b2 = s2.encode()

client.sendall(struct.pack("!H", len(b1)))
client.sendall(b1)

client.sendall(struct.pack("!H", len(b2)))
client.sendall(b2)

merged_len = len(b1) + len(b2)
buffer = b""
while len(buffer) < merged_len:
    buffer += client.recv(merged_len - len(buffer))

print("Ordered array:", buffer.decode())

client.close()


--udp
server.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("", 5000))

print("Server ready")

while True:
    data, addr = sock.recvfrom(1024)
    parts = data.decode().split()

    if len(parts) < 2:
        continue  # ignore invalid packets

    a = parts[0]
    b = parts[1]

    i = j = 0
    result = []

    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            result.append(a[i])
            i += 1
        else:
            result.append(b[j])
            j += 1

    result.extend(a[i:])
    result.extend(b[j:])

    sock.sendto("".join(result).encode(), addr)

client.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

a = input("Enter first sorted array (chars): ")
b = input("Enter second sorted array (chars): ")

sock.sendto(f"{a} {b}".encode(), server)

data, _ = sock.recvfrom(1024)
print("Merged:", data.decode())


5.   The client sends to the server an integer. The server returns the list of divisors for the specified number.
--tcp
--no threads

server.py
import socket
import struct

HOST = "0.0.0.0"
PORT = 1234

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Server listening on port", PORT)

while True:
    client, addr = server.accept()
    print("Connected:", addr)

    try:
        # receive number (uint16)
        data = client.recv(2)
        if len(data) != 2:
            client.close()
            continue

        a = struct.unpack("!H", data)[0]

        divisors = []
        for i in range(1, a + 1):
            if a % i == 0:
                divisors.append(i)

        # send divisors + terminating 0
        for d in divisors:
            client.sendall(struct.pack("!H", d))
        client.sendall(struct.pack("!H", 0))

    except Exception as e:
        print("Error:", e)

    client.close()

client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

a = int(input("Enter a number: "))
client.sendall(struct.pack("!H", a))

print("Divisors:", end=" ")

while True:
    data = client.recv(2)
    val = struct.unpack("!H", data)[0]
    if val == 0:
        break
    print(val, end=" ")

print()
client.close()

--threads

server.py
import socket
import struct
import threading

HOST = "0.0.0.0"
PORT = 4321


def handle_client(client, addr):
    print("Client connected:", addr)

    try:
        data = client.recv(2)
        if len(data) != 2:
            client.close()
            return

        a = struct.unpack("!H", data)[0]

        divisors = []
        for i in range(1, a + 1):
            if a % i == 0:
                divisors.append(i)

        for d in divisors:
            client.sendall(struct.pack("!H", d))
        client.sendall(struct.pack("!H", 0))

    except Exception as e:
        print("Error:", e)

    client.close()
    print("Client handled:", addr)


server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(5)

print("Threaded server listening on port", PORT)

while True:
    client, addr = server.accept()
    threading.Thread(target=handle_client, args=(client, addr), daemon=True).start()


client.py
import socket
import struct

HOST = "127.0.0.1"
PORT = 4321

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((HOST, PORT))

a = int(input("Enter a number: "))
client.sendall(struct.pack("!H", a))

print("Divisors:", end=" ")

while True:
    data = client.recv(2)
    val = struct.unpack("!H", data)[0]
    if val == 0:
        break
    print(val, end=" ")

print()
client.close()

--udp
server.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("", 5000))

print("UDP server running on port 5000...")

while True:
    data, addr = sock.recvfrom(1024)
    x = int(data.decode())

    divisors = [str(i) for i in range(1, x + 1) if x % i == 0]
    result = " ".join(divisors)

    sock.sendto(result.encode(), addr)

client.py
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

x = input("Enter integer: ")
sock.sendto(x.encode(), server)

data, _ = sock.recvfrom(1024)
print("Divisors:", data.decode())


6.   The client sends to the server a string and a character. The server returns to the client a list of all positions in the string where specified character is found.
--tcp
--no threads
server.py
import socket

HOST = '0.0.0.0'
PORT = 1234

s = socket.socket()
s.bind((HOST, PORT))
s.listen(5)
print(f"Server listening on port {PORT}...")

while True:
    conn, addr = s.accept()
    print("Connected by", addr)

    text = conn.recv(1024).decode()      # receive string
    char = conn.recv(1).decode()         # receive single character

    # find positions
    positions = [str(i) for i, c in enumerate(text) if c == char]

    # send positions back as comma-separated string
    conn.send(",".join(positions).encode())

    conn.close()

client.py
import socket

HOST = '127.0.0.1'
PORT = 1234

s = socket.socket()
s.connect((HOST, PORT))

text = input("Enter string: ")
char = input("Enter character: ")

# send string and character
s.send(text.encode())
s.send(char.encode())

# receive positions
positions = s.recv(1024).decode()
print(f"Character '{char}' found at positions: {positions}")

s.close()


--threads
server.py
import socket
import threading

HOST = '0.0.0.0'
PORT = 1234

def handle_client(conn, addr):
    print("Connected by", addr)

    text = conn.recv(1024).decode()      # receive string
    char = conn.recv(1).decode()         # receive single character

    # find positions
    positions = [str(i) for i, c in enumerate(text) if c == char]

    # send positions back as comma-separated string
    conn.send(",".join(positions).encode())

    conn.close()
    print(f"Client {addr} handled.")

# main server
s = socket.socket()
s.bind((HOST, PORT))
s.listen(5)
print(f"Server listening on port {PORT}...")

while True:
    conn, addr = s.accept()
    # handle each client in a new thread
    t = threading.Thread(target=handle_client, args=(conn, addr))
    t.start()

client.py
import socket

HOST = '127.0.0.1'
PORT = 1234

s = socket.socket()
s.connect((HOST, PORT))

text = input("Enter string: ")
char = input("Enter character: ")

# send string and character
s.send(text.encode())
s.send(char.encode())

# receive positions
positions = s.recv(1024).decode()
print(f"Character '{char}' found at positions: {positions}")

s.close()

--udp
server.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 6 running...")

while True:
    data, addr = s.recvfrom(1024)
    msg = data.decode()

    text, ch = msg.split(";")
    positions = [str(i) for i, c in enumerate(text) if c == ch]

    s.sendto(" ".join(positions).encode(), addr)


client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

text = input("Enter string: ")
ch = input("Enter character: ")

s.sendto(f"{text};{ch}".encode(), server)
data, _ = s.recvfrom(1024)

print("Positions:", data.decode())


7.   The client sends to the server a string and two numbers (s, I, l). The sever returns to the client the substring of s starting at index I, of length l.
--tcp
--no threads

server.py
import socket

HOST = '0.0.0.0'
PORT = 1234

s = socket.socket()
s.bind((HOST, PORT))
s.listen(5)
print(f"Server listening on port {PORT}...")

while True:
    conn, addr = s.accept()
    print("Connected by", addr)

    try:
        data = conn.recv(1024).decode().strip()
        if not data:
            conn.close()
            continue

        # split into string, I, L
        parts = data.split('|')
        if len(parts) != 3:
            conn.send(b"Invalid data format")
            conn.close()
            continue

        text = parts[0]
        I = int(parts[1])
        L = int(parts[2])

        # get substring safely
        if I >= len(text):
            substring = "Invalid index"
        else:
            substring = text[I:I+L]

        conn.send(substring.encode())

    except Exception as e:
        print("Error:", e)
    finally:
        conn.close()

client.py
import socket

HOST = '127.0.0.1'
PORT = 1234

s = socket.socket()
s.connect((HOST, PORT))

text = input("Enter string: ")
I = input("Index: ")
L = input("Length: ")

# send all data in one message
message = f"{text}|{I}|{L}"
s.send(message.encode())

substring = s.recv(1024).decode()
print("Substring:", substring)

s.close()


--threads

server.py
import socket
import threading

HOST = '0.0.0.0'
PORT = 1234

def handle_client(conn, addr):
    print(f"Client connected: {addr}")
    try:
        data = conn.recv(1024).decode().strip()
        if not data:
            conn.close()
            return

        # Expect format: string|I|L
        parts = data.split('|')
        if len(parts) != 3:
            conn.send(b"Invalid data format")
            conn.close()
            return

        text = parts[0]
        try:
            I = int(parts[1])
            L = int(parts[2])
        except ValueError:
            conn.send(b"Invalid numbers")
            conn.close()
            return

        # Get substring safely
        if I >= len(text):
            substring = "Invalid index"
        else:
            substring = text[I:I+L]

        conn.send(substring.encode())

    except Exception as e:
        print(f"Error with {addr}: {e}")
    finally:
        conn.close()
        print(f"Client disconnected: {addr}")

# Main server
server = socket.socket()
server.bind((HOST, PORT))
server.listen(5)
print(f"Server listening on port {PORT}...")

while True:
    conn, addr = server.accept()
    t = threading.Thread(target=handle_client, args=(conn, addr))
    t.start()

client.py
import socket

HOST = '127.0.0.1'
PORT = 1234

s = socket.socket()
s.connect((HOST, PORT))

text = input("Enter string: ")
I = input("Index: ")
L = input("Length: ")

# send all data in one message
message = f"{text}|{I}|{L}"
s.send(message.encode())

substring = s.recv(1024).decode()
print("Substring:", substring)

s.close()

--udp
server.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 7 running...")

while True:
    data, addr = s.recvfrom(1024)
    text, i, l = data.decode().split(";")
    i, l = int(i), int(l)

    s.sendto(text[i:i+l].encode(), addr)

client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

text = input("Enter string: ")
i = input("Enter start index: ")
l = input("Enter length: ")

s.sendto(f"{text};{i};{l}".encode(), server)
data, _ = s.recvfrom(1024)

print("Substring:", data.decode())




8.   The client sends to the server two arrays of integers. The server returns an arrays containing the common numbers found in both arrays.
--tcp
--no threads

server.py
import socket
import struct

HOST = '127.0.0.1'
PORT = 1234

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    print(f"Server listening on {HOST}:{PORT}")

    while True:
        conn, addr = s.accept()
        print(f"Client connected: {addr}")
        with conn:
            # Receive first array
            n1 = struct.unpack('!H', conn.recv(2))[0]
            arr1 = [struct.unpack('!i', conn.recv(4))[0] for _ in range(n1)]

            # Receive second array
            n2 = struct.unpack('!H', conn.recv(2))[0]
            arr2 = [struct.unpack('!i', conn.recv(4))[0] for _ in range(n2)]

            # Find common elements
            common = []
            for x in arr1:
                if x in arr2 and x not in common:
                    common.append(x)

            # Send common array
            conn.send(struct.pack('!H', len(common)))
            for x in common:
                conn.send(struct.pack('!i', x))

            print(f"Processed client: common = {common}")

client.py
import socket
import struct

# connect to server
s = socket.socket()
s.connect(('127.0.0.1', 1234))

# first array
n1 = int(input("Number of elements in first array: "))
arr1 = []
for i in range(n1):
    val = int(input(f"arr1[{i}]: "))
    arr1.append(val)

# second array
n2 = int(input("Number of elements in second array: "))
arr2 = []
for i in range(n2):
    val = int(input(f"arr2[{i}]: "))
    arr2.append(val)

# send first array
s.send(struct.pack('!H', n1))  # send length as unsigned short
for num in arr1:
    s.send(struct.pack('!i', num))  # send each int

# send second array
s.send(struct.pack('!H', n2))
for num in arr2:
    s.send(struct.pack('!i', num))

# receive common array
k = struct.unpack('!H', s.recv(2))[0]  # length of common array
common = []
for _ in range(k):
    num = struct.unpack('!i', s.recv(4))[0]
    common.append(num)

print("Common elements:", common)

s.close()

--threads

server.py
import socket
import struct
import threading

def handle_client(conn, addr):
    print(f"Connected to {addr}")

    try:
        # receive first array
        n1 = struct.unpack('!H', conn.recv(2))[0]
        arr1 = []
        for _ in range(n1):
            arr1.append(struct.unpack('!i', conn.recv(4))[0])

        # receive second array
        n2 = struct.unpack('!H', conn.recv(2))[0]
        arr2 = []
        for _ in range(n2):
            arr2.append(struct.unpack('!i', conn.recv(4))[0])

        # find common elements
        common = []
        for x in arr1:
            if x in arr2 and x not in common:
                common.append(x)

        # send back common array
        conn.send(struct.pack('!H', len(common)))  # send length
        for num in common:
            conn.send(struct.pack('!i', num))  # send each integer

        print(f"Sent common elements to {addr}: {common}")
    except Exception as e:
        print(f"Error with {addr}: {e}")
    finally:
        conn.close()

# main server
server = socket.socket()
server.bind(('0.0.0.0', 1234))
server.listen(5)
print("Server listening on port 1234...")

while True:
    conn, addr = server.accept()
    thread = threading.Thread(target=handle_client, args=(conn, addr))
    thread.start()

client.py
import socket
import struct

# connect to server
s = socket.socket()
s.connect(('127.0.0.1', 1234))

# first array
n1 = int(input("Number of elements in first array: "))
arr1 = []
for i in range(n1):
    val = int(input(f"arr1[{i}]: "))
    arr1.append(val)

# second array
n2 = int(input("Number of elements in second array: "))
arr2 = []
for i in range(n2):
    val = int(input(f"arr2[{i}]: "))
    arr2.append(val)

# send first array
s.send(struct.pack('!H', n1))  # send length as unsigned short
for num in arr1:
    s.send(struct.pack('!i', num))  # send each int

# send second array
s.send(struct.pack('!H', n2))
for num in arr2:
    s.send(struct.pack('!i', num))

# receive common array
k = struct.unpack('!H', s.recv(2))[0]  # length of common array
common = []
for _ in range(k):
    num = struct.unpack('!i', s.recv(4))[0]
    common.append(num)

print("Common elements:", common)

s.close()

--udp
server.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 8 running...")

while True:
    data, addr = s.recvfrom(1024)
    a, b = data.decode().split()

    arr1 = set(map(int, a.split(",")))
    arr2 = set(map(int, b.split(",")))

    common = arr1 & arr2
    s.sendto(",".join(map(str, common)).encode(), addr)

client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

a = input("First array (comma separated): ")
b = input("Second array (comma separated): ")

s.sendto(f"{a} {b}".encode(), server)
data, _ = s.recvfrom(1024)

print("Common numbers:", data.decode())


9.   The client sends to the server two arrays of numbers. The server returns to the client a list of numbers that are present in the first arrays but not in the second.
--tcp
--no threads


server.py
import socket
import struct

while True:
    server = socket.socket()
    server.bind(('0.0.0.0', 1234))
    server.listen(1)
    print("Server listening on port 1234...")

    conn, addr = server.accept()
    print(f"Connected to {addr}")

    try:
        # receive first array
        n1 = struct.unpack('!H', conn.recv(2))[0]
        arr1 = []
        for _ in range(n1):
            arr1.append(struct.unpack('!i', conn.recv(4))[0])

        # receive second array
        n2 = struct.unpack('!H', conn.recv(2))[0]
        arr2 = []
        for _ in range(n2):
            arr2.append(struct.unpack('!i', conn.recv(4))[0])

        # find elements in arr1 not in arr2
        diff = []
        for x in arr1:
            if x not in arr2 and x not in diff:
                diff.append(x)

        # send result
        conn.send(struct.pack('!H', len(diff)))
        for num in diff:
            conn.send(struct.pack('!i', num))

        print(f"Sent diff elements: {diff}")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        conn.close()
        server.close()


client.py
import socket
import struct

# connect to server
s = socket.socket()
s.connect(('127.0.0.1', 1234))

# first array
n1 = int(input("Number of elements in first array: "))
arr1 = []
for i in range(n1):
    val = int(input(f"arr1[{i}]: "))
    arr1.append(val)

# second array
n2 = int(input("Number of elements in second array: "))
arr2 = []
for i in range(n2):
    val = int(input(f"arr2[{i}]: "))
    arr2.append(val)

# send first array
s.send(struct.pack('!H', n1))  # send length as unsigned short
for num in arr1:
    s.send(struct.pack('!i', num))  # send each int

# send second array
s.send(struct.pack('!H', n2))
for num in arr2:
    s.send(struct.pack('!i', num))

# receive common array
k = struct.unpack('!H', s.recv(2))[0]  # length of common array
diff = []
for _ in range(k):
    num = struct.unpack('!i', s.recv(4))[0]
    diff.append(num)

print("Diff elements:", diff)

s.close()


--threads

server.py
import socket
import struct
import threading

def handle_client(conn, addr):
    print(f"Connected to {addr}")

    try:
        # receive first array
        n1 = struct.unpack('!H', conn.recv(2))[0]
        arr1 = []
        for _ in range(n1):
            arr1.append(struct.unpack('!i', conn.recv(4))[0])

        # receive second array
        n2 = struct.unpack('!H', conn.recv(2))[0]
        arr2 = []
        for _ in range(n2):
            arr2.append(struct.unpack('!i', conn.recv(4))[0])

        # find common elements
        diff = []
        for x in arr1:
            if x not in arr2 and x not in diff:
                diff.append(x)

        # send back common array
        conn.send(struct.pack('!H', len(diff)))  # send length
        for num in diff:
            conn.send(struct.pack('!i', num))  # send each integer

        print(f"Sent common elements to {addr}: {diff}")
    except Exception as e:
        print(f"Error with {addr}: {e}")
    finally:
        conn.close()

# main server
server = socket.socket()
server.bind(('0.0.0.0', 1234))
server.listen(5)
print("Server listening on port 1234...")

while True:
    conn, addr = server.accept()
    thread = threading.Thread(target=handle_client, args=(conn, addr))
    thread.start()

client.py
import socket
import struct

# connect to server
s = socket.socket()
s.connect(('127.0.0.1', 1234))

# first array
n1 = int(input("Number of elements in first array: "))
arr1 = []
for i in range(n1):
    val = int(input(f"arr1[{i}]: "))
    arr1.append(val)

# second array
n2 = int(input("Number of elements in second array: "))
arr2 = []
for i in range(n2):
    val = int(input(f"arr2[{i}]: "))
    arr2.append(val)

# send first array
s.send(struct.pack('!H', n1))  # send length as unsigned short
for num in arr1:
    s.send(struct.pack('!i', num))  # send each int

# send second array
s.send(struct.pack('!H', n2))
for num in arr2:
    s.send(struct.pack('!i', num))

# receive common array
k = struct.unpack('!H', s.recv(2))[0]  # length of common array
diff = []
for _ in range(k):
    num = struct.unpack('!i', s.recv(4))[0]
    diff.append(num)

print("Diff elements:", diff)

s.close()


--udp
server.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 9 running...")

while True:
    data, addr = s.recvfrom(1024)
    a, b = data.decode().split()

    arr1 = set(map(int, a.split(",")))
    arr2 = set(map(int, b.split(",")))

    diff = arr1 - arr2
    s.sendto(",".join(map(str, diff)).encode(), addr)

client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

a = input("First array: ")
b = input("Second array: ")

s.sendto(f"{a} {b}".encode(), server)
data, _ = s.recvfrom(1024)

print("Result:", data.decode())


10.The client sends to the server two strings. The server sends back the character with the largest number of occurrences on the same positions in both strings together with its count.
--tcp
--no threads

server.py
import socket
import struct

server = socket.socket()
server.bind(('0.0.0.0', 1234))
server.listen(1)
print("Server listening on port 1234...")

while True:
    conn, addr = server.accept()
    print(f"Connected to {addr}")

    try:
        # receive string lengths
        len1 = struct.unpack('!H', conn.recv(2))[0]
        len2 = struct.unpack('!H', conn.recv(2))[0]

        # receive strings
        str1 = conn.recv(len1).decode()
        str2 = conn.recv(len2).decode()

        # compute character frequencies at same positions
        min_len = min(len1, len2)
        freq = [0] * 256
        for i in range(min_len):
            if str1[i] == str2[i]:
                freq[ord(str1[i])] += 1

        max_count = 0
        max_ch = '\0'
        for i in range(256):
            if freq[i] > max_count:
                max_count = freq[i]
                max_ch = chr(i)

        # send back result
        conn.send(max_ch.encode())
        conn.send(struct.pack('!H', max_count))

        print(f"Sent max char '{max_ch}' count = {max_count}")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        conn.close()

client.py
import socket
import struct

s = socket.socket()
s.connect(('127.0.0.1', 1234))

str1 = input("Enter first string: ")
str2 = input("Enter second string: ")

len1 = len(str1)
len2 = len(str2)

# send lengths
s.send(struct.pack('!H', len1))
s.send(struct.pack('!H', len2))

# send strings
s.send(str1.encode())
s.send(str2.encode())

# receive result
ch = s.recv(1).decode()
count = struct.unpack('!H', s.recv(2))[0]

print(f"Most common character at same positions: '{ch}' with count: {count}")

s.close()


--threads

server.py
import socket
import struct
import threading

def handle_client(conn, addr):
    print(f"Connected to {addr}")

    try:
        # receive lengths
        len1 = struct.unpack('!H', conn.recv(2))[0]
        len2 = struct.unpack('!H', conn.recv(2))[0]

        # receive strings
        str1 = conn.recv(len1).decode()
        str2 = conn.recv(len2).decode()

        # find matching characters at same positions
        min_len = min(len1, len2)
        freq = [0] * 256
        for i in range(min_len):
            if str1[i] == str2[i]:
                freq[ord(str1[i])] += 1

        max_ch = ''
        max_count = 0
        for i in range(256):
            if freq[i] > max_count:
                max_count = freq[i]
                max_ch = chr(i)

        # send results
        conn.send(max_ch.encode())
        conn.send(struct.pack('!H', max_count))

        print(f"Sent to {addr}: char='{max_ch}', count={max_count}")

    except Exception as e:
        print(f"Error with {addr}: {e}")
    finally:
        conn.close()

# main server
server = socket.socket()
server.bind(('0.0.0.0', 1234))
server.listen(5)
print("Server listening on port 1234...")

while True:
    conn, addr = server.accept()
    threading.Thread(target=handle_client, args=(conn, addr)).start()


client.py
import socket
import struct

s = socket.socket()
s.connect(('127.0.0.1', 1234))

str1 = input("Enter first string: ")
str2 = input("Enter second string: ")

len1 = len(str1)
len2 = len(str2)

# send lengths
s.send(struct.pack('!H', len1))
s.send(struct.pack('!H', len2))

# send strings
s.send(str1.encode())
s.send(str2.encode())

# receive result
ch = s.recv(1).decode()
count = struct.unpack('!H', s.recv(2))[0]

print(f"Most common character at same positions: '{ch}' with count: {count}")

s.close()

--udp

server,py
import socket
from collections import Counter

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 10 running...")

while True:
    data, addr = s.recvfrom(1024)
    decoded = data.decode()
    s1, s2 = decoded.split(" ", 1)

    matches = [c1 for c1, c2 in zip(s1, s2) if c1 == c2]
    if matches:
        c, cnt = Counter(matches).most_common(1)[0]
        s.sendto(f"{c} {cnt}".encode(), addr)
    else:
        s.sendto(b"None 0", addr)

client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

s1 = input("First string: ")
s2 = input("Second string: ")

s.sendto(f"{s1} {s2}".encode(), server)
data, _ = s.recvfrom(1024)

print("Result:", data.decode())


11.Define a simple structure (e.g., a Person object with firstname, lastname, gender  and age). The client sends this structure to the server. The server increments the age and sends the updated structure back.
--tcp

--no threads

server.py
import socket
import pickle


def handle_client(conn):
    # Receive a Person object
    person = pickle.loads(conn.recv(1024))

    # Increment age
    person['age'] += 1

    # Send it back
    conn.send(pickle.dumps(person))
    conn.close()


# Setup server
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', 1234))
server.listen(5)
print("Server listening on port 1234...")

while True:
    conn, addr = server.accept()
    print("Client connected:", addr)
    handle_client(conn)

client.py
import socket
import pickle

# Input person data
person = {}
person['firstname'] = input("Enter firstname: ")
person['lastname'] = input("Enter lastname: ")
person['gender'] = input("Enter gender (M/F): ")
person['age'] = int(input("Enter age: "))

# Connect to server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 1234))

# Send Person object
s.send(pickle.dumps(person))

# Receive updated Person
updated = pickle.loads(s.recv(1024))
print("Updated person:", updated)

s.close()


--threads

server.py
import socket
import pickle
import threading


def handle_client(conn, addr):
    print("Client connected:", addr)
    try:
        # Receive Person object
        person = pickle.loads(conn.recv(1024))

        # Increment age
        person['age'] += 1

        # Send it back
        conn.send(pickle.dumps(person))
    except Exception as e:
        print("Error with client", addr, ":", e)
    finally:
        conn.close()
        print("Client disconnected:", addr)


# Setup server
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', 1234))
server.listen(5)
print("Server listening on port 1234...")

while True:
    conn, addr = server.accept()
    # Start a new thread for each client
    thread = threading.Thread(target=handle_client, args=(conn, addr))
    thread.start()


client.py
import socket
import pickle

# Input person data
person = {}
person['firstname'] = input("Enter firstname: ")
person['lastname'] = input("Enter lastname: ")
person['gender'] = input("Enter gender (M/F): ")
person['age'] = int(input("Enter age: "))

# Connect to server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 1234))

# Send Person object
s.send(pickle.dumps(person))

# Receive updated Person
updated = pickle.loads(s.recv(1024))
print("Updated person:", updated)

s.close()

--udp
server.py
import socket
import struct

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("", 5000))
print("Server 11 running...")

person_struct = struct.Struct("32s32s8si")  # C struct layout

while True:
    data, addr = sock.recvfrom(1024)
    if len(data) < person_struct.size:
        continue

    # Unpack struct
    fname, lname, gender, age = person_struct.unpack(data)
    fname = fname.decode().rstrip("\x00")
    lname = lname.decode().rstrip("\x00")
    gender = gender.decode().rstrip("\x00")

    print(f"Received: {fname} {lname}, {gender}, {age}")

    # Increment age
    age += 1

    # Pack and send back
    packed = person_struct.pack(fname.encode(), lname.encode(), gender.encode(), age)
    sock.sendto(packed, addr)

client.py
import socket
import struct

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

person_struct = struct.Struct("32s32s8si")

fname = input("First name: ")
lname = input("Last name: ")
gender = input("Gender: ")
age = int(input("Age: "))

# Pack struct
packed = person_struct.pack(
    fname.encode(), lname.encode(), gender.encode(), age
)

sock.sendto(packed, server)

data, _ = sock.recvfrom(1024)
fname, lname, gender, age = person_struct.unpack(data)
fname = fname.decode().rstrip("\x00")
lname = lname.decode().rstrip("\x00")
gender = gender.decode().rstrip("\x00")

print(f"Updated age: {age}")



12.The client sends a date string in YYYY-MM-DD format. The server returns the day of the week corresponding to that date.
--tcp
--no-threads
server.py
import socket
from datetime import datetime

# List of weekday names
weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]

# Create a TCP socket
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', 1234))  # Listen on all network interfaces, port 1234
server.listen(5)  # Allow up to 5 pending connections
print("Day-of-week server listening on port 1234...")

while True:
    # Wait for a client to connect
    conn, addr = server.accept()
    print("Client connected:", addr)

    try:
        # Receive a date string (expecting 10 bytes: "YYYY-MM-DD")
        date_str = conn.recv(11).decode().strip()  # strip() removes any trailing whitespace or newlines
        print("Received date:", date_str)

        # Convert string to a datetime object
        dt = datetime.strptime(date_str, "%Y-%m-%d")

        # Find the day of the week
        day = weekdays[dt.weekday()]  # weekday() gives 0=Monday ... 6=Sunday

        # Send the day name back to the client
        conn.send(day.encode())
        print(f"Sent day: {day}")

    except Exception as e:
        print("Error:", e)

    finally:
        # Close the connection
        conn.close()
        print("Client disconnected:", addr)

client.py
import socket

# Connect to server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 1234))

# Input date
date_str = input("Enter date (YYYY-MM-DD): ")

# Send date
s.send(date_str.encode())

# Receive day
day = s.recv(16).decode()
print("Day of the week:", day)

s.close()


--threads
server.py
import socket
import threading
from datetime import datetime

weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]


def handle_client(conn, addr):
    print("Client connected:", addr)
    try:
        # Receive date string (YYYY-MM-DD)
        date_str = conn.recv(11).decode().strip()

        # Parse date and get day of week
        dt = datetime.strptime(date_str, "%Y-%m-%d")
        day = weekdays[dt.weekday()]

        # Send day back
        conn.send(day.encode())

        print(f"Processed {date_str} -> {day}")
    except Exception as e:
        print("Error:", e)
    finally:
        conn.close()
        print("Client disconnected:", addr)


# TCP server
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', 1234))
server.listen(5)
print("Day-of-week server listening on port 1234...")

while True:
    conn, addr = server.accept()
    threading.Thread(target=handle_client, args=(conn, addr)).start()

client.py
import socket

# Connect to server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('127.0.0.1', 1234))

# Input date
date_str = input("Enter date (YYYY-MM-DD): ")

# Send date
s.send(date_str.encode())

# Receive day
day = s.recv(16).decode()
print("Day of the week:", day)

s.close()

--udp
server.py
import socket, datetime

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 12 running...")

while True:
    data, addr = s.recvfrom(1024)
    d = datetime.datetime.strptime(data.decode(), "%Y-%m-%d")
    s.sendto(d.strftime("%A").encode(), addr)

client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

date = input("Enter date (YYYY-MM-DD): ")
s.sendto(date.encode(), server)

data, _ = s.recvfrom(1024)
print("Day:", data.decode())

13.The client sends a small text file to the server. The server saves the file and returns the length of the received file content as an unsigned integer
--tcp
--no-threads

server.py
import socket
import struct
import os

PORT = 1234

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen(5)

print(f"Server listening on port {PORT}...")

while True:
    conn, addr = server.accept()
    print(f"Connected to {addr}")

    # Receive filename length
    name_len_bytes = conn.recv(2)
    name_len = struct.unpack('!H', name_len_bytes)[0]

    # Receive filename
    filename = conn.recv(name_len).decode()
    print(f"Receiving file: {filename}")

    # Make a copy filename (e.g., test-copy.txt)
    base, ext = os.path.splitext(filename)
    new_filename = f"{base}-copy{ext}"

    # Ensure we don't overwrite an existing copy
    counter = 1
    while os.path.exists(new_filename):
        new_filename = f"{base}-copy{counter}{ext}"
        counter += 1

    # Receive content length
    content_len_bytes = conn.recv(4)
    content_len = struct.unpack('!I', content_len_bytes)[0]

    # Receive file content
    content = b''
    while len(content) < content_len:
        chunk = conn.recv(content_len - len(content))
        if not chunk:
            break
        content += chunk

    # Save the file
    with open(new_filename, 'wb') as f:
        f.write(content)

    print(f"Saved file as '{new_filename}' ({len(content)} bytes)")

    # Send back length
    conn.send(struct.pack('!I', len(content)))

    conn.close()

client.py
import socket
import struct

PORT = 1234
SERVER_IP = '127.0.0.1'

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((SERVER_IP, PORT))

filename = input("Enter filename to send: ")

# Read file content
with open(filename, 'rb') as f:
    content = f.read()

# Send filename length and filename
s.send(struct.pack('!H', len(filename)))
s.send(filename.encode())

# Send content length and content
s.send(struct.pack('!I', len(content)))
s.send(content)

# Receive confirmation
received_bytes = struct.unpack('!I', s.recv(4))[0]
print(f"Server received {received_bytes} bytes.")

s.close()


--threads

server.py
import socket
import struct
import os
import threading

PORT = 1234

def handle_client(conn, addr):
    print(f"Connected to {addr}")

    try:
        # Receive filename length
        name_len_bytes = conn.recv(2)
        if not name_len_bytes:
            return
        name_len = struct.unpack('!H', name_len_bytes)[0]

        # Receive filename
        filename = conn.recv(name_len).decode()
        print(f"Receiving file: {filename}")

        # Make a copy filename (e.g., test-copy.txt)
        base, ext = os.path.splitext(filename)
        new_filename = f"{base}-copy{ext}"
        counter = 1
        while os.path.exists(new_filename):
            new_filename = f"{base}-copy{counter}{ext}"
            counter += 1

        # Receive content length
        content_len_bytes = conn.recv(4)
        content_len = struct.unpack('!I', content_len_bytes)[0]

        # Receive file content
        content = b''
        while len(content) < content_len:
            chunk = conn.recv(content_len - len(content))
            if not chunk:
                break
            content += chunk

        # Save the file
        with open(new_filename, 'wb') as f:
            f.write(content)

        print(f"Saved file as '{new_filename}' ({len(content)} bytes)")

        # Send back length
        conn.send(struct.pack('!I', len(content)))

    except Exception as e:
        print(f"Error with {addr}: {e}")
    finally:
        conn.close()

# Main server
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen(5)

print(f"Server listening on port {PORT}...")

while True:
    conn, addr = server.accept()
    # Start a new thread for each client
    t = threading.Thread(target=handle_client, args=(conn, addr))
    t.start()

client.py
import socket
import struct

PORT = 1234
SERVER_IP = '127.0.0.1'

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((SERVER_IP, PORT))

filename = input("Enter filename to send: ")

# Read file content
with open(filename, 'rb') as f:
    content = f.read()

# Send filename length and filename
s.send(struct.pack('!H', len(filename)))
s.send(filename.encode())

# Send content length and content
s.send(struct.pack('!I', len(content)))
s.send(content)

# Receive confirmation
received_bytes = struct.unpack('!I', s.recv(4))[0]
print(f"Server received {received_bytes} bytes.")

s.close()

--udp
server.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 13 running...")

while True:
    data, addr = s.recvfrom(4096)
    with open("received.txt", "wb") as f:
        f.write(data)
    s.sendto(len(data).to_bytes(4, "little"), addr)

client.py
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

fname = input("File to send: ")
with open(fname, "rb") as f:
    data = f.read()

s.sendto(data, server)
resp, _ = s.recvfrom(4)

print("Bytes received:", int.from_bytes(resp, "little"))


14.The client sends an array of boolean values. The server counts how many true values are in the array and returns the count..
--tcp
--no-thread
server.py
import socket
import struct

PORT = 1234

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen(5)

print(f"Server listening on port {PORT}...")

while True:
    conn, addr = server.accept()
    print(f"Connected to {addr}")

    try:
        # Receive number of elements (2 bytes)
        n_bytes = conn.recv(2)
        n = struct.unpack('!H', n_bytes)[0]

        # Receive array elements
        arr = []
        for _ in range(n):
            val_bytes = conn.recv(4)
            val = struct.unpack('!I', val_bytes)[0]  # 0 or 1
            arr.append(val)

        # Count True values
        count = sum(1 for x in arr if x == 1)

        # Send back the count
        conn.send(struct.pack('!H', count))

        print(f"Processed client {addr}. TRUE count: {count}")

    except Exception as e:
        print(f"Error with {addr}: {e}")

    finally:
        conn.close()

client.py
import socket
import struct

PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('127.0.0.1', PORT))

# Input array
n = int(input("Enter number of elements: "))
arr = []
for i in range(n):
    val = int(input(f"arr[{i}] (0 or 1): "))
    arr.append(val)

# Send number of elements
client.send(struct.pack('!H', n))

# Send array elements
for val in arr:
    client.send(struct.pack('!I', val))

# Receive TRUE count
count_bytes = client.recv(2)
count = struct.unpack('!H', count_bytes)[0]

print(f"Server counted {count} TRUE values.")

client.close()



--thread
server.py
import socket
import struct
import threading

PORT = 1234

def handle_client(conn, addr):
    print(f"Connected to {addr}")

    try:
        # Receive number of elements (unsigned short)
        n_bytes = conn.recv(2)
        if not n_bytes:
            return
        n = struct.unpack('!H', n_bytes)[0]

        # Receive array of booleans (as ints)
        arr = []
        for _ in range(n):
            val_bytes = conn.recv(4)
            val = struct.unpack('!I', val_bytes)[0]  # 0 or 1
            arr.append(val)

        # Count how many are True (1)
        count = sum(1 for x in arr if x == 1)

        # Send back the count (unsigned short)
        conn.send(struct.pack('!H', count))

        print(f"Processed client {addr}. TRUE count: {count}")

    except Exception as e:
        print(f"Error with {addr}: {e}")
    finally:
        conn.close()

# Main server
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen(5)

print(f"Server listening on port {PORT}...")

while True:
    conn, addr = server.accept()
    t = threading.Thread(target=handle_client, args=(conn, addr))
    t.start()

client.py
import socket
import struct

PORT = 1234

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('127.0.0.1', PORT))

# Input array
n = int(input("Enter number of elements: "))
arr = []
for i in range(n):
    val = int(input(f"arr[{i}] (0 or 1): "))
    arr.append(val)

# Send number of elements
client.send(struct.pack('!H', n))

# Send array elements
for val in arr:
    client.send(struct.pack('!I', val))

# Receive TRUE count
count_bytes = client.recv(2)
count = struct.unpack('!H', count_bytes)[0]

print(f"Server counted {count} TRUE values.")

client.close()


--udp

server.py
import socket, struct

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind(("", 5000))
print("Server 14 running...")

while True:
    data, addr = s.recvfrom(1024)
    nums = struct.unpack(f"{len(data)//4}i", data)
    count = sum(1 for x in nums if x)
    s.sendto(struct.pack("i", count), addr)

client.py
import socket, struct

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server = ("127.0.0.1", 5000)

n = int(input("How many booleans: "))
arr = [int(input(f"Value {i+1} (0/1): ")) for i in range(n)]

data = struct.pack(f"{n}i", *arr)
s.sendto(data, server)

resp, _ = s.recvfrom(4)
print("True count:", struct.unpack("i", resp)[0])



LAB2
1.   The client takes a string from the command line and sends it to the server. The server interprets the string as a command with its parameters. It executes the command and returns the standard output and the exit code to the client.
--tcp

server.py
import socket
import threading
import subprocess
import struct

PORT = 4321

def handle_client(conn, addr):
    print(f"Connected to {addr}")
    try:
        # Receive command
        cmd = conn.recv(256).decode()
        print(f"Received command: {cmd}")

        # Execute command
        proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, _ = proc.communicate()
        exit_code = proc.returncode

        # Send output length and output
        conn.send(struct.pack('!I', len(output)))
        conn.send(output)

        # Send exit code
        conn.send(struct.pack('!I', exit_code))

        print(f"Sent output and exit code to {addr}")
    except Exception as e:
        print(f"Error with {addr}: {e}")
    finally:
        conn.close()

# Main server
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen(5)
print(f"TCP Server listening on port {PORT}...")

while True:
    conn, addr = server.accept()
    threading.Thread(target=handle_client, args=(conn, addr)).start()

client.py
import socket
import struct
import sys

if len(sys.argv) < 2:
    print("Usage: python client_tcp.py <command>")
    sys.exit(1)

cmd = " ".join(sys.argv[1:])
PORT = 4321

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('127.0.0.1', PORT))

# Send command
client.send(cmd.encode())

# Receive output length
len_bytes = client.recv(4)
length = struct.unpack('!I', len_bytes)[0]

# Receive output
output = client.recv(length).decode()
print("Output:\n", output)

# Receive exit code
exit_code = struct.unpack('!I', client.recv(4))[0]
print("Exit code:", exit_code)

client.close()

--udp
server.py
import socket
import threading
import subprocess
import struct

PORT = 4321

def handle_client(data, addr, server):
    try:
        cmd = data.decode()
        print(f"Received command from {addr}: {cmd}")

        # Execute command
        proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output, _ = proc.communicate()
        exit_code = proc.returncode

        # Send output length
        server.sendto(struct.pack('!I', len(output)), addr)
        # Send output
        server.sendto(output, addr)
        # Send exit code
        server.sendto(struct.pack('!I', exit_code), addr)

        print(f"Sent output and exit code to {addr}")
    except Exception as e:
        print(f"Error with {addr}: {e}")

# Main UDP server
server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server.bind(('0.0.0.0', PORT))
print(f"UDP Server listening on port {PORT}...")

while True:
    data, addr = server.recvfrom(1024)
    threading.Thread(target=handle_client, args=(data, addr, server)).start()

client.py
import socket
import struct
import sys

if len(sys.argv) < 2:
    print("Usage: python client_udp.py <command>")
    sys.exit(1)

cmd = " ".join(sys.argv[1:])
PORT = 4321

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Send command
client.sendto(cmd.encode(), ('127.0.0.1', PORT))

# Receive output length
len_bytes, _ = client.recvfrom(4)
length = struct.unpack('!I', len_bytes)[0]

# Receive output
output, _ = client.recvfrom(length)
print("Output:\n", output.decode())

# Receive exit code
exit_code_bytes, _ = client.recvfrom(4)
exit_code = struct.unpack('!I', exit_code_bytes)[0]
print("Exit code:", exit_code)

client.close()


2.   The client sends the complete path to a file. The server returns back the length of the file and its content in the case the file exists. When the file does not exist the server returns a length of -1 and no content. The client will store the content in a file with the same name as the input file with the suffix â€“copy appended (ex: for f.txt => f.txt-copy).
--tcp

server.py
import socket
import threading
import struct
import os

PORT = 4321

def handle_client(conn, addr):
    print(f"Connected: {addr}")

    # receive path length (2 bytes)
    path_len_bytes = conn.recv(2)
    if not path_len_bytes:
        conn.close()
        return

    path_len = struct.unpack('!H', path_len_bytes)[0]

    # receive path
    path = conn.recv(path_len).decode()
    print("Requested file:", path)

    if not os.path.exists(path):
        conn.send(struct.pack('!i', -1))
        conn.close()
        return

    with open(path, 'rb') as f:
        data = f.read()

    conn.send(struct.pack('!i', len(data)))
    conn.sendall(data)

    print("File sent")
    conn.close()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen()

print("TCP server listening on port", PORT)

while True:
    conn, addr = server.accept()
    threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()

client.py
import socket
import struct
import os

PORT = 4321

path = input("Enter full file path: ")

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('127.0.0.1', PORT))

# send path length + path
client.send(struct.pack('!H', len(path)))
client.send(path.encode())

# receive file size
size = struct.unpack('!i', client.recv(4))[0]

if size == -1:
    print("File not found on server")
    client.close()
    exit()

data = b''
while len(data) < size:
    data += client.recv(size - len(data))

new_name = path + "-copy"

with open(new_name, 'wb') as f:
    f.write(data)

print("File saved as:", new_name)
client.close()

--udp

server.py
import socket
import struct
import threading
import os

PORT = 4321

def handle_request(data, addr, server):
    path = data.decode()
    print("Requested:", path)

    if not os.path.exists(path):
        server.sendto(struct.pack('!i', -1), addr)
        return

    with open(path, 'rb') as f:
        content = f.read()

    server.sendto(struct.pack('!i', len(content)), addr)
    server.sendto(content, addr)
    print("File sent to", addr)

server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server.bind(('0.0.0.0', PORT))

print("UDP server listening on port", PORT)

while True:
    data, addr = server.recvfrom(1024)
    threading.Thread(
        target=handle_request,
        args=(data, addr, server),
        daemon=True
    ).start()

client.py
import socket
import struct

PORT = 4321

path = input("Enter full file path: ")

client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
client.sendto(path.encode(), ('127.0.0.1', PORT))

size_bytes, _ = client.recvfrom(4)
size = struct.unpack('!i', size_bytes)[0]

if size == -1:
    print("File not found on server")
    client.close()
    exit()

data, _ = client.recvfrom(size)

new_name = path + "-copy"

with open(new_name, 'wb') as f:
    f.write(data)

print("File saved as:", new_name)
client.close()


3.   The server chooses a random float number <SRF>. Run multiple clients. Each client chooses a random float number <CRF> and send it to the server. When the server does not receive any incoming connection for at least 10 seconds it chooses the client that has guessed the best approximation (is closest) for its own number and sends it back the message â€œYou have the best guess with an error of <SRV>-<CRF>â€. It also sends to each other client the string â€œYou lost !â€. The server closes all connections after this.

--tcp

server.py
import socket
import struct
import threading
import time
import random
import math

PORT = 4321
TIMEOUT = 10

clients = []  # (conn, guess)
lock = threading.Lock()

server_number = random.uniform(0, 100)
print(f"ðŸŽ² Server number: {server_number:.2f}")

def handle_client(conn, addr):
    try:
        data = conn.recv(4)
        if len(data) != 4:
            conn.close()
            return

        guess = struct.unpack('!f', data)[0]

        with lock:
            clients.append((conn, guess))

        print(f"ðŸ“¨ Guess {guess:.2f} from {addr}")
    except:
        conn.close()

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen()

server.settimeout(TIMEOUT)
print(f"ðŸŸ¢ TCP server listening on port {PORT}...")

start_time = time.time()

while True:
    try:
        conn, addr = server.accept()
        threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()
        start_time = time.time()
    except socket.timeout:
        break

print("â± No connections for 10 seconds. Choosing winner...")

with lock:
    if not clients:
        print("No clients.")
    else:
        best_error = abs(server_number - clients[0][1])
        winner = 0

        for i, (_, guess) in enumerate(clients):
            err = abs(server_number - guess)
            if err < best_error:
                best_error = err
                winner = i

        for i, (conn, guess) in enumerate(clients):
            if i == winner:
                msg = f"You won! Error = {best_error:.2f}"
            else:
                msg = "You lost!"
            conn.send(msg.encode())
            conn.close()

server.close()

client.py
import socket
import struct
import random

PORT = 4321

guess = random.uniform(0, 100)
print(f"ðŸŽ¯ My guess: {guess:.2f}")

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('127.0.0.1', PORT))

sock.send(struct.pack('!f', guess))

msg = sock.recv(1024).decode()
print("ðŸ“© Server:", msg)

sock.close()


--udp

server.py
import socket
import struct
import threading
import time
import random
import math

PORT = 4321
TIMEOUT = 10

clients = []  # (addr, guess)
lock = threading.Lock()

server_number = random.uniform(0, 100)
print(f"ðŸŽ² Server number: {server_number:.2f}")

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(('0.0.0.0', PORT))
sock.settimeout(1)

last_guess_time = time.time()

def handle_guess(data, addr):
    global last_guess_time
    guess = struct.unpack('!f', data)[0]

    with lock:
        clients.append((addr, guess))
        last_guess_time = time.time()

    print(f"ðŸ“¨ Guess {guess:.2f} from {addr}")
    sock.sendto(b"Guess received", addr)

print(f"ðŸŸ¢ UDP server listening on port {PORT}...")

while True:
    try:
        data, addr = sock.recvfrom(4)
        threading.Thread(target=handle_guess, args=(data, addr), daemon=True).start()
    except socket.timeout:
        if time.time() - last_guess_time >= TIMEOUT:
            break

print("â± Timeout reached. Choosing winner...")

with lock:
    if clients:
        best_error = abs(server_number - clients[0][1])
        winner = 0

        for i, (_, guess) in enumerate(clients):
            err = abs(server_number - guess)
            if err < best_error:
                best_error = err
                winner = i

        for i, (addr, guess) in enumerate(clients):
            if i == winner:
                msg = f"You won! Error = {best_error:.2f}"
            else:
                msg = "You lost!"
            sock.sendto(msg.encode(), addr)

sock.close()

client.py
import socket
import struct
import random

PORT = 4321

guess = random.uniform(0, 100)
print(f"My guess: {guess:.2f}")

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

sock.sendto(struct.pack('!f', guess), ('127.0.0.1', PORT))

sock.settimeout(15)
try:
    while True:
        msg, _ = sock.recvfrom(1024)
        print("Server:", msg.decode())
except socket.timeout:
    pass

sock.close()



4.   The clients send an integer number N and an array of N float values. The server will merge sort the numbers received from all clients until it gets an empty array of floats (N=0). The server returns to each client the size of the merge-sorted array followed by the merge-sorted arrays of all floats from all clients.


--tcp

server.py
import socket
import struct
import threading

PORT = 4321

all_numbers = []
client_sockets = []
stop_receiving = False
lock = threading.Lock()

def recv_all(sock, size):
    data = b''
    while len(data) < size:
        chunk = sock.recv(size - len(data))
        if not chunk:
            return None
        data += chunk
    return data

def handle_client(conn):
    global stop_receiving

    # receive N
    data = recv_all(conn, 4)
    if not data:
        conn.close()
        return

    N = struct.unpack('!i', data)[0]

    with lock:
        client_sockets.append(conn)

    if N == 0:
        stop_receiving = True
        return

    # receive N floats
    data = recv_all(conn, 4 * N)
    floats = list(struct.unpack(f'!{N}f', data))

    with lock:
        all_numbers.extend(floats)

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', PORT))
server.listen()

print("TCP server listening...")

threads = []

while not stop_receiving:
    server.settimeout(1)
    try:
        conn, addr = server.accept()
        print("Client connected:", addr)
        t = threading.Thread(target=handle_client, args=(conn,))
        t.start()
        threads.append(t)
    except socket.timeout:
        pass

print("N = 0 received. Sorting and broadcasting...")

with lock:
    all_numbers.sort()
    size = len(all_numbers)

for conn in client_sockets:
    conn.send(struct.pack('!i', size))
    if size > 0:
        conn.send(struct.pack(f'!{size}f', *all_numbers))
    conn.close()

server.close()
print("Server done.")

client.p
import socket
import struct

PORT = 4321

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('127.0.0.1', PORT))

N = int(input("Enter N (0 to stop): "))
sock.send(struct.pack('!i', N))

if N > 0:
    arr = []
    for i in range(N):
        x = float(input(f"Float {i+1}: "))
        arr.append(x)

    sock.send(struct.pack(f'!{N}f', *arr))

print("Waiting for result...")

data = sock.recv(4)
size = struct.unpack('!i', data)[0]

if size > 0:
    data = sock.recv(4 * size)
    result = struct.unpack(f'!{size}f', data)
    print("Sorted array:", result)
else:
    print("Empty array")

sock.close()


--udp

server.py
?
client.py


5.   The client sends a domain name taken from the command line (Ex: www.google.com) to the server. The server opens a TCP connection to the IP address corresponding to the received domain name on port 80 (called HTTP-Srv). It sends on the TCP connection the string: â€œGET / HTTP/1.0\n\nâ€ and relays the answer back to the client. When HTTP-Srv closes connection to the server, the server closes the connection to the client at its turn.
--tcp

server.py
import socket
import threading

SERVER_PORT = 4321
MAX_BUFFER = 4096


def handle_client(client_sock):
    try:
        # Receive domain
        domain = client_sock.recv(256)
        if not domain:
            client_sock.close()
            return

        domain = domain.decode().strip()
        print(f"Client requested domain: {domain}")

        # Resolve domain
        try:
            ip = socket.gethostbyname(domain)
            print(f"Resolved IP: {ip}")
        except socket.gaierror:
            print(f"Cannot resolve domain {domain}")
            client_sock.close()
            return

        # Connect to HTTP server
        http_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            http_sock.connect((ip, 80))
        except socket.error:
            print("Cannot connect to HTTP server")
            http_sock.close()
            client_sock.close()
            return

        # Send HTTP GET
        request = b"GET / HTTP/1.0\r\n\r\n"
        http_sock.sendall(request)

        # Relay response
        while True:
            data = http_sock.recv(MAX_BUFFER)
            if not data:
                break
            client_sock.sendall(data)

        print(f"Finished relaying HTTP response for {domain}")

        http_sock.close()
        client_sock.close()

    except Exception:
        client_sock.close()


def main():
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(("", SERVER_PORT))
    server_sock.listen(5)

    print(f"Server listening on port {SERVER_PORT}")

    while True:
        client_sock, addr = server_sock.accept()
        print(f"Client connected: {addr[0]}:{addr[1]}")
        threading.Thread(target=handle_client, args=(client_sock,), daemon=True).start()


if __name__ == "__main__":
    main()

client.py
import socket
import sys

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321
MAX_BUFFER = 4096


def main():
    if len(sys.argv) >= 2:
        domain = sys.argv[1]
    else:
        domain = input("Enter domain: ")

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    # Send domain
    sock.sendall(domain.encode())

    print("\nConnected to server. Receiving HTTP response...\n")

    while True:
        data = sock.recv(MAX_BUFFER)
        if not data:
            break
        print(data.decode(errors="ignore"), end="")

    print("\n\nConnection closed by server.")
    sock.close()


if __name__ == "__main__":
    main()


--udp

server.py
import socket
import threading

SERVER_PORT = 4321
MAX_BUFFER = 4096


def handle_client(server_sock, client_addr, domain):
    domain = domain.decode().strip()
    print(f"Client requested domain: {domain}")

    # Resolve domain
    try:
        ip = socket.gethostbyname(domain)
        print(f"Resolved IP: {ip}")
    except socket.gaierror:
        msg = b"Cannot resolve domain\n"
        server_sock.sendto(msg, client_addr)
        return

    # Connect to HTTP server
    http_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        http_sock.connect((ip, 80))
    except socket.error:
        msg = b"Cannot connect to HTTP server\n"
        server_sock.sendto(msg, client_addr)
        http_sock.close()
        return

    # Send HTTP GET
    http_sock.sendall(b"GET / HTTP/1.0\r\n\r\n")

    # Relay HTTP response via UDP
    while True:
        data = http_sock.recv(MAX_BUFFER)
        if not data:
            break
        server_sock.sendto(data, client_addr)

    print(f"Finished relaying HTTP response for {domain}")
    http_sock.close()


def main():
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    server_sock.bind(("", SERVER_PORT))

    print(f"UDP Server listening on port {SERVER_PORT}")

    while True:
        data, client_addr = server_sock.recvfrom(MAX_BUFFER)
        threading.Thread(
            target=handle_client,
            args=(server_sock, client_addr, data),
            daemon=True
        ).start()


if __name__ == "__main__":
    main()


client.py
import socket
import sys

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321
MAX_BUFFER = 4096


def main():
    if len(sys.argv) >= 2:
        domain = sys.argv[1]
    else:
        domain = input("Enter domain: ")

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    # Send domain
    sock.sendto(domain.encode(), (SERVER_IP, SERVER_PORT))

    print("Receiving HTTP response...\n")

    while True:
        data, _ = sock.recvfrom(MAX_BUFFER)
        print(data.decode(errors="ignore"), end="")


if __name__ == "__main__":
    main()


6.   The server chooses a random integer number. Each client generates a random integer number and send it to the server. The server answers with the message â€œlargerâ€ if the client has sent a smaller number than the serverâ€™s choice, or with message â€œsmallerâ€ if the client has send a larger number than the serverâ€™s choice. Each client continues generating a different random number (larger or smaller than the previous) according to the serverâ€™s indication. When a client guesses the server choice â€“ the server sends back to the winner the message â€œYou win â€“ within x triesâ€. It also sends back to all other clients the message â€œYou lost â€“ after y retries!â€ (x and y are the number of tries of each respective client). The server closes all connections upon a win and it chooses a different random integer for the next game (set of clients)

--tcp

server.p
import socket
import threading
import random
import struct
import time

SERVER_PORT = 4321
MAX_CLIENTS = 10
BUFFER_SIZE = 256

clients = []
tries = {}
secret_number = 0
game_over = False
lock = threading.Lock()


def handle_client(conn, idx):
    global game_over

    tries[idx] = 0

    while True:
        try:
            data = conn.recv(4)
            if not data:
                break

            guess = struct.unpack("!i", data)[0]

            with lock:
                if game_over:
                    break

                tries[idx] += 1

                if guess < secret_number:
                    conn.sendall(b"larger")
                elif guess > secret_number:
                    conn.sendall(b"smaller")
                else:
                    conn.sendall(f"You win - within {tries[idx]} tries".encode())

                    # notify others
                    for i, c in enumerate(clients):
                        if i != idx:
                            c.sendall(f"You lost - after {tries.get(i, 0)} tries!".encode())
                            c.shutdown(socket.SHUT_RDWR)

                    game_over = True
                    break
        except:
            break

    conn.close()


def start_game(server_socket):
    global secret_number, game_over, clients, tries

    secret_number = random.randint(1, 100)
    game_over = False
    clients = []
    tries = {}

    print(f"\nNew game! Secret number: {secret_number}")

    while not game_over and len(clients) < MAX_CLIENTS:
        conn, addr = server_socket.accept()
        idx = len(clients)
        clients.append(conn)

        print(f"Client connected: {addr}")

        t = threading.Thread(target=handle_client, args=(conn, idx), daemon=True)
        t.start()

    while not game_over:
        time.sleep(0.1)

    for c in clients:
        try:
            c.close()
        except:
            pass


def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("0.0.0.0", SERVER_PORT))
    server.listen(MAX_CLIENTS)

    print(f"TCP Server listening on port {SERVER_PORT}")

    while True:
        start_game(server)
        print("Game ended. Ready for next game!")


if __name__ == "__main__":
    main()

client.py
import socket
import struct
import random
import time

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321


def play_game():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    lower, upper = 1, 100
    print("Connected to server. Starting guesses...")

    while True:
        guess = random.randint(lower, upper)
        print("Sending guess:", guess)

        sock.sendall(struct.pack("!i", guess))

        data = sock.recv(256)
        if not data:
            break

        msg = data.decode()
        print("Server:", msg)

        if "win" in msg or "lost" in msg:
            break
        if msg == "larger":
            lower = guess + 1
        elif msg == "smaller":
            upper = guess - 1

        time.sleep(0.5)

    sock.close()
    print("Game ended.")


if __name__ == "__main__":
    play_game()


--udp

server.py
import socket
import struct
import random
import threading

SERVER_PORT = 4321
MAX_CLIENTS = 10

clients = []
tries = {}
secret_number = 0
game_over = False
lock = threading.Lock()

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("0.0.0.0", SERVER_PORT))


def start_game():
    global secret_number, game_over, clients, tries

    secret_number = random.randint(1, 100)
    game_over = False
    clients = []
    tries = {}

    print(f"\nNew game started! Secret number: {secret_number}")

    while not game_over:
        data, addr = sock.recvfrom(4)
        guess = struct.unpack("!i", data)[0]

        with lock:
            if addr not in clients:
                if len(clients) >= MAX_CLIENTS:
                    continue
                clients.append(addr)
                tries[addr] = 0

            tries[addr] += 1

            if guess < secret_number:
                sock.sendto(b"larger", addr)
            elif guess > secret_number:
                sock.sendto(b"smaller", addr)
            else:
                sock.sendto(f"You win - within {tries[addr]} tries".encode(), addr)

                for c in clients:
                    if c != addr:
                        sock.sendto(
                            f"You lost - after {tries[c]} tries!".encode(), c
                        )

                game_over = True


def main():
    print(f"UDP Server listening on port {SERVER_PORT}")
    while True:
        start_game()
        print("Game ended. Waiting for next round...")


if __name__ == "__main__":
    main()

client.py
import socket
import struct
import random
import time

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_addr = (SERVER_IP, SERVER_PORT)

lower, upper = 1, 100
print("Connected to UDP server. Starting guesses...")

while True:
    guess = random.randint(lower, upper)
    print("Sending guess:", guess)

    sock.sendto(struct.pack("!i", guess), server_addr)

    data, _ = sock.recvfrom(256)
    msg = data.decode()
    print("Server:", msg)

    if "win" in msg or "lost" in msg:
        break
    if msg == "larger":
        lower = guess + 1
    elif msg == "smaller":
        upper = guess - 1

    time.sleep(0.5)

sock.close()
print("Game ended.")


7.   The client reads a username and a password from the standard input. It sends the username to the server. The server uses the getpwent system call repeatedly to find the password information about the username. If the entry for the username is found, the password field from the struct passwd is returned to the client. The client recovers the salt of the password and checks the input password with the received encrypted version using the crypt system call. If there is no user username, the server returns back to the client the empty string and closes the connection.
--tcp
server.py
import socket
import threading

SERVER_PORT = 4321
BUFFER_SIZE = 256
USERS_FILE = "lol.txt"
lock = threading.Lock()

def get_user_password(username):
    """Return the password for the given username from users.txt or None if not found."""
    try:
        with open(USERS_FILE, "r") as f:
            for line in f:
                line = line.strip()
                if not line or ':' not in line:
                    continue
                file_user, file_pass = line.split(":", 1)
                if file_user == username:
                    return file_pass
    except FileNotFoundError:
        print("users.txt not found")
    return None

def handle_client(conn, addr):
    try:
        username = conn.recv(BUFFER_SIZE).decode().strip()
        if not username:
            conn.close()
            return
        print(f"Received username from {addr}: {username}")

        password = get_user_password(username)
        if password is not None:
            conn.send(password.encode())
            print(f"Sent password for {username}")
        else:
            conn.send(b"")
            print(f"No such user: {username}")
    except Exception as e:
        print("Error handling client:", e)
    finally:
        conn.close()

def main():
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(("0.0.0.0", SERVER_PORT))
    server_sock.listen(5)
    print(f"TCP Server listening on port {SERVER_PORT}...")

    while True:
        client, addr = server_sock.accept()
        print(f"Client connected: {addr}")
        threading.Thread(target=handle_client, args=(client, addr), daemon=True).start()

if __name__ == "__main__":
    main()

clent.py
import socket

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321
BUFFER_SIZE = 256

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((SERVER_IP, SERVER_PORT))

    username = input("Enter username: ").strip()
    password = input("Enter password: ").strip()

    sock.send(username.encode())
    server_pass = sock.recv(BUFFER_SIZE).decode()

    if not server_pass:
        print("No such user found on server.")
    elif password == server_pass:
        print("Login successful!")
    else:
        print("Incorrect password.")

    sock.close()

if __name__ == "__main__":
    main()


--udp
server.py
import socket
import threading

SERVER_PORT = 4321
BUFFER_SIZE = 256
USERS_FILE = "lol.txt"

def get_password_for_user(username):
    """Return password for username or empty string if not found"""
    try:
        with open(USERS_FILE, "r") as f:
            for line in f:
                line = line.strip()
                if not line or ':' not in line:
                    continue
                file_user, file_pass = line.split(":", 1)
                if file_user == username:
                    return file_pass
    except FileNotFoundError:
        print("users.txt not found")
    return ""

def handle_request(sock, data, client_addr):
    try:
        username, password = data.decode().split()
        print(f"Request from {client_addr} -> username: {username}")

        stored_pass = get_password_for_user(username)
        if not stored_pass:
            response = "NO_USER"
        elif password == stored_pass:
            response = "OK"
        else:
            response = "WRONG_PASSWORD"

        sock.sendto(response.encode(), client_addr)
    except Exception as e:
        print("Error handling request:", e)

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("0.0.0.0", SERVER_PORT))
    print(f"UDP Server listening on port {SERVER_PORT}...")

    while True:
        data, client_addr = sock.recvfrom(BUFFER_SIZE)
        threading.Thread(target=handle_request, args=(sock, data, client_addr), daemon=True).start()

if __name__ == "__main__":
    main()

client.py
import socket

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321
BUFFER_SIZE = 256

def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    server_addr = (SERVER_IP, SERVER_PORT)

    username = input("Enter username: ").strip()
    password = input("Enter password: ").strip()

    message = f"{username} {password}".encode()
    sock.sendto(message, server_addr)

    data, _ = sock.recvfrom(BUFFER_SIZE)
    print("Server response:", data.decode())

    sock.close()

if __name__ == "__main__":
    main()


8.   Build a server that facilitates a peer-to-peer (P2P) file-sharing network. The server maintains a directory of files and connected peers. Clients can request files, and the server connects them to peers that have the requested files. Data transfers happens over TCP.

--tcp

server.py
# tcp_server.py
import socket
import threading

SERVER_PORT = 4321
BUFFER_SIZE = 1024
MAX_FILES = 100

directory = []
directory_lock = threading.Lock()

def trim(s):
    return s.strip()

def remove_file_from_peer(filename, ip, port):
    with directory_lock:
        global directory
        directory = [entry for entry in directory if not (entry['filename'] == filename and entry['ip'] == ip and entry['port'] == port)]

def handle_client(conn, addr):
    try:
        data = conn.recv(BUFFER_SIZE).decode()
        if not data:
            conn.close()
            return
        data = trim(data)
        print(f"[Server] Received: {data} from {addr}")

        if data.startswith("REGISTER"):
            parts = data.split(maxsplit=2)
            port = int(parts[1])
            files = parts[2].split(",")
            with directory_lock:
                for f in files:
                    if len(directory) >= MAX_FILES:
                        break
                    directory.append({'filename': trim(f), 'ip': addr[0], 'port': port})
            conn.send(b"Files registered.\n")

        elif data.startswith("REQUEST"):
            filename = data.split(maxsplit=1)[1]
            found = False
            with directory_lock:
                for entry in directory:
                    if entry['filename'] == filename:
                        msg = f"PEER {entry['ip']}:{entry['port']}\n"
                        conn.send(msg.encode())
                        found = True
                        break
            if not found:
                conn.send(b"NOTFOUND\n")

        elif data.startswith("REMOVE"):
            _, filename, ip, port = data.split()
            remove_file_from_peer(filename, ip, int(port))
            conn.send(b"File removed from previous peer.\n")

        elif data.startswith("LIST"):
            port = int(data.split()[1])
            msg = ""
            with directory_lock:
                for entry in directory:
                    if entry['port'] == port:
                        msg += entry['filename'] + "\n"
            conn.send(msg.encode())

        else:
            conn.send(b"INVALID COMMAND\n")
    except Exception as e:
        print(f"[Server] Error: {e}")
    finally:
        conn.close()

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("", SERVER_PORT))
    s.listen(10)
    print(f"[Server] TCP Server started on port {SERVER_PORT}")

    while True:
        conn, addr = s.accept()
        print(f"[Server] Client connected: {addr}")
        threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()

if __name__ == "__main__":
    main()

client.py
# tcp_client.py
import socket
import threading
import os

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321
BUFFER_SIZE = 1024

def trim(s):
    return s.strip()

def send_to_server(msg):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((SERVER_IP, SERVER_PORT))
    s.send(msg.encode())
    resp = s.recv(BUFFER_SIZE).decode()
    s.close()
    return resp

def peer_server(port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(("", port))
    s.listen(5)
    print(f"[Peer] File server running on port {port}")
    while True:
        c, _ = s.accept()
        filename = c.recv(BUFFER_SIZE).decode()
        if not os.path.isfile(filename):
            c.send(b"NOTFOUND")
            c.close()
            continue
        with open(filename, "rb") as f:
            while True:
                data = f.read(BUFFER_SIZE)
                if not data:
                    break
                c.send(data)
        c.close()

def download_from_peer(ip, port, filename):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((ip, port))
        s.send(filename.encode())
        with open(filename, "wb") as f:
            while True:
                data = s.recv(BUFFER_SIZE)
                if not data:
                    break
                f.write(data)
        print(f"Downloaded '{filename}' from {ip}:{port}")
    except Exception as e:
        print("Cannot connect to peer:", e)
    finally:
        s.close()

def main():
    my_port = int(input("Enter your peer port: "))
    files = input("Enter files to share (comma separated): ")
    files = trim(files)

    msg = f"REGISTER {my_port} {files}"
    resp = send_to_server(msg)
    print(f"[Server] {resp}")

    threading.Thread(target=peer_server, args=(my_port,), daemon=True).start()

    while True:
        choice = int(input("\nOptions:\n1. Request file\n2. Show my files\n3. Exit\nChoice: "))
        if choice == 1:
            filename = input("Enter filename to download: ")
            msg = f"REQUEST {filename}"
            resp = send_to_server(msg)
            print(f"[Server] {resp}")
            if resp.startswith("PEER"):
                ip_port = resp.split()[1]
                ip, port = ip_port.split(":")
                download_from_peer(ip, int(port), filename)

                send_to_server(f"REMOVE {filename} {ip} {port}")
                send_to_server(f"REGISTER {my_port} {filename}")

        elif choice == 2:
            resp = send_to_server(f"LIST {my_port}")
            print("Your current files:\n" + resp)

        elif choice == 3:
            break

if __name__ == "__main__":
    main()

--udp
server.py
# udp_server.py
import socket
import threading

SERVER_PORT = 4321
BUFFER_SIZE = 1024
MAX_FILES = 100

directory = []
directory_lock = threading.Lock()

def trim(s):
    return s.strip()

def remove_file_from_peer(filename, ip, port):
    global directory
    with directory_lock:
        directory = [entry for entry in directory if not (entry['filename'] == filename and entry['ip'] == ip and entry['port'] == port)]

def handle_message(msg, addr, sock):
    msg = trim(msg)
    print(f"[Server] Received: {msg} from {addr}")

    response = ""
    if msg.startswith("REGISTER"):
        parts = msg.split(maxsplit=2)
        port = int(parts[1])
        files = parts[2].split(",")
        with directory_lock:
            for f in files:
                if len(directory) >= MAX_FILES:
                    break
                directory.append({'filename': trim(f), 'ip': addr[0], 'port': port})
        response = "Files registered.\n"

    elif msg.startswith("REQUEST"):
        filename = msg.split(maxsplit=1)[1]
        found = False
        with directory_lock:
            for entry in directory:
                if entry['filename'] == filename:
                    response = f"PEER {entry['ip']}:{entry['port']}\n"
                    found = True
                    break
        if not found:
            response = "NOTFOUND\n"

    elif msg.startswith("REMOVE"):
        _, filename, ip, port = msg.split()
        remove_file_from_peer(filename, ip, int(port))
        response = "File removed from previous peer.\n"

    elif msg.startswith("LIST"):
        port = int(msg.split()[1])
        with directory_lock:
            files = [entry['filename'] for entry in directory if entry['port'] == port]
        response = "\n".join(files) + ("\n" if files else "No files.\n")
    else:
        response = "INVALID COMMAND\n"

    sock.sendto(response.encode(), addr)

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(("", SERVER_PORT))
    print(f"[Server] UDP Server started on port {SERVER_PORT}")

    while True:
        data, addr = s.recvfrom(BUFFER_SIZE)
        threading.Thread(target=handle_message, args=(data.decode(), addr, s), daemon=True).start()

if __name__ == "__main__":
    main()

client.py
# udp_client.py
import socket
import threading
import os

SERVER_IP = "127.0.0.1"
SERVER_PORT = 4321
BUFFER_SIZE = 1024

def trim(s):
    return s.strip()

def send_to_server(sock, server_addr, msg):
    sock.sendto(msg.encode(), server_addr)
    try:
        sock.settimeout(2)  # 2-second timeout
        data, _ = sock.recvfrom(BUFFER_SIZE)
        return data.decode()
    except socket.timeout:
        return "No response"

def peer_server(port):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(("", port))
    print(f"[Peer] UDP file server on port {port}")

    while True:
        data, addr = s.recvfrom(BUFFER_SIZE)
        filename = data.decode()
        if not os.path.isfile(filename):
            s.sendto(b"NOTFOUND", addr)
            continue
        with open(filename, "rb") as f:
            while True:
                chunk = f.read(BUFFER_SIZE)
                if not chunk:
                    break
                s.sendto(chunk, addr)

def download_from_peer(ip, port, filename):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    peer_addr = (ip, port)
    s.sendto(filename.encode(), peer_addr)
    with open(filename, "wb") as f:
        s.settimeout(2)  # 2-second timeout
        while True:
            try:
                data, _ = s.recvfrom(BUFFER_SIZE)
                if not data:
                    break
                f.write(data)
            except socket.timeout:
                break
    print(f"Downloaded '{filename}' from {ip}:{port} (UDP)")
    s.close()

def main():
    my_port = int(input("Enter your peer port: "))
    files = input("Enter files to share (comma separated): ")
    files = trim(files)

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    server_addr = (SERVER_IP, SERVER_PORT)

    # Register files with server
    msg = f"REGISTER {my_port} {files}"
    resp = send_to_server(sock, server_addr, msg)
    print(f"[Server] {resp}")

    threading.Thread(target=peer_server, args=(my_port,), daemon=True).start()

    while True:
        choice = int(input("\nOptions:\n1. Request file\n2. Show my files\n3. Exit\nChoice: "))
        if choice == 1:
            filename = input("Enter filename to download: ")
            msg = f"REQUEST {filename}"
            resp = send_to_server(sock, server_addr, msg)
            print(f"[Server] {resp}")
            if resp.startswith("PEER"):
                ip_port = resp.split()[1]
                ip, port = ip_port.split(":")
                download_from_peer(ip, int(port), filename)

                # Update server
                send_to_server(sock, server_addr, f"REMOVE {filename} {ip} {port}")
                send_to_server(sock, server_addr, f"REGISTER {my_port} {filename}")

        elif choice == 2:
            resp = send_to_server(sock, server_addr, f"LIST {my_port}")
            print("Your current files:\n" + resp)

        elif choice == 3:
            break

if __name__ == "__main__":
    main()


9.   Change the C Example Concurrent Number Guess Bellow to transmit with each answer to a client â€“ the number of total clients that are competing. Also change the client to read the numbers from the standard input and launch a contest in the class during the lab . A client server implementation in c for the number guess problem. The server chooses a random number. The clients connect and send numbers to server. The server returns to each client a status message:

Â·         â€˜Hâ€™ â€“ send a larger number

Â·         â€˜Sâ€™ â€“ send a lower number

Â·         â€˜Gâ€™ â€“ you guessed my number

Â·         â€˜Lâ€™ â€“ another client guessed the number. You are a looser !


--tcp

server.py
import socket
import threading
import random

HOST = ""
PORT = 5000

clients = []
clients_lock = threading.Lock()
game_lock = threading.Lock()

secret_number = random.randint(1, 100)
running = True

print(f"[Server] Secret number = {secret_number}")

def broadcast_lose(winner_sock):
    with clients_lock:
        total = len(clients)
        for c in clients:
            if c != winner_sock:
                c.sendall(f"L {total}".encode())

def handle_client(sock, addr):
    global secret_number

    print(f"[+] Client connected {addr}")

    try:
        while True:
            data = sock.recv(64)
            if not data:
                break

            guess = int(data.decode())
            guessed = False

            with game_lock:
                total = len(clients)
                if guess > secret_number:
                    response = f"S {total}"
                elif guess < secret_number:
                    response = f"H {total}"
                else:
                    response = f"G {total}"
                    guessed = True

            sock.sendall(response.encode())

            if guessed:
                print(f"[WINNER] {addr} guessed {secret_number}")
                broadcast_lose(sock)

                with game_lock:
                    secret_number = random.randint(1, 100)
                    print(f"[New Round] Secret = {secret_number}")

                break

    finally:
        with clients_lock:
            clients.remove(sock)
        sock.close()
        print(f"[-] Client disconnected {addr}")

def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((HOST, PORT))
    server.listen(5)

    print("[Server] TCP listening on port 5000")

    while running:
        client_sock, addr = server.accept()
        with clients_lock:
            clients.append(client_sock)
        threading.Thread(target=handle_client, args=(client_sock, addr), daemon=True).start()

if __name__ == "__main__":
    main()

client.py
import socket

SERVER_IP = "127.0.0.1"
PORT = 5000

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((SERVER_IP, PORT))

print("Connected to server! Guess the number (1â€“100)")

while True:
    guess = input("Enter your guess: ")
    if not guess.isdigit():
        break

    sock.sendall(guess.encode())
    data = sock.recv(64).decode()

    status, total = data.split()
    total = int(total)

    if status == "H":
        print(f"Server: Send a larger number! (Players: {total})")
    elif status == "S":
        print(f"Server: Send a smaller number! (Players: {total})")
    elif status == "G":
        print(f"ðŸŽ‰ You guessed it! (Players: {total})")
        break
    elif status == "L":
        print(f"ðŸ’€ Another player guessed it! You lose! (Players: {total})")
        break

sock.close()

--udp

server.py
import socket
import random
import threading

PORT = 5000
BUFFER = 64

clients = []
clients_lock = threading.Lock()
game_lock = threading.Lock()

secret_number = random.randint(1, 100)
print(f"[Server] Secret number = {secret_number}")

def same_client(a, b):
    return a[0] == b[0] and a[1] == b[1]

def broadcast_lose(sock, winner):
    with clients_lock:
        total = len(clients)
        for c in clients:
            if not same_client(c, winner):
                sock.sendto(f"L {total}".encode(), c)

def main():
    global secret_number

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("", PORT))

    print("[Server] UDP listening on port 5000")

    while True:
        data, addr = sock.recvfrom(BUFFER)
        guess = int(data.decode())

        with clients_lock:
            if not any(same_client(c, addr) for c in clients):
                clients.append(addr)
                print(f"[+] New client {addr}, total={len(clients)}")

        guessed = False
        with game_lock:
            total = len(clients)
            if guess > secret_number:
                response = f"S {total}"
            elif guess < secret_number:
                response = f"H {total}"
            else:
                response = f"G {total}"
                guessed = True

        sock.sendto(response.encode(), addr)

        if guessed:
            print(f"[WINNER] {addr} guessed {secret_number}")
            broadcast_lose(sock, addr)
            with game_lock:
                secret_number = random.randint(1, 100)
                print(f"[New Round] Secret = {secret_number}")

if __name__ == "__main__":
    main()

client.py
import socket

SERVER_IP = "127.0.0.1"
PORT = 5000

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

print("Connected to server! Guess the number (1â€“100)")

while True:
    guess = input("Enter your guess: ")
    if not guess.isdigit():
        break

    sock.sendto(guess.encode(), (SERVER_IP, PORT))
    data, _ = sock.recvfrom(64)

    status, total = data.decode().split()
    total = int(total)

    if status == "H":
        print(f"Server: Send a larger number! (Players: {total})")
    elif status == "S":
        print(f"Server: Send a smaller number! (Players: {total})")
    elif status == "G":
        print(f"ðŸŽ‰ You guessed it! (Players: {total})")
        break
    elif status == "L":
        print(f"ðŸ’€ Another player guessed it! You lose! (Players: {total})")
        break

sock.close()



LAB3
3.   Implement a UDP-based real-time collaborative whiteboard application where multiple clients can draw on a shared canvas. The server manages the canvas state and broadcasts updates to all clients. Use drawing primitives of type line, circle, ellipse, rectangles with contour colors and eventually fill.

--server.py
import socket
import threading
import time

TCP_PORT = 6006
BUFFER_SIZE = 1024

canvas_state = []
pending_updates = []

udp_clients = set()

canvas_lock = threading.Lock()
clients_lock = threading.Lock()

running = True


def udp_broadcast(udp_sock):
    global running
    while running:
        updates = []

        with canvas_lock:
            while pending_updates:
                updates.append(pending_updates.pop(0))

        if updates:
            with clients_lock:
                for cmd in updates:
                    print(f"[UDP] Broadcasting: {cmd}")
                    for client in udp_clients:
                        udp_sock.sendto(cmd.encode(), client)

        time.sleep(0.05)


def handle_client(conn, addr):
    print(f"[TCP] Client connected: {addr}")

    # Receive UDP port
    data = conn.recv(16)
    if not data:
        conn.close()
        return

    udp_port = int(data.decode())
    udp_addr = (addr[0], udp_port)

    with clients_lock:
        udp_clients.add(udp_addr)

    print(f"[UDP] Registered client {udp_addr}")

    # Send initial canvas state
    with canvas_lock:
        for cmd in canvas_state:
            conn.sendall((cmd + "\n").encode())
            time.sleep(0.01)

    # Receive drawing commands
    while True:
        data = conn.recv(BUFFER_SIZE)
        if not data:
            break

        cmd = data.decode().strip()
        print(f"[TCP] Received: {cmd}")

        with canvas_lock:
            canvas_state.append(cmd)
            pending_updates.append(cmd)

    with clients_lock:
        udp_clients.discard(udp_addr)

    print(f"[TCP] Client disconnected: {addr}")
    conn.close()


def main():
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.bind(("", TCP_PORT))
    tcp_sock.listen(5)

    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    print("[Server] TCP listening on port", TCP_PORT)
    print("[Server] UDP broadcasting enabled")

    threading.Thread(target=udp_broadcast, args=(udp_sock,), daemon=True).start()

    try:
        while True:
            conn, addr = tcp_sock.accept()
            threading.Thread(
                target=handle_client, args=(conn, addr), daemon=True
            ).start()
    except KeyboardInterrupt:
        print("\n[Server] Shutting down")

    tcp_sock.close()
    udp_sock.close()


if __name__ == "__main__":
    main()


client.py
import socket
import threading
import sys

SERVER_IP = "127.0.0.1"
SERVER_PORT = 6006
BUFFER_SIZE = 1024

running = True


def udp_listener(port):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("", port))
    sock.settimeout(1.0)

    print(f"[UDP] Listening on port {port}")

    while running:
        try:
            data, _ = sock.recvfrom(BUFFER_SIZE)
            print("[Canvas update]", data.decode())
        except socket.timeout:
            pass

    sock.close()


def tcp_receive_initial(sock):
    sock.settimeout(5.0)
    print("[TCP] Receiving initial canvas...")

    buffer = ""
    while True:
        try:
            data = sock.recv(BUFFER_SIZE)
            if not data:
                break
            buffer += data.decode()
        except socket.timeout:
            break

    for line in buffer.split("\n"):
        if line.strip():
            print("[Initial state]", line)

    print("[TCP] Ready for commands")
    sock.settimeout(None)


def main():
    # Allocate UDP port automatically
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", 0))
    udp_port = udp_sock.getsockname()[1]
    udp_sock.close()

    print("[Client] UDP port:", udp_port)

    threading.Thread(target=udp_listener, args=(udp_port,), daemon=True).start()

    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_IP, SERVER_PORT))

    # Send UDP port to server
    tcp_sock.sendall(str(udp_port).encode())

    tcp_receive_initial(tcp_sock)

    print("\nCommands:")
    print(" line x1 y1 x2 y2 color")
    print(" circle x y r color")
    print(" rect x y w h color [fill]")
    print(" ellipse x y rx ry color [fill]")
    print(" type 'exit' to quit\n")

    try:
        while True:
            cmd = input("> ").strip()
            if cmd == "exit":
                break
            if cmd:
                tcp_sock.sendall(cmd.encode())
    except KeyboardInterrupt:
        pass

    global running
    running = False
    tcp_sock.close()


if __name__ == "__main__":
    main()


1.   The client sends periodical PING datagrams with a random content to a <server> and <port> specified in command line. The server returns back (echoes) the same packets (content). The client checks the content of the received packets to match what was sent and computes the round trip time and displays it to the user â€“ for each sent packet.

server.py
import socket
import sys

BUFFER_SIZE = 1024

def main():
    if len(sys.argv) != 2:
        print("Usage: python udp_server.py <port>")
        return

    port = int(sys.argv[1])

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(("", port))

    print(f"[Server] UDP Echo Server listening on port {port}")

    while True:
        data, addr = sock.recvfrom(BUFFER_SIZE)
        print(f"[Server] Received {len(data)} bytes from {addr}")

        # Echo back the same data
        sock.sendto(data, addr)

if __name__ == "__main__":
    main()

client.py
import socket
import sys
import time
import random
import string

BUFFER_SIZE = 1024
PING_INTERVAL = 1  # seconds


def random_payload(length=16):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))


def main():
    if len(sys.argv) != 3:
        print("Usage: python udp_client.py <server_ip> <server_port>")
        return

    server_ip = sys.argv[1]
    server_port = int(sys.argv[2])

    server_addr = (server_ip, server_port)

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(2.0)

    seq = 1

    print(f"[Client] Pinging {server_ip}:{server_port}\n")

    while True:
        payload = random_payload()
        message = f"{seq}:{payload}"

        send_time = time.time()
        sock.sendto(message.encode(), server_addr)

        try:
            data, _ = sock.recvfrom(BUFFER_SIZE)
            recv_time = time.time()

            rtt = (recv_time - send_time) * 1000  # ms
            received = data.decode()

            if received == message:
                print(f"PING {seq}: RTT = {rtt:.2f} ms")
            else:
                print(f"PING {seq}: CORRUPTED PACKET")

        except socket.timeout:
            print(f"PING {seq}: Request timed out")

        seq += 1
        time.sleep(PING_INTERVAL)


if __name__ == "__main__":
    main()

4.   Implement the Chat server example (see the link bellow) using UDP and TCP â€“only this time each client should contact the server just for registration. All communication happens directly between the peers (clients) without passing trough the server. Each client maintains an endpoint (TCP/UDP) with the server just for learning the arrival/departure of other clients. You create a mesh architecture where all clients connect directly between each others.
server.py
import socket
import threading

SERVER_PORT = 7000

clients = {}  # username -> (ip, udp_port, conn)
lock = threading.Lock()


def handle_client(conn, addr):
    try:
        data = conn.recv(1024).decode().strip()
        _, username, udp_port = data.split()
        udp_port = int(udp_port)

        with lock:
            # Notify new client about existing peers
            for user, (ip, port, _) in clients.items():
                conn.sendall(f"JOIN {user} {ip} {port}\n".encode())

            # Notify existing peers
            for _, (_, _, c) in clients.items():
                c.sendall(f"JOIN {username} {addr[0]} {udp_port}\n".encode())

            clients[username] = (addr[0], udp_port, conn)

        print(f"[Server] {username} joined from {addr[0]}:{udp_port}")

        # Keep connection alive
        while conn.recv(1024):
            pass

    except:
        pass
    finally:
        with lock:
            if 'username' in locals() and username in clients:
                del clients[username]
                for _, (_, _, c) in clients.items():
                    c.sendall(f"LEAVE {username}\n".encode())

        print(f"[Server] {addr} disconnected")
        conn.close()


def main():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(("", SERVER_PORT))
    sock.listen(10)

    print(f"[Server] Registration server running on port {SERVER_PORT}")

    while True:
        conn, addr = sock.accept()
        threading.Thread(target=handle_client, args=(conn, addr), daemon=True).start()


if __name__ == "__main__":
    main()

client.py
import socket
import threading

SERVER_IP = "127.0.0.1"
SERVER_PORT = 7000
BUFFER = 1024

peers = {}        # username -> (ip, port)
running = True


def udp_listener(udp_sock):
    while running:
        try:
            data, addr = udp_sock.recvfrom(BUFFER)
            print(data.decode())
        except:
            break


def tcp_listener(tcp_sock):
    global running
    while running:
        try:
            data = tcp_sock.recv(BUFFER)
            if not data:
                break

            msg = data.decode().strip()
            parts = msg.split()

            if parts[0] == "JOIN":
                user, ip, port = parts[1], parts[2], int(parts[3])
                peers[user] = (ip, port)
                print(f"[Peer joined] {user} {ip}:{port}")

            elif parts[0] == "LEAVE":
                user = parts[1]
                peers.pop(user, None)
                print(f"[Peer left] {user}")

        except:
            break


def main():
    global running

    # === Terminal input instead of command line ===
    username = input("Enter username: ").strip()
    udp_port = int(input("Enter UDP port: ").strip())

    # UDP socket for peer communication
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", udp_port))

    threading.Thread(
        target=udp_listener, args=(udp_sock,), daemon=True
    ).start()

    # TCP connection to registration server
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_IP, SERVER_PORT))
    tcp_sock.sendall(f"REGISTER {username} {udp_port}\n".encode())

    threading.Thread(
        target=tcp_listener, args=(tcp_sock,), daemon=True
    ).start()

    print("\nType messages to broadcast to all peers.")
    print("Type 'exit' to quit.\n")

    while True:
        msg = input("> ")
        if msg.lower() == "exit":
            break

        for user, (ip, port) in peers.items():
            udp_sock.sendto(
                f"MSG {username}: {msg}".encode(),
                (ip, port)
            )

    running = False
    tcp_sock.close()
    udp_sock.close()


if __name__ == "__main__":
    main()


5.      Write an UDP broadcast application that serves as client and server at the same time. The application is started with the network broadcast address (<NBCAST>) as argument in the command line.

1.       Upon launching the application listens on UDP port 7777.

2.    Every 3 seconds the application sends a UDP broadcast message to NBCAST port 7777 with the format: TIMEQUERY\0 (string)

3.    Whenever the application receives a TIMEQUERY demand it answers to the source IP:port with a string message: TIME HH:MM:SS\0 (current time) using unicast.

4.    Every 10 seconds the application sends a UDP broadcast message to NBCAST port 7777 with the format:  DATEQUERY\0 (string)

5.    Whenever the application receives a DATEQUERY demand it answers to the source IP:port with a string message: DATE DD:MM:YYYY\0 (current date) using unicast.

6.    The application will keep a list of peers (that answer to broadcast â€“ IP:portno) and update the information anytime a unicast message is received upon a broadcast.

7.    When an entry in a list does not have any answer for 3 consecutive broadcasts it will be removed from the list.

8.    The list will be displayed (ip,date, time) on the screen upon each update (using a screen positioning api like conio or by erasing the screen before each update).

9.    Every malformed request/response received will be counted and displayed at the end of a screen update. You will have a list of malformed messages displayed with their source IP address. The list should be limited in size and implemented as a queue. Recent messages are added to the head and old messages are moving towards the tail.


import socket
import sys
import threading
import time
from collections import deque
from datetime import datetime

PORT = 7777
BUFFER = 512

MAX_MALFORMED = 10
MAX_MISSED = 3

peers = {}  
# ip -> { "date": str, "time": str, "missed": int }

malformed = deque(maxlen=MAX_MALFORMED)
lock = threading.Lock()


def clear_screen():
    print("\033[2J\033[H", end="")


def display():
    clear_screen()
    print("===== PEERS (ip | date | time | missed) =====")
    for ip, p in peers.items():
        print(f"{ip:15} | {p['date']:10} | {p['time']:8} | {p['missed']}")
    print("\n===== MALFORMED (recent first) =====")
    for ip, msg in malformed:
        print(f"{ip}: {msg}")
    print("\nCtrl+C to exit")


def now_time():
    return datetime.now().strftime("%H:%M:%S")


def now_date():
    return datetime.now().strftime("%d:%m:%Y")


def receiver(sock):
    while True:
        data, addr = sock.recvfrom(BUFFER)
        msg = data.decode(errors="ignore").strip("\0")
        src_ip = addr[0]

        with lock:
            if msg == "TIMEQUERY":
                reply = f"TIME {now_time()}\0"
                sock.sendto(reply.encode(), addr)

            elif msg == "DATEQUERY":
                reply = f"DATE {now_date()}\0"
                sock.sendto(reply.encode(), addr)

            elif msg.startswith("TIME "):
                time_part = msg[5:]
                peer = peers.setdefault(src_ip, {"date": "-", "time": "-", "missed": 0})
                peer["time"] = time_part
                peer["missed"] = 0
                display()

            elif msg.startswith("DATE "):
                date_part = msg[5:]
                peer = peers.setdefault(src_ip, {"date": "-", "time": "-", "missed": 0})
                peer["date"] = date_part
                peer["missed"] = 0
                display()

            else:
                malformed.appendleft((src_ip, msg))
                display()


def sender(sock, broadcast_addr):
    counter = 0
    dest = (broadcast_addr, PORT)

    while True:
        time.sleep(1)
        counter += 1

        with lock:
            if counter % 3 == 0:
                sock.sendto(b"TIMEQUERY\0", dest)
                for p in peers.values():
                    p["missed"] += 1

            if counter % 10 == 0:
                sock.sendto(b"DATEQUERY\0", dest)

            # remove peers with too many misses
            removed = [ip for ip, p in peers.items() if p["missed"] >= MAX_MISSED]
            for ip in removed:
                del peers[ip]

            if removed:
                display()


def main():
    if len(sys.argv) != 2:
        print("Usage: python udp_peer.py <NBCAST>")
        return

    broadcast_ip = sys.argv[1]

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.bind(("", PORT))

    print(f"UDP Peer running on port {PORT}")
    print(f"Broadcast address: {broadcast_ip}")

    threading.Thread(target=receiver, args=(sock,), daemon=True).start()
    threading.Thread(target=sender, args=(sock, broadcast_ip), daemon=True).start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("\nExiting...")


if __name__ == "__main__":
    main()


Write a pair of TCP/IP applications (SERVER, CLIENT) where each CLIENT connects to the SERVER on port 7000 over TCP. The server keeps a list of all connected CLIENTS (ip and port) and sends that list to each CLIENT upon connection. The server also sends incremental changes to the list to each of the connected CLIENTS whenever a new CLIENT arrives or when a CLIENT closes its TCP connection to the server. 
Each CLIENT reads messages from the standard input and sends that message over UDP to all the other CLIENTS registered to the server (the list is kept by each CLIENT and updated by the SERVER). Users can type in messages at the standard input and each message will be sent by the CLIENT to all other registered CLIENTS through UDP. Whenever the user enters a message with the content â€œQUITâ€ - that CLIENT disconnects its TCP connection from the SERVER and closes its UDP socket (the â€œQUITâ€ message is not sent to all other clients). Upon receiving a list incremental update, each CLIENT displays a message stating the client action (Ex: : Client 192.168.0.3:5000 has disconnectedâ€ or â€œClient 192.168.0.3:5000 has connectedâ€)  

server.py
import socket
import threading

PORT = 7000
clients = []  # list of (ip, udp_port, tcp_socket)
lock = threading.Lock()


def broadcast(msg, exclude=None):
    with lock:
        for ip, port, sock in clients:
            if sock != exclude:
                sock.sendall(msg.encode())


def send_client_list(sock):
    with lock:
        msg = "LIST "
        for ip, port, _ in clients:
            msg += f"{ip}:{port} "
        sock.sendall(msg.encode())


def handle_client(client_sock, addr):
    try:
        udp_port = int(client_sock.recv(32).decode())
    except:
        client_sock.close()
        return

    ip = addr[0]

    with lock:
        clients.append((ip, udp_port, client_sock))

    print(f"Client {ip}:{udp_port} connected")

    send_client_list(client_sock)
    broadcast(f"JOIN {ip}:{udp_port}", exclude=client_sock)

    try:
        while client_sock.recv(32):
            pass
    except:
        pass

    with lock:
        clients[:] = [c for c in clients if c[2] != client_sock]

    print(f"Client {ip}:{udp_port} disconnected")
    broadcast(f"LEAVE {ip}:{udp_port}", exclude=client_sock)
    client_sock.close()


def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("", PORT))
    server.listen()

    print("Server listening on port 7000")

    while True:
        sock, addr = server.accept()
        threading.Thread(target=handle_client, args=(sock, addr), daemon=True).start()


if __name__ == "__main__":
    main()


client.py

import socket
import threading

SERVER_PORT = 7000
BUFFER = 512

peers = []  # list of (ip, port)
lock = threading.Lock()


def udp_listener(udp_sock):
    while True:
        data, addr = udp_sock.recvfrom(BUFFER)
        print(f"UDP from {addr[0]}:{addr[1]} -> {data.decode()}")


def tcp_listener(tcp_sock):
    global peers

    while True:
        data = tcp_sock.recv(BUFFER)
        if not data:
            break

        msg = data.decode().strip()

        if msg.startswith("LIST "):
            with lock:
                peers.clear()
                parts = msg[5:].split()
                for p in parts:
                    ip, port = p.split(":")
                    peers.append((ip, int(port)))
            print(f"Updated peer list ({len(peers)} peers)")

        elif msg.startswith("JOIN "):
            ip, port = msg[5:].split(":")
            with lock:
                peers.append((ip, int(port)))
            print(f"Client {ip}:{port} has connected")

        elif msg.startswith("LEAVE "):
            ip, port = msg[6:].split(":")
            with lock:
                peers = [p for p in peers if not (p[0] == ip and p[1] == int(port))]
            print(f"Client {ip}:{port} has disconnected")


def main():
    server_ip = input("Enter server IP: ")

    # TCP
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((server_ip, SERVER_PORT))

    # UDP
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", 0))
    udp_port = udp_sock.getsockname()[1]

    tcp_sock.sendall(str(udp_port).encode())
    print(f"Connected to server. My UDP port: {udp_port}")

    threading.Thread(target=tcp_listener, args=(tcp_sock,), daemon=True).start()
    threading.Thread(target=udp_listener, args=(udp_sock,), daemon=True).start()

    while True:
        msg = input("> ")
        if msg == "QUIT":
            break

        with lock:
            for ip, port in peers:
                udp_sock.sendto(msg.encode(), (ip, port))

    tcp_sock.close()
    udp_sock.close()
    print("Disconnected.")


if __name__ == "__main__":
    main()



Implement a distributed quiz to assess your students' ability to perform simple
arithmetical expressions, using both TCP and UDP for communication.
Donâ€™t focus on actually implementing the logic of solving the arithmetical
expression on the client side. You can get a maximum grade even if you
send random values as the studentâ€™s answer.
Server (teacher)
Broadcasts port 7777, from 2 to 2 seconds, a list of simple arithmetical expressions as a string, in which the
arithmetical expressions are separated by a semicolon (;).
For example, the server might send the string â€œ10+2;4/2;3+1â€, and there are three questions: 10+2, 4/2 and 3
+ 1.
The server will also handle TCP connections from each student to get the answers from the quiz. After a
student sends the N answers (where N is the number of questions), the server computes the score and sends it
to the student via TCP.
The quiz will end after 12 seconds. After this amount of time has passed, the server stops broadcasting the test
and waits for all the answers from the students that are already connected to the test.
Clients (students):
The students listen on UDP on port 7777 to get the test from the server (teacher).
Upon receiving the test, the students connect to the server using a TCP connection on port 1234, and then
send their answers to the server (teacher). First the student sends the question index and then the answer for
that question (pay attention, these are numerical data!). For example, to send the answer for the first question,
the student first sends the value 0 (the index of the question) and then 12 (the answer for that question).
A student can send at most N answers (where N is the number of questions)!
Rubric:
1p: Default
4p: Sending, through TCP a string and then a several numbers.
2.5p: Using both TCP and UDP for communication.
2.5p: Server (teacher) can handle multiple clients at once

server.py
import socket
import threading
import time

expressions = []
correct_answers = []
quiz_active = True


def evaluate_expression(expr):
    try:
        a, op, b = int(expr[0]), expr[1], int(expr[2:])
        if op == '+': return a + b
        if op == '-': return a - b
        if op == '*': return a * b
        if op == '/': return a // b if b != 0 else 0
    except:
        return 0


def udp_broadcast():
    global quiz_active

    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

    quiz_str = ";".join(expressions).encode()

    print("[SERVER] Broadcasting quiz every 2 seconds for 12 seconds...")
    for _ in range(6):
        udp_sock.sendto(quiz_str, ("255.255.255.255", 7777))
        print("[SERVER] Broadcasted quiz:", quiz_str.decode())
        time.sleep(2)

    quiz_active = False
    udp_sock.close()
    print("[SERVER] Broadcast ended.")


def handle_student(client_sock, addr):
    print(f"[SERVER] Student connected from {addr[0]}")

    total = len(expressions)
    answers = [None] * total
    received = 0

    while received < total:
        try:
            q_idx = int.from_bytes(client_sock.recv(4), "big")
            ans = int.from_bytes(client_sock.recv(4), "big")
        except:
            break

        if 0 <= q_idx < total and answers[q_idx] is None:
            answers[q_idx] = ans
            received += 1
            print(f"[SERVER] Received from {addr[0]}: Q{q_idx} -> {ans}")

    score = sum(
        1 for i in range(total)
        if answers[i] == correct_answers[i]
    )

    client_sock.send(score.to_bytes(4, "big"))
    print(f"[SERVER] Sent score {score} to {addr[0]}")
    client_sock.close()


def tcp_server():
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.bind(("", 1234))
    tcp_sock.listen()

    print("[SERVER] Listening for TCP answers on port 1234...")

    while True:
        client, addr = tcp_sock.accept()
        threading.Thread(
            target=handle_student,
            args=(client, addr),
            daemon=True
        ).start()


# ---- MAIN ----
quiz_input = input(
    "Enter arithmetic expressions separated by semicolons (e.g. 2+2;3*4;6/2):\n> "
)

for expr in quiz_input.split(";"):
    expressions.append(expr)
    correct_answers.append(evaluate_expression(expr))

print(f"[SERVER] Loaded {len(expressions)} expressions.")

threading.Thread(target=udp_broadcast).start()
tcp_server()

client.py
import socket
import time
import random


def listen_udp():
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", 7777))

    data, addr = udp_sock.recvfrom(256)
    quiz = data.decode()
    server_ip = addr[0]

    print(f"[CLIENT] Received quiz from {server_ip}: {quiz}")
    udp_sock.close()
    return server_ip, quiz


def send_answers(server_ip, quiz):
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((server_ip, 1234))

    questions = quiz.split(";")
    print("[CLIENT] Sending random answers...")

    for i in range(len(questions)):
        ans = random.randint(1, 20)
        tcp_sock.send(i.to_bytes(4, "big"))
        tcp_sock.send(ans.to_bytes(4, "big"))
        print(f"[CLIENT] Sent answer Q{i} -> {ans}")
        time.sleep(0.3)

    score = int.from_bytes(tcp_sock.recv(4), "big")
    print("[CLIENT] Final score:", score)

    tcp_sock.close()


# ---- MAIN ----
server_ip, quiz = listen_udp()
send_answers(server_ip, quiz)



Implementarea in C a unei perechi de programe client/server care comunica prin socket-uri TCP/IP pentru rezolvarea problemelor:
1. Schimb de mesaje intre client si server pentru obtinerea problemei de la test.
2. Se da un sir de caractere si un caracter. Se cere sa se elimine din sir prima aparitie a caracterului.
3. Se da un numar. Se cere sa se afiseze toate numerele prime mai mici ca numarul dat.
4. Un client trimite unui server doua siruri de numere. Serverul va returna clientului sirul de numere care se regaseste in cel de-al doilea sir
dar nu se regasesc in primul.
5. Un client trimite unui server doua siruri de caractere. Serverul ii raspunde clientului cu caracterul care se regaseste de cele mai multe ori pe
pozitii identice in cele doua siruri si cu numarul de aparitii ale acestui caracter.

server.py
import socket
import threading

PORT = 12345
BUF_SIZE = 1024


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True


def handle_client(client_sock):
    try:
        option = int.from_bytes(client_sock.recv(4), "big")

        if option == 1:
            msg = client_sock.recv(BUF_SIZE).decode()
            print("[Server] Received:", msg)
            client_sock.sendall(b"Server: Am primit mesajul tau!\0")

        elif option == 2:
            text = client_sock.recv(BUF_SIZE).decode()
            ch = client_sock.recv(1).decode()

            if ch in text:
                text = text.replace(ch, "", 1)

            client_sock.sendall(text.encode() + b"\0")

        elif option == 3:
            num = int.from_bytes(client_sock.recv(4), "big")
            primes = [str(i) for i in range(2, num) if is_prime(i)]
            result = " ".join(primes)
            client_sock.sendall(result.encode() + b"\0")

        elif option == 4:
            s1 = client_sock.recv(BUF_SIZE).decode()
            s2 = client_sock.recv(BUF_SIZE).decode()

            set1 = set(map(int, s1.split()))
            result = [x for x in map(int, s2.split()) if x not in set1]

            out = " ".join(map(str, result))
            client_sock.sendall(out.encode() + b"\0")

        elif option == 5:
            s1 = client_sock.recv(BUF_SIZE).decode()
            s2 = client_sock.recv(BUF_SIZE).decode()

            freq = {}
            for a, b in zip(s1, s2):
                if a == b:
                    freq[a] = freq.get(a, 0) + 1

            if freq:
                best = max(freq, key=freq.get)
                result = f"{best} {freq[best]}"
            else:
                result = "? 0"

            client_sock.sendall(result.encode() + b"\0")

    finally:
        client_sock.close()


def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(("", PORT))
    server.listen()

    print(f"[Server] Listening on port {PORT}...")

    while True:
        client, addr = server.accept()
        print("[Server] Client connected:", addr)
        threading.Thread(target=handle_client, args=(client,), daemon=True).start()


if __name__ == "__main__":
    main()

client.py
import socket

SERVER_IP = "127.0.0.1"
PORT = 12345
BUF_SIZE = 1024

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((SERVER_IP, PORT))

option = int(input("Selectati problema (1-5): "))
sock.sendall(option.to_bytes(4, "big"))

if option == 1:
    msg = input("Introduceti mesaj: ")
    sock.sendall(msg.encode() + b"\0")
    print("Raspuns server:", sock.recv(BUF_SIZE).decode())

elif option == 2:
    text = input("Introduceti sirul: ")
    ch = input("Caracterul de eliminat: ")[0]
    sock.sendall(text.encode() + b"\0")
    sock.sendall(ch.encode())
    print("Rezultat:", sock.recv(BUF_SIZE).decode())

elif option == 3:
    num = int(input("Introduceti un numar: "))
    sock.sendall(num.to_bytes(4, "big"))
    print("Numere prime:", sock.recv(BUF_SIZE).decode())

elif option == 4:
    s1 = input("Primul sir de numere: ")
    s2 = input("Al doilea sir de numere: ")
    sock.sendall(s1.encode() + b"\0")
    sock.sendall(s2.encode() + b"\0")
    print("Rezultat:", sock.recv(BUF_SIZE).decode())

elif option == 5:
    s1 = input("Primul sir: ")
    s2 = input("Al doilea sir: ")
    sock.sendall(s1.encode() + b"\0")
    sock.sendall(s2.encode() + b"\0")
    print("Rezultat:", sock.recv(BUF_SIZE).decode())

sock.close()



"""
Implement a server application that generates a random integer P and communicates to the clients the number of digits of
that number â€“ when the client connects.

Implement a client application that receives from a server the number of digits of P. The client generates a random
digit every N seconds and sends the digit to the server. The server answers with the positions where the digit is found
on the serverâ€™s number.

Spawn multiple clients. The server will announce all clients when it has a winner using UDP. You should design a method
for the server to infer the IP and port where is should communicate with each peer over UDP.

server.py
import socket
import threading
import random
import time

TCP_PORT = 12345

clients = []  # list of (tcp_sock, addr, udp_port)
clients_lock = threading.Lock()
game_over = False

# Generate secret number
digits_count = 4
secret = ''.join(str(random.randint(0, 9)) for _ in range(digits_count))
print(f"[Server] Secret number: {secret}")

def send_udp_announcement(msg):
    """Send a UDP message to all connected clients."""
    with clients_lock:
        for tcp_sock, addr, udp_port in clients:
            try:
                udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                udp_sock.sendto(msg.encode(), (addr[0], udp_port))
                udp_sock.close()
            except Exception as e:
                print(f"[Server] UDP send error: {e}")

def handle_client(tcp_sock, addr, udp_port):
    global game_over
    print(f"[Server] Client {addr[0]}:{addr[1]} connected (UDP {udp_port})")

    # Send number of digits
    tcp_sock.send(digits_count.to_bytes(4, "big"))

    total_found = 0  # track total digits guessed

    while not game_over:
        try:
            data = tcp_sock.recv(4)
            if not data:
                break
            guess = int.from_bytes(data, "big")

            # Check positions
            response = []
            for i, d in enumerate(secret):
                if int(d) == guess:
                    response.append(str(i))
            if not response:
                resp_str = "none"
            else:
                resp_str = " ".join(response)

            tcp_sock.send(resp_str.encode())

            # Update total_found
            total_found += len(response)
            if total_found >= digits_count and not game_over:
                game_over = True
                msg = f"Winner: {addr[0]}:{addr[1]}"
                print(f"[Server] {msg}")
                send_udp_announcement(msg)

        except:
            break

    tcp_sock.close()
    print(f"[Server] Client {addr[0]}:{addr[1]} disconnected")

def tcp_server():
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(("", TCP_PORT))
    server_sock.listen(5)
    print(f"[Server] Listening on TCP port {TCP_PORT}")

    while not game_over:
        try:
            client_sock, client_addr = server_sock.accept()

            # Receive UDP port
            data = client_sock.recv(4)
            if not data:
                client_sock.close()
                continue
            udp_port = int.from_bytes(data, "big")

            with clients_lock:
                clients.append((client_sock, client_addr, udp_port))

            threading.Thread(target=handle_client, args=(client_sock, client_addr, udp_port), daemon=True).start()
        except:
            break

    server_sock.close()
    print("[Server] Server shutting down.")

if __name__ == "__main__":
    tcp_server()

client.py

import socket
import threading
import time
import random

SERVER_IP = "127.0.0.1"
TCP_PORT = 12345

def listen_udp(udp_port):
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", udp_port))
    print(f"[Client] Listening on UDP port {udp_port}")

    while True:
        try:
            data, addr = udp_sock.recvfrom(256)
            msg = data.decode()
            print(f"\n[UDP] {msg}")
            if "Winner" in msg:
                break
        except:
            break

    udp_sock.close()
    print("[Client] UDP listener closed.")

def client_worker(client_id):
    # Create UDP socket and let OS pick port
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", 0))
    udp_port = udp_sock.getsockname()[1]
    udp_sock.close()  # We'll only send port to server; listening handled in thread

    # Start UDP listener thread
    udp_thread = threading.Thread(target=listen_udp, args=(udp_port,), daemon=True)
    udp_thread.start()
    time.sleep(0.1)  # small delay to ensure listener is ready

    # Connect TCP to server
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_IP, TCP_PORT))
    # Send UDP port to server
    tcp_sock.sendall(udp_port.to_bytes(4, "big"))

    # Receive number of digits
    digits_count_data = tcp_sock.recv(4)
    if not digits_count_data:
        print(f"[Client {client_id}] Server closed connection immediately.")
        tcp_sock.close()
        return
    digits_count = int.from_bytes(digits_count_data, "big")
    print(f"[Client {client_id}] Secret number has {digits_count} digits.")

    while True:
        # Generate a random digit every 2 seconds
        guess = random.randint(0, 9)
        tcp_sock.sendall(guess.to_bytes(4, "big"))

        try:
            resp = tcp_sock.recv(128)
            if not resp:
                print(f"[Client {client_id}] Server closed connection.")
                break
            resp_msg = resp.decode()
            print(f"[Client {client_id}] Sent {guess} â†’ positions: {resp_msg}")
        except:
            break

        time.sleep(2)

    tcp_sock.close()
    print(f"[Client {client_id}] TCP connection closed.")

if __name__ == "__main__":
    # Spawn multiple clients
    num_clients = 3
    threads = []
    for i in range(num_clients):
        t = threading.Thread(target=client_worker, args=(i+1,))
        t.start()
        threads.append(t)
        time.sleep(0.5)  # stagger connections slightly

    for t in threads:
        t.join()



Proiect - â€žNumÄƒr Echilibratâ€ (TCP + UDP, doi clienti)
Se doreste implementarea unui proiect de tip -"NumÄƒr Echilibrat" intre un server si mai multi clienti, folosind o conexiune hibridÄƒ TCP/UDP.

1. Etapa de conectare (TCP)
- Serverul porneÈ™te È™i asteaptÄƒ conexiuni TCP din partea clienÈ›ilor.
- Fiecare client se conecteazÄƒ la server si transmite numele de utilizator (ID).
DunÄƒ ce s-a creat conexiunea, serverul trimite prin TCP un mesaj catre fiecare client
pentru a comuta pe comunicare UDP.
- Serverul inchide conexiunile TCP si incepe comunicarea UDP.

2. Comunicarea (UDP)
-Jocul se desfasoarÄƒ prin mesaje UDP intre server si clienti
- Fiecare client trimite serverului numere intregi pozitive
- Transmiterea numerelor continuÄƒ pÃ¢nÄƒ cÃ¢nd clientul trimite numÄƒrul 0. moment Ã®n care
jocul acelui client se incheie.

3. FuncÈ›ionarea serverului
Serverul primeÈ™te fiecare numÄƒr È™i il afiÈ™eazÄƒ pe ecran.
- Pentru fiecare numÄƒr primit (diferit de 0), serverul calculeazÄƒ È™i trimite clientului num
echilibrat imediat urmÄƒtor.
- Un numÄƒr este considerat echilibrat dacÄƒ suma cifrelor de pe poziÈ›iile impare este e
suma cifrelor de pe poziÈ›iile pare.

Exemple:
. DacÄƒ clientul trimite 130, serverul rÄƒspunde cu 132.

4. ÃŽncheierea problemei
- Comunicarea pentru fiecare client se terminÄƒ cÃ¢nd acesta trimite numÄƒrul 0.

server.py
import socket
import threading

TCP_PORT = 5000
UDP_PORT = 6000
BUF_SIZE = 1024

clients = []
clients_lock = threading.Lock()


def is_balanced(n):
    s = str(n)
    sum_even = sum(int(s[i]) for i in range(1, len(s), 2))
    sum_odd = sum(int(s[i]) for i in range(0, len(s), 2))
    return sum_even == sum_odd


def next_balanced(n):
    n += 1
    while not is_balanced(n):
        n += 1
    return n


def handle_tcp_client(conn, addr):
    try:
        data = conn.recv(BUF_SIZE).decode()
        parts = data.strip().split()
        if len(parts) != 3 or parts[0] != "REGISTER":
            print(f"[TCP] Invalid message from {addr}: {data}")
            conn.close()
            return

        name = parts[1]
        udp_port = int(parts[2])

        with clients_lock:
            clients.append((addr[0], udp_port, name))

        print(f"[TCP] Registered client {name} @ {addr[0]}:{udp_port}")

        # Tell client to switch to UDP
        conn.send(b"SWITCH_UDP\n")
    finally:
        conn.close()


def udp_handler():
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", UDP_PORT))
    print(f"[UDP] Listening on port {UDP_PORT}...")

    while True:
        data, client_addr = udp_sock.recvfrom(BUF_SIZE)
        try:
            n = int(data.decode())
        except ValueError:
            continue

        print(f"[UDP] Received {n} from {client_addr}")
        if n == 0:
            continue

        balanced = next_balanced(n)
        udp_sock.sendto(str(balanced).encode(), client_addr)


def main():
    # TCP server
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.bind(("", TCP_PORT))
    tcp_sock.listen(5)
    print(f"[TCP] Listening on port {TCP_PORT}...")

    # Start UDP thread
    udp_thread = threading.Thread(target=udp_handler, daemon=True)
    udp_thread.start()

    while True:
        conn, addr = tcp_sock.accept()
        threading.Thread(target=handle_tcp_client, args=(conn, addr), daemon=True).start()


if __name__ == "__main__":
    main()

client.py
import socket
import threading

SERVER_IP = "127.0.0.1"
TCP_PORT = 5000
UDP_PORT = 7001  # change if multiple clients
BUF_SIZE = 1024


def udp_receive(udp_sock):
    while True:
        data, addr = udp_sock.recvfrom(BUF_SIZE)
        print(f"[SERVER -> YOU] Next balanced number: {data.decode()}")


def main():
    name = input("Enter your name: ")
    udp_port = input("Enter your UDP port: ")

    # TCP registration
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_IP, TCP_PORT))
    tcp_sock.send(f"REGISTER {name} {udp_port}".encode())

    data = tcp_sock.recv(BUF_SIZE).decode()
    if "SWITCH_UDP" in data:
        print("Server instructed to switch to UDP.")
    tcp_sock.close()

    # UDP communication
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", int(udp_port)))

    threading.Thread(target=udp_receive, args=(udp_sock,), daemon=True).start()

    server_addr = (SERVER_IP, 6000)  # server UDP port
    while True:
        n = int(input("Enter number (0 to quit): "))
        udp_sock.sendto(str(n).encode(), server_addr)
        if n == 0:
            print("Session ended.")
            break

    udp_sock.close()


if __name__ == "__main__":
    main()




Enunt: SÄƒ se genereze o pereche de programe client-server care sa respecte cerintele de mai jos:
1. (1p) Serverul si Clientul primesc IP-ul È™i porturile TCP din linia de comandÄƒ:
2. (1p) Serverul creeazÄ un socket TCP È™i ascultÄƒ conexiuni.
3. (1p) Serverul TCP deserveste concurent Clientii.
4. (3p) In comunicarea cu Serverul, Clientul primeÈ™te de la Server:
- un È™ir de caractere (text)
- o comandÄƒ: UPPER, LOWER, REVERSE
(UPPER + converteÈ™te È™irul la majuscule, LOWER + converteÈ™te È™irul la litere mici, REVERSE + inverseazÄƒ È™irul)
È™i trimite rezultatul calculului Ã®napoi Serverului TCP.
5. (1p) Apoi, Serverul si Clientul devin o pereche de programe emiÈ›Äƒtor-receptor UDP care ruleaza pe portul UDP transmis
anterior de catre server.
6. (1p) Serverul trimite Clientului un È™ir de caractere.
7. (1p) Clientul caspunde Serverului cu textul FOUND dacÄƒ È™irul apare ca subÈ™ir Ã®n oricare din È™irurile de paractere primite
anterior prin TCP sau NOT FOUND dacÄƒ nu apare.
Nota: toate sicurile se citesc de la tastatura.
(1p) oficiu
Exemplu:
Text: Hello World
Comanda (UPPER/LOWER/REVERSE): REVERSE
Raspuns TCP: dlrow olleH
Text de verificat UDP: World
Raspuns UDP: FOUND

server.py
import socket
import threading

BUF_SIZE = 1024

def is_upper_lower_reverse(s, cmd):
    if cmd == "UPPER":
        return s.upper()
    elif cmd == "LOWER":
        return s.lower()
    elif cmd == "REVERSE":
        return s[::-1]
    return s

# TCP handler for each client
def handle_tcp_client(conn, addr):
    tcp_received = []

    try:
        while True:
            text = input(f"[TCP] Enter text for client {addr}: ").strip()
            if not text:
                text = "Hello World"
            while True:
                command = input("[TCP] Command (UPPER/LOWER/REVERSE): ").strip().upper()
                if command in ("UPPER", "LOWER", "REVERSE"):
                    break
                print("Invalid command.")

            conn.send(f"{text}|{command}".encode())
            response = conn.recv(BUF_SIZE)
            if not response:
                break
            result = response.decode().strip()
            print(f"[TCP] Client {addr} responded: {result}")
            tcp_received.append(result)

            cont = input("[TCP] Continue TCP with this client? (y/n): ").strip().lower()
            if cont != 'y':
                break

        # Ask UDP port for client
        while True:
            udp_port_str = input(f"[TCP] Enter UDP port for client {addr}: ").strip()
            if udp_port_str.isdigit():
                udp_port = int(udp_port_str)
                break
            print("Invalid port.")
    finally:
        conn.close()
        # Start UDP communication
        threading.Thread(target=handle_udp_client, args=(addr[0], udp_port, tcp_received), daemon=True).start()


def handle_udp_client(client_ip, udp_port, tcp_received):
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", 0))  # random server port

    udp_text = input(f"[UDP] Enter text to send to client {client_ip}:{udp_port}: ").strip()
    udp_sock.sendto(udp_text.encode(), (client_ip, udp_port))

    data, addr = udp_sock.recvfrom(BUF_SIZE)
    print(f"[UDP] Client {addr} responded: {data.decode()}")

    udp_sock.close()


def main():
    IP = input("Enter server IP to bind: ").strip()
    TCP_PORT = int(input("Enter TCP port to bind: ").strip())

    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.bind((IP, TCP_PORT))
    tcp_sock.listen(5)
    print(f"[TCP] Server listening on {IP}:{TCP_PORT}")

    while True:
        conn, addr = tcp_sock.accept()
        print(f"[TCP] Client connected: {addr}")
        threading.Thread(target=handle_tcp_client, args=(conn, addr), daemon=True).start()


if __name__ == "__main__":
    main()

client.py
import socket

BUF_SIZE = 1024

def main():
    SERVER_IP = input("Enter server IP: ").strip()
    TCP_PORT = int(input("Enter server TCP port: ").strip())

    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_IP, TCP_PORT))

    tcp_received = []

    # TCP communication
    while True:
        data = tcp_sock.recv(BUF_SIZE)
        if not data:
            break
        text_cmd = data.decode().strip()
        if "|" not in text_cmd:
            break
        text, command = text_cmd.split("|")
        if command == "UPPER":
            result = text.upper()
        elif command == "LOWER":
            result = text.lower()
        elif command == "REVERSE":
            result = text[::-1]
        else:
            result = text
        tcp_received.append(result)
        tcp_sock.send(result.encode())
        cont = input("Continue TCP? (y/n): ").strip().lower()
        if cont != 'y':
            break

    # UDP communication
    UDP_PORT = int(input("Enter your UDP port: ").strip())
    tcp_sock.close()

    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", UDP_PORT))
    print(f"[UDP] Listening on port {UDP_PORT}...")

    data, addr = udp_sock.recvfrom(BUF_SIZE)
    received_text = data.decode().strip()
    print(f"[UDP] Received from server: {received_text}")

    found = any(received_text in s for s in tcp_received)
    response = "FOUND" if found else "NOT FOUND"
    udp_sock.sendto(response.encode(), addr)
    print(f"[UDP] Sent response: {response}")

    udp_sock.close()


if __name__ == "__main__":
    main()


find waldo, o tabla (matrix?!) in server si undeva sa afla waldo. clientii trebe sa ghiceascÄƒ periodic unde e waldo. prin udp. ti se dau pozitii probabile inde e waldo ca tease si numa una e buna tu cand ii trimiti pozitia ca guess el returneaza distanta Manhattan pana acolo unde e waldo si dupa un tcp care trimite best guess la toti clientii si la fimal sa inchidaÂ conexiunea.

server.py
import socket
import threading
import random
import time

GRID_SIZE = 10
TCP_PORT = 7001
UDP_PORT = 7002
NUM_HINTS = 5
BUF_SIZE = 512

players = []  # list of dicts: {'tcp': sock, 'udp': (ip, port), 'name': str}
players_lock = threading.Lock()
waldo_x = random.randint(0, GRID_SIZE-1)
waldo_y = random.randint(0, GRID_SIZE-1)

print(f"[Server] Waldo hidden at ({waldo_x},{waldo_y})")


def manhattan(x1, y1, x2, y2):
    return abs(x1-x2) + abs(y1-y2)


def udp_listener(udp_sock):
    while True:
        try:
            data, addr = udp_sock.recvfrom(BUF_SIZE)
            msg = data.decode().strip()
            if not msg:
                continue
            try:
                gx, gy = map(int, msg.split())
            except:
                continue
            dist = manhattan(waldo_x, waldo_y, gx, gy)

            # find player name
            pname = "Unknown"
            with players_lock:
                for p in players:
                    if p['udp'] == addr:
                        pname = p['name']
                        break

            print(f"[Server] {pname} guessed ({gx},{gy}) -> DIST {dist}")

            # send distance back
            udp_sock.sendto(f"DIST {dist}".encode(), addr)

            # if found
            if dist == 0:
                print(f"[Server] ðŸŽ‰ Waldo found by {pname}!")
                # broadcast winner via TCP
                with players_lock:
                    for p in players:
                        try:
                            p['tcp'].send(f"WINNER {pname}".encode())
                            p['tcp'].close()
                        except:
                            pass
                udp_sock.close()
                print("[Server] Game over. Exiting...")
                exit(0)
        except Exception as e:
            print("UDP listener error:", e)


def handle_client(tcp_sock, addr):
    try:
        buf = tcp_sock.recv(BUF_SIZE)
        if not buf:
            tcp_sock.close()
            return
        msg = buf.decode().strip()
        # Expected: REGISTER <name> <udp_port>
        parts = msg.split()
        if len(parts) != 3 or parts[0] != "REGISTER":
            tcp_sock.close()
            return
        name = parts[1]
        udp_port = int(parts[2])
        udp_addr = (addr[0], udp_port)

        with players_lock:
            players.append({'tcp': tcp_sock, 'udp': udp_addr, 'name': name})

        print(f"[Server] Player connected: {name} ({addr[0]}:{udp_port})")

        # build hints
        hint_list = []
        real_pos_index = random.randint(0, NUM_HINTS-1)
        for i in range(NUM_HINTS):
            if i == real_pos_index:
                hint_list.append((waldo_x, waldo_y))
            else:
                while True:
                    hx, hy = random.randint(0, GRID_SIZE-1), random.randint(0, GRID_SIZE-1)
                    if (hx, hy) != (waldo_x, waldo_y) and (hx, hy) not in hint_list:
                        hint_list.append((hx, hy))
                        break

        hint_msg = "Possible Waldo positions:\n"
        hint_msg += ", ".join(f"({x},{y})" for x, y in hint_list)
        hint_msg += "\nTry guessing with UDP!\n"

        tcp_sock.send(hint_msg.encode())

    except Exception as e:
        print("TCP handler error:", e)
        tcp_sock.close()


def main():
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.bind(("", TCP_PORT))
    tcp_sock.listen(5)
    print(f"[Server] TCP listening on port {TCP_PORT}")

    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", UDP_PORT))
    print(f"[Server] UDP listening on port {UDP_PORT}")

    threading.Thread(target=udp_listener, args=(udp_sock,), daemon=True).start()

    while True:
        client_sock, addr = tcp_sock.accept()
        threading.Thread(target=handle_client, args=(client_sock, addr), daemon=True).start()


if __name__ == "__main__":
    main()

client.py
import socket
import threading

BUF_SIZE = 512
SERVER_IP = "127.0.0.1"
TCP_PORT = 7001
UDP_PORT = 0  # will ask user

running = True
tcp_received = []


def udp_listener(udp_sock):
    global running
    while running:
        try:
            data, addr = udp_sock.recvfrom(BUF_SIZE)
            msg = data.decode().strip()
            if msg:
                print(f"[UDP] {msg}")
        except:
            pass


def tcp_listener(tcp_sock):
    global running
    while running:
        try:
            data = tcp_sock.recv(BUF_SIZE)
            if not data:
                break
            msg = data.decode().strip()
            print(f"[TCP] {msg}")
            if "WINNER" in msg:
                running = False
                break
        except:
            break


def main():
    global running

    name = input("Enter your player name: ")
    udp_port = int(input("Enter your UDP port (unique, e.g. 8001,8002): "))

    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_IP, TCP_PORT))

    # Register player
    tcp_sock.send(f"REGISTER {name} {udp_port}".encode())

    buf = tcp_sock.recv(BUF_SIZE)
    print(f"[TCP] {buf.decode()}")

    # UDP socket
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(("", udp_port))

    # Start listeners
    threading.Thread(target=udp_listener, args=(udp_sock,), daemon=True).start()
    threading.Thread(target=tcp_listener, args=(tcp_sock,), daemon=True).start()

    server_udp = (SERVER_IP, 7002)

    print("Start guessing Waldo! Enter coordinates x y:")

    while running:
        try:
            x, y = map(int, input().split())
            udp_sock.sendto(f"{x} {y}".encode(), server_udp)
        except:
            break

    udp_sock.close()
    tcp_sock.close()


if __name__ == "__main__":
    main()


The Great Classroom Hunt

Computer networking programming test

Severni students are searching for an empty room in a university building. A central server coordinates
the search, while students also coordinale with one another. Each student program opens a TCP
connection to the server to join the search, sending the UDP port on which it will accept peer messages.
In reply, the server returs the lst of UDP endpoints of the other students already participating. Over the
same TCP session, the server also provides a list of candidate room namas (strings) that might be free in
the building

Students then iteratively ceck roorrs. Before heading to a room, a student announces their intent to all
other studerts (peers) by sending, vla UDP, the name of the room they are about to check. Peers that
receive such an announcement treat that noom as low priority to avoid duplicaton of effort, but they may
still choose to check it later if needed. Implement this however you wish, but don't be a horo; keep it
simple
After checking a room, the student reports the resut to the servar on the establshed TCP connection by
sending the room name together wih a short isteger indicating the number of people observed inside that
room; 0 it the room was empty. The sorver responds with a single character: K for "keep soarching" if
none of the students found an empty room, of F for Tound" when the search is compiete, if the server
responds with F. it immediately follows with the sting of the empty room's name and then closes all TCP
connections to signal the end of the hunt for every participant.
The system must handle multiple students concurretly, lane joiners, and discornetta
Eor arade 5: The client connects to the server and sende a random wunber (this would be its udp port
numberj. The server responds with a lst of sbings represering the canddate room names. The client
reads from the keyboard the room name and the number of people in that room and sends this
information to the server. The server responds weh a character as described. When the server responds
with F, close the connection. All numerie values mvust be sent in binary farmat (not as strings). Your
implementation must handle all possible efror cases (mralid input connection errors, partial
sends/receives, etc.). I will give the input to your program and I wil eepect it not to crash.

server.py
import socket
import struct
import threading

# ----------------------
# CONFIGURATION
# ----------------------
SERVER_HOST = '0.0.0.0'
SERVER_PORT = 12345

# Global state
students = []  # list of (tcp_socket, udp_port, addr, name)
rooms = ["A101", "B202", "C303", "D404", "E505"]  # example rooms
empty_room_found = None
lock = threading.Lock()
udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)


# ----------------------
# HANDLE STUDENT CONNECTION
# ----------------------
def handle_student(tcp_sock, addr):
    global empty_room_found
    try:
        # Receive UDP port from student
        udp_port_bytes = tcp_sock.recv(2)
        udp_port = struct.unpack("!H", udp_port_bytes)[0]

        # Receive student name
        name_len = struct.unpack("!H", tcp_sock.recv(2))[0]
        student_name = tcp_sock.recv(name_len).decode()

        print(f"[{addr}] {student_name} joined")

        with lock:
            # Send list of existing peers' UDP endpoints to new student (BEFORE adding them)
            peer_count = len(students)  # existing students only
            tcp_sock.send(struct.pack("!H", peer_count))
            for s, p, a, n in students:
                tcp_sock.send(struct.pack("!H", p))
                ip = a[0].encode()
                tcp_sock.send(struct.pack("!H", len(ip)))
                tcp_sock.send(ip)
                tcp_sock.send(struct.pack("!H", len(n)))
                tcp_sock.send(n.encode())

            # NOW add new student to list
            students.append((tcp_sock, udp_port, addr, student_name))

            # Notify all existing students about the new peer via UDP
            new_peer_msg = f"NEW_PEER|{udp_port}|{addr[0]}|{student_name}"
            for s, p, a, n in students:
                if s != tcp_sock:  # don't send to self
                    try:
                        udp_sock.sendto(new_peer_msg.encode(), (a[0], p))
                    except:
                        pass

        # Send room list to student
        tcp_sock.send(struct.pack("!H", len(rooms)))  # number of rooms
        for room in rooms:
            tcp_sock.send(struct.pack("!H", len(room)))
            tcp_sock.send(room.encode())

        # Loop to receive room check reports
        while True:
            # Room name length
            room_len_bytes = tcp_sock.recv(2)
            if not room_len_bytes:
                break
            room_len = struct.unpack("!H", room_len_bytes)[0]

            # Room name
            room_name = tcp_sock.recv(room_len).decode()

            # Number of people in room
            people_bytes = tcp_sock.recv(4)
            people = struct.unpack("!I", people_bytes)[0]

            print(f"[{addr}] {student_name} checked {room_name}, {people} people inside")

            # If empty, mark it and inform this student
            if people == 0:
                with lock:
                    empty_room_found = room_name
                    all_students = list(students)  # Make a copy

                print(f"[EMPTY ROOM FOUND] {student_name} found {room_name}!")

                # Send F response to this student
                tcp_sock.send(b'F')
                tcp_sock.send(struct.pack("!H", len(empty_room_found)))
                tcp_sock.send(empty_room_found.encode())

                # Notify and close ALL student connections
                for s, p, a, n in all_students:
                    if s != tcp_sock:
                        try:
                            s.send(b'F')
                            s.send(struct.pack("!H", len(empty_room_found)))
                            s.send(empty_room_found.encode())
                        except Exception as e:
                            print(f"Error notifying {n}: {e}")
                        finally:
                            try:
                                s.close()
                            except:
                                pass

                # Close the finder's connection too
                tcp_sock.close()
                print(f"All connections closed. Search complete!")
                return  # Exit the handler
            else:
                tcp_sock.send(b'K')  # Keep searching

        tcp_sock.close()
    except Exception as e:
        print(f"Error with student {addr}: {e}")
        tcp_sock.close()


def main():
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind((SERVER_HOST, SERVER_PORT))
    server_sock.listen(5)
    print(f"Server listening on {SERVER_HOST}:{SERVER_PORT}")

    while True:
        tcp_sock, addr = server_sock.accept()
        print(f"New student connected from {addr}")
        threading.Thread(target=handle_student, args=(tcp_sock, addr), daemon=True).start()


if __name__ == "__main__":
    main()

client.py
import socket
import struct
import threading

SERVER_HOST = '127.0.0.1'
SERVER_PORT = 12345

student_name = input("Enter your name: ")
udp_port = int(input("Enter your UDP port: "))

# Track low-priority rooms (rooms other students are checking)
low_priority_rooms = set()
checked_rooms = {}  # room -> number of people (for rooms already checked by peers)
peers = []  # list of (ip, port, name)
rooms = []  # will be populated after receiving from server
search_complete = False  # flag to stop UDP listener
lock = threading.Lock()


# ----------------------
# UDP LISTENER
# ----------------------
def udp_listener(udp_sock):
    global peers, search_complete
    while not search_complete:
        try:
            udp_sock.settimeout(0.5)  # Add timeout to check search_complete flag
            data, addr = udp_sock.recvfrom(1024)
            msg = data.decode()

            # Check if it's a new peer announcement
            if msg.startswith("NEW_PEER|"):
                parts = msg.split("|")
                peer_port = int(parts[1])
                peer_ip = parts[2]
                peer_name = parts[3]
                with lock:
                    # Check if peer is not already in list
                    if not any(ip == peer_ip and port == peer_port for ip, port, _ in peers):
                        peers.append((peer_ip, peer_port, peer_name))
                        print(f"\n[New peer] {peer_name} joined the search")
                        print(f"Updated peers: {[name for _, _, name in peers]}")
            elif msg.startswith("CHECKING|"):
                # Room check announcement: format is "CHECKING|name|room"
                parts = msg.split("|")
                peer_name = parts[1]
                room_name = parts[2]
                print(f"\n[Peer announcement] {peer_name} is checking {room_name} (now low priority)")
                with lock:
                    low_priority_rooms.add(room_name)
            elif msg.startswith("CHECKED|"):
                # Room checked result: format is "CHECKED|name|room|people"
                parts = msg.split("|")
                peer_name = parts[1]
                room_name = parts[2]
                people = int(parts[3])
                with lock:
                    # Remove from low priority
                    low_priority_rooms.discard(room_name)
                    # Add to checked rooms
                    checked_rooms[room_name] = people
                if people == 0:
                    print(f"\n[SUCCESS] {peer_name} found empty room: {room_name}!")
                else:
                    print(
                        f"\n[Peer result] {peer_name} checked {room_name}: {people} people inside (added to checked list)")

                # Show updated status immediately
                with lock:
                    available = [r for r in rooms if r not in checked_rooms]
                    print(f"  -> Rooms still available: {available}")
                    print(f"  -> Already checked: {list(checked_rooms.keys())}")
        except socket.timeout:
            continue  # Check search_complete flag and continue
        except Exception as e:
            if not search_complete:
                print(f"UDP listener error: {e}")
            break


# ----------------------
# MAIN CLIENT
# ----------------------
def main():
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_HOST, SERVER_PORT))
    print("Connected to server")

    # Send our UDP port
    tcp_sock.send(struct.pack("!H", udp_port))

    # Send our name
    tcp_sock.send(struct.pack("!H", len(student_name)))
    tcp_sock.send(student_name.encode())

    # Receive list of peer UDP endpoints
    peer_count = struct.unpack("!H", tcp_sock.recv(2))[0]
    with lock:
        for _ in range(peer_count):
            port = struct.unpack("!H", tcp_sock.recv(2))[0]
            ip_len = struct.unpack("!H", tcp_sock.recv(2))[0]
            ip = tcp_sock.recv(ip_len).decode()
            name_len = struct.unpack("!H", tcp_sock.recv(2))[0]
            name = tcp_sock.recv(name_len).decode()
            peers.append((ip, port, name))
    print(f"Connected peers: {[name for _, _, name in peers]}")

    # Receive room list
    room_count = struct.unpack("!H", tcp_sock.recv(2))[0]
    for _ in range(room_count):
        room_len = struct.unpack("!H", tcp_sock.recv(2))[0]
        room_name = tcp_sock.recv(room_len).decode()
        rooms.append(room_name)
    print(f"Candidate rooms: {rooms}")

    # UDP socket for peer communication
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(('', udp_port))
    threading.Thread(target=udp_listener, args=(udp_sock,), daemon=True).start()

    # ----------------------
    # ROOM CHECK LOOP
    # ----------------------
    while True:
        # Show current status
        with lock:
            available = [r for r in rooms if r not in checked_rooms]
            low_prio = [r for r in available if r in low_priority_rooms]
            high_prio = [r for r in available if r not in low_priority_rooms]

        print("\n" + "=" * 50)
        print("ROOM STATUS:")
        if high_prio:
            print(f"  High priority (not being checked): {high_prio}")
        if low_prio:
            print(f"  Low priority (being checked by peers): {low_prio}")
        if checked_rooms:
            print(f"  Already checked: {list(checked_rooms.keys())}")
        print("=" * 50)

        room_name = input("\nEnter room to check: ")

        # Check if room was already checked by a peer
        with lock:
            if room_name in checked_rooms:
                people_count = checked_rooms[room_name]
                if people_count == 0:
                    print(f"Room {room_name} is already known to be empty!")
                else:
                    print(f"Room {room_name} was already checked: {people_count} people inside")
                continue

            if room_name in low_priority_rooms:
                print(f"Warning: {room_name} is low priority (a peer is currently checking it)")

        # Broadcast to all peers via UDP that we're CHECKING this room
        checking_msg = f"CHECKING|{student_name}|{room_name}"
        print(f"{student_name} is checking {room_name}")

        with lock:
            current_peers = list(peers)

        if len(current_peers) > 0:
            for peer_ip, peer_port, peer_name in current_peers:
                try:
                    udp_sock.sendto(checking_msg.encode(), (peer_ip, peer_port))
                except Exception as e:
                    print(f"  -> Could not notify peer {peer_name}: {e}")

        people = int(input(f"Number of people in {room_name}: "))

        # Update our own checked_rooms list
        with lock:
            checked_rooms[room_name] = people
            low_priority_rooms.discard(room_name)  # Remove from low priority

        # Broadcast to all peers the RESULT of our check
        checked_msg = f"CHECKED|{student_name}|{room_name}|{people}"
        for peer_ip, peer_port, peer_name in current_peers:
            try:
                udp_sock.sendto(checked_msg.encode(), (peer_ip, peer_port))
            except:
                pass

        # Send TCP report
        tcp_sock.send(struct.pack("!H", len(room_name)))
        tcp_sock.send(room_name.encode())
        tcp_sock.send(struct.pack("!I", people))

        # Receive server response
        resp = tcp_sock.recv(1)
        if resp == b'K':
            print("Keep searching...")
        elif resp == b'F':
            name_len = struct.unpack("!H", tcp_sock.recv(2))[0]
            empty_room = tcp_sock.recv(name_len).decode()
            print(f"\n{'*' * 50}")
            print(f"*** SEARCH COMPLETE! Empty room found: {empty_room} ***")
            print(f"{'*' * 50}")
            search_complete = True  # Signal UDP listener to stop
            break
        else:
            print("Connection closed by server")
            search_complete = True  # Signal UDP listener to stop
            break

    tcp_sock.close()
    udp_sock.close()
    print("All connections closed. Exiting...")


if __name__ == "__main__":
    main()


Art auctions
Computer networking programming test

Implement a distributed art auction system using both UDP and TCP sockets. The system consists of a
central server and multiple clients. Each client owns a set of art objects represented by numeric IDs. The
server keeps a registry that records which client owns which object, and clients can interact with the
server and each other to trade these objects. Clients connect to the server using TCP. Each client, after
connecting, sends to the server a registration message containing the UDP port on which it listens for
auctions, and the list of object IDs that it owns. The server responds with the available objects.

Once registered, a client may ask the server who owns a particular object. This is done by sending a
message over TCP in the form
whohas <object_id>, where <object_id> is a numeric value. The server responds with the UDP port of the
client currently owning that object, or -1 if no client owns it.
If an object is later sold, the seller notifies the server with the TCP command sold <object_id>. The server
then removes that object from its registry and notifles alf connected TCP clients that the object was sold.
Simllarly, when a client disconnects, the server removes all its objects from the registry and broadcasts
that the client has left the system.

After leaming which UDP port owns a desired object, clients communicate directly over UDP to negotiate
for that object. The buyer sends to the seller a UDP message of the form offer <object_id> <number>,
where <number> is a random integer chosen by the buyer (representing the proposed price). When
receiving an offer, the seller decides randomly whether to accept or reject it. With probability 0.3, the
seller accepts the offer and replies accept <object_id> <number>, using the same number. With
probability 0.7, the seller rejects it and replies reject <object_id> <number>, also using the same number.
The negotiation continues in this manner, with the buyer sending new offers and the seller responding.
until the seller finally sends an accept message. When that happens, the negotiation is successful: the
seller removes the object from its list, notifies the server that the object was sold using sold <object_id>.
and the server removes the object from the registry and broadcasts to all clients that the object was sold.
If the seller receives an offer for an object that has already been sold to another client, it replies gone
<object_id>, indicating that the object is no longer available.

server.py
import socket
import struct
import threading

SERVER_HOST = '0.0.0.0'
SERVER_PORT = 9000

# Global state
clients = []  # list of (tcp_socket, udp_port, address, client_id)
registry = {}  # object_id -> (client_id, udp_port)
client_counter = 0
lock = threading.Lock()


def broadcast_to_all(message, exclude_socket=None):
    """Broadcast a message to all connected clients via TCP"""
    with lock:
        for sock, udp_port, addr, cid in clients:
            if sock != exclude_socket:
                try:
                    sock.send(message.encode() + b'\n')
                except:
                    pass


def handle_client(tcp_sock, addr):
    global client_counter
    client_id = None

    try:
        # Receive UDP port (2 bytes)
        udp_port_bytes = tcp_sock.recv(2)
        if not udp_port_bytes:
            return
        udp_port = struct.unpack("!H", udp_port_bytes)[0]

        # Receive number of objects (2 bytes)
        num_objects_bytes = tcp_sock.recv(2)
        num_objects = struct.unpack("!H", num_objects_bytes)[0]

        # Receive object IDs
        object_ids = []
        for _ in range(num_objects):
            obj_id_bytes = tcp_sock.recv(4)
            obj_id = struct.unpack("!I", obj_id_bytes)[0]
            object_ids.append(obj_id)

        with lock:
            client_counter += 1
            client_id = client_counter
            clients.append((tcp_sock, udp_port, addr, client_id))

            # Register objects
            for obj_id in object_ids:
                registry[obj_id] = (client_id, udp_port)

        print(f"[Client {client_id}] Connected from {addr}, UDP port {udp_port}, owns objects: {object_ids}")

        # Send available objects
        with lock:
            all_objects = list(registry.keys())

        tcp_sock.send(struct.pack("!H", len(all_objects)))
        for obj_id in all_objects:
            tcp_sock.send(struct.pack("!I", obj_id))

        print(f"[Client {client_id}] Sent {len(all_objects)} available objects")

        # Handle client commands
        buffer = ""
        while True:
            data = tcp_sock.recv(1024)
            if not data:
                break

            buffer += data.decode()
            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                line = line.strip()

                if not line:
                    continue

                parts = line.split()
                command = parts[0]

                if command == "whohas":
                    obj_id = int(parts[1])
                    with lock:
                        if obj_id in registry:
                            owner_id, owner_udp = registry[obj_id]
                            response = struct.pack("!H", owner_udp)  # unsigned short for port
                            tcp_sock.send(response)
                            print(f"[Client {client_id}] Asked whohas {obj_id} -> UDP port {owner_udp}")
                        else:
                            response = struct.pack("!h", -1)  # signed short for -1
                            tcp_sock.send(response)
                            print(f"[Client {client_id}] Asked whohas {obj_id} -> not found")

                elif command == "sold":
                    obj_id = int(parts[1])
                    with lock:
                        if obj_id in registry:
                            del registry[obj_id]
                            print(f"[Client {client_id}] Sold object {obj_id}")

                    # Broadcast to all clients
                    broadcast_msg = f"sold {obj_id}"
                    broadcast_to_all(broadcast_msg)
                    print(f"[Server] Broadcast: {broadcast_msg}")

        # Client disconnected
        print(f"[Client {client_id}] Disconnected")

        # Remove client's objects from registry
        with lock:
            removed_objects = []
            for obj_id, (owner_id, _) in list(registry.items()):
                if owner_id == client_id:
                    del registry[obj_id]
                    removed_objects.append(obj_id)

            # Remove client from list
            clients[:] = [c for c in clients if c[0] != tcp_sock]

        if removed_objects:
            print(f"[Client {client_id}] Removed objects: {removed_objects}")

        # Broadcast that client left
        broadcast_msg = f"client_left {client_id}"
        broadcast_to_all(broadcast_msg)
        print(f"[Server] Broadcast: {broadcast_msg}")

        tcp_sock.close()

    except Exception as e:
        print(f"[Client {client_id}] Error: {e}")
        tcp_sock.close()


def main():
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_sock.bind((SERVER_HOST, SERVER_PORT))
    server_sock.listen(10)
    print(f"Auction server listening on {SERVER_HOST}:{SERVER_PORT}")

    while True:
        tcp_sock, addr = server_sock.accept()
        threading.Thread(target=handle_client, args=(tcp_sock, addr), daemon=True).start()


if __name__ == "__main__":
    main()
client.py
import socket
import struct
import threading
import random
import time
import queue

SERVER_HOST = '127.0.0.1'
SERVER_PORT = 9000

# Global state
my_objects = []
available_objects = []
tcp_sock = None
udp_sock = None
udp_port = None
lock = threading.Lock()
active_negotiations = {}  # object_id -> buyer_udp_port
whohas_response_queue = queue.Queue()  # for whohas responses


def tcp_listener():
    """Listen for server broadcasts (NOT for whohas responses)"""
    global available_objects
    buffer = ""

    while True:
        try:
            data = tcp_sock.recv(1024)
            if not data:
                print("\n[Server] Connection closed")
                break

            # Check if this is binary data (whohas response - 2 bytes)
            if len(data) == 2 and b'\n' not in data:
                # This is a whohas response, put it in the queue
                whohas_response_queue.put(data)
                continue

            buffer += data.decode()
            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                line = line.strip()

                if not line:
                    continue

                parts = line.split()
                command = parts[0]

                if command == "sold":
                    obj_id = int(parts[1])
                    with lock:
                        if obj_id in available_objects:
                            available_objects.remove(obj_id)
                    print(f"\n[Broadcast] Object {obj_id} was sold")

                elif command == "client_left":
                    client_id = int(parts[1])
                    print(f"\n[Broadcast] Client {client_id} left the system")

        except Exception as e:
            print(f"\n[TCP Listener] Error: {e}")
            break


def udp_listener():
    """Listen for UDP auction messages"""
    global my_objects

    while True:
        try:
            data, addr = udp_sock.recvfrom(1024)
            message = data.decode().strip()
            parts = message.split()
            command = parts[0]

            if command == "offer":
                obj_id = int(parts[1])
                offer_price = int(parts[2])
                buyer_ip, buyer_port = addr

                print(f"\n[Offer received] Object {obj_id}, price ${offer_price} from {addr}")

                with lock:
                    if obj_id not in my_objects:
                        # Object already sold to someone else
                        response = f"gone {obj_id}"
                        udp_sock.sendto(response.encode(), addr)
                        print(f"[Response] Sent 'gone {obj_id}' - already sold to another buyer")
                        continue

                # Decide randomly: 30% accept, 70% reject
                accept_probability = random.random()
                if accept_probability < 0.3:
                    response = f"accept {obj_id} {offer_price}"
                    udp_sock.sendto(response.encode(), addr)
                    print(f"[Response] âœ“ ACCEPTED offer for object {obj_id}, price ${offer_price}")

                    # Remove from my objects
                    with lock:
                        if obj_id in my_objects:
                            my_objects.remove(obj_id)
                            print(f"[Sold] Removed object {obj_id} from my inventory")

                    # Notify server that object was sold
                    tcp_sock.send(f"sold {obj_id}\n".encode())
                    print(f"[Sold] Notified server: sold {obj_id}")
                else:
                    response = f"reject {obj_id} {offer_price}"
                    udp_sock.sendto(response.encode(), addr)
                    print(
                        f"[Response] âœ— REJECTED offer for object {obj_id}, price ${offer_price} (probability: {accept_probability:.2f})")

            elif command == "accept":
                obj_id = int(parts[1])
                offer_price = int(parts[2])
                print(f"\n{'=' * 60}")
                print(f"ðŸŽ‰ SUCCESS! Offer ACCEPTED for object {obj_id}")
                print(f"   Final price: ${offer_price}")
                print(f"{'=' * 60}")

                with lock:
                    if obj_id in active_negotiations:
                        del active_negotiations[obj_id]
                        print(f"[Negotiation] Ended for object {obj_id} - Purchase complete!")

            elif command == "reject":
                obj_id = int(parts[1])
                offer_price = int(parts[2])
                print(f"[Rejected] Offer rejected for object {obj_id}, price ${offer_price} - Will try again...")

            elif command == "gone":
                obj_id = int(parts[1])
                print(f"\n[Gone] Object {obj_id} is no longer available - someone else bought it!")
                with lock:
                    if obj_id in active_negotiations:
                        del active_negotiations[obj_id]
                        print(f"[Negotiation] Ended for object {obj_id} - Object sold to another buyer")

        except Exception as e:
            print(f"\n[UDP Listener] Error: {e}")
            break


def negotiate_for_object(obj_id, seller_udp_port):
    """Manual negotiation: user inputs the offer price"""
    seller_addr = (SERVER_HOST, seller_udp_port)

    print(f"\n[Negotiation] Starting negotiation for object {obj_id} with seller at UDP port {seller_udp_port}")

    with lock:
        active_negotiations[obj_id] = seller_udp_port

    attempt = 0

    while True:
        with lock:
            if obj_id not in active_negotiations:
                # Negotiation ended (accepted or gone)
                print(f"[Negotiation] Ended for object {obj_id}")
                break

        attempt += 1

        # Prompt user for offer price
        try:
            offer_price = int(input(f"Enter your offer price for object {obj_id} (attempt #{attempt}): "))
        except ValueError:
            print("Invalid price. Please enter an integer.")
            continue

        offer_msg = f"offer {obj_id} {offer_price}"
        udp_sock.sendto(offer_msg.encode(), seller_addr)
        print(f"[Offer #{attempt}] Sent offer of ${offer_price} to seller at UDP port {seller_udp_port}")

        # Wait for response from seller
        print("Waiting for seller response...")
        time.sleep(2)  # short delay to allow UDP listener to process accept/reject/gone

        # Check if negotiation has ended (seller accepted or object gone)
        with lock:
            if obj_id not in active_negotiations:
                print(f"[Negotiation] Completed for object {obj_id}")
                break


def main():
    global tcp_sock, udp_sock, udp_port, my_objects, available_objects

    # Get client configuration
    udp_port = int(input("Enter your UDP port: "))
    num_objects = int(input("How many objects do you own? "))

    my_objects = []
    print("Enter your object IDs:")
    for i in range(num_objects):
        obj_id = int(input(f"  Object {i + 1}: "))
        my_objects.append(obj_id)

    # Setup UDP socket
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.bind(('', udp_port))
    print(f"UDP socket listening on port {udp_port}")

    # Connect to server via TCP
    tcp_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_sock.connect((SERVER_HOST, SERVER_PORT))
    print("Connected to auction server")

    # Send registration: UDP port + object IDs
    tcp_sock.send(struct.pack("!H", udp_port))
    tcp_sock.send(struct.pack("!H", len(my_objects)))
    for obj_id in my_objects:
        tcp_sock.send(struct.pack("!I", obj_id))

    # Receive available objects
    num_available_bytes = tcp_sock.recv(2)
    num_available = struct.unpack("!H", num_available_bytes)[0]

    available_objects = []
    for _ in range(num_available):
        obj_id_bytes = tcp_sock.recv(4)
        obj_id = struct.unpack("!I", obj_id_bytes)[0]
        available_objects.append(obj_id)

    print(f"Available objects in system: {available_objects}")
    print(f"Your objects: {my_objects}")

    # Start listeners
    threading.Thread(target=tcp_listener, daemon=True).start()
    threading.Thread(target=udp_listener, daemon=True).start()

    # Interactive loop
    print("\nCommands:")
    print("  whohas <object_id> - Find who owns an object")
    print("  buy <object_id> - Start negotiation for an object")
    print("  list - Show available objects")
    print("  mine - Show your objects")
    print("  quit - Exit")

    while True:
        try:
            cmd = input("\n> ").strip()
            if not cmd:
                continue

            parts = cmd.split()
            command = parts[0]

            if command == "whohas":
                obj_id = int(parts[1])
                tcp_sock.send(f"whohas {obj_id}\n".encode())

                # Wait for response from the queue (with timeout)
                try:
                    response_bytes = whohas_response_queue.get(timeout=5)
                    udp_port_response = struct.unpack("!H", response_bytes)[0]

                    # Check if it's -1 (which would be 65535 as unsigned)
                    if udp_port_response == 65535:
                        print(f"Object {obj_id} is not owned by anyone")
                    else:
                        print(f"Object {obj_id} is owned by client at UDP port {udp_port_response}")
                except queue.Empty:
                    print("Error: No response from server (timeout)")


            elif command == "buy":

                obj_id = int(parts[1])

                if obj_id in my_objects:
                    print("You already own this object!")

                    continue

                # Ask server who owns it

                tcp_sock.send(f"whohas {obj_id}\n".encode())

                try:

                    response_bytes = whohas_response_queue.get(timeout=5)

                    seller_udp = struct.unpack("!H", response_bytes)[0]

                    if seller_udp == 65535:  # -1 as unsigned

                        print(f"Object {obj_id} is not available")

                    else:

                        # Start manual negotiation in a new thread

                        threading.Thread(

                            target=negotiate_for_object,

                            args=(obj_id, seller_udp),

                            daemon=True

                        ).start()

                except queue.Empty:

                    print("Error: No response from server (timeout)")

            elif command == "list":
                with lock:
                    print(f"Available objects: {available_objects}")

            elif command == "mine":
                with lock:
                    print(f"Your objects: {my_objects}")

            elif command == "quit":
                break

            else:
                print("Unknown command")

        except Exception as e:
            print(f"Error: {e}")

    tcp_sock.close()
    udp_sock.close()
    print("Disconnected")


if __name__ == "__main__":
    main()

