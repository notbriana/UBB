LAB11.   A client sends to the server an array of numbers. Server returns the sum of the numbers.--no threadsserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Bind failed\n");        closesocket(s);        WSACleanup();        return 1;    }    if (listen(s, 5) < 0) {        printf("Listen failed\n");        closesocket(s);        WSACleanup();        return 1;    }    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) {            printf("Accept failed: %d\n", WSAGetLastError());            continue;        }        printf("Connected client: %s:%d\n",            inet_ntoa(client.sin_addr),            ntohs(client.sin_port));        // --- receive array size ---        uint16_t n;        if (recv(c, (char*)&n, sizeof(n), 0) != sizeof(n)) {            printf("Error receiving array size\n");            closesocket(c);            continue;        }        n = ntohs(n);        uint16_t* numbers = (uint16_t*)malloc(n * sizeof(uint16_t));        if (!numbers) {            printf("Memory allocation error\n");            closesocket(c);            continue;        }        // --- receive array elements ---        int error = 0;        for (uint16_t i = 0; i < n; i++) {            uint16_t num;            if (recv(c, (char*)&num, sizeof(num), 0) != sizeof(num)) {                printf("Error receiving number %d\n", i);                error = 1;                break;            }            numbers[i] = ntohs(num);        }        if (error) {            free(numbers);            closesocket(c);            continue;        }        // --- calculate sum ---        uint16_t suma = 0;        for (uint16_t i = 0; i < n; i++)            suma += numbers[i];        uint16_t net_sum = htons(suma);        send(c, (char*)&net_sum, sizeof(net_sum), 0);        free(numbers);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1"); // server IP    if (connect(c, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Error connecting to server: %d\n", WSAGetLastError());        closesocket(c);        WSACleanup();        return 1;    }    // --- input numbers ---    uint16_t n;    printf("How many numbers? ");    scanf("%hu", &n);    uint16_t* numbers = (uint16_t*)malloc(n * sizeof(uint16_t));    if (!numbers) {        printf("Memory allocation error\n");        closesocket(c);        WSACleanup();        return 1;    }    for (uint16_t i = 0; i < n; i++) {        printf("Number %d: ", i + 1);        scanf("%hu", &numbers[i]);    }    // --- send array size ---    uint16_t net_n = htons(n);    send(c, (char*)&net_n, sizeof(net_n), 0);    // --- send numbers ---    for (uint16_t i = 0; i < n; i++) {        uint16_t net_num = htons(numbers[i]);        send(c, (char*)&net_num, sizeof(net_num), 0);    }    // --- receive sum ---    uint16_t net_sum, sum;    recv(c, (char*)&net_sum, sizeof(net_sum), 0);    sum = ntohs(net_sum);    printf("Sum = %hu\n", sum);    free(numbers);    closesocket(c);    WSACleanup();    return 0;}--threadserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 4321void* handle_client(int c) {	// Receive number of elements	uint32_t n_net;	int bytes = recv(c, (char*)&n_net, sizeof(n_net), 0);	if (bytes <= 0) {		closesocket(c);		return 0;	}	uint32_t n = ntohl(n_net); // convert to host order	if (n == 0) n = 1; // safety	printf("Client wants to send %u numbers\n", n);	// Allocate array dynamically	uint32_t* numbers = (uint32_t*)malloc(n * sizeof(uint32_t));	if (!numbers) {		printf("Memory allocation failed!\n");		closesocket(c);		return 0;	}	// Receive numbers	for (uint32_t i = 0; i < n; i++) {		uint32_t num_net;		recv(c, (char*)&num_net, sizeof(num_net), 0);		numbers[i] = ntohl(num_net);	}	// Compute sum	uint32_t sum = 0;	for (uint32_t i = 0; i < n; i++)		sum += numbers[i];	// Send sum back	uint32_t sum_net = htonl(sum);	send(c, (char*)&sum_net, sizeof(sum_net), 0);	printf("Processed client: sum = %u\n", sum);	free(numbers);         // free allocated memory	closesocket(c);	return 0;}int main() {	WSADATA wsa;	SOCKET server, client;	struct sockaddr_in server_addr, client_addr;	int client_len = sizeof(client_addr);	WSAStartup(MAKEWORD(2, 2), &wsa);	server = socket(AF_INET, SOCK_STREAM, 0);	server_addr.sin_family = AF_INET;	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(PORT);	bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));	listen(server, 5);	printf("Server listening on port %d...\n", PORT);	while (1) {		client = accept(server, (struct sockaddr*)&client_addr, &client_len);		if (client != INVALID_SOCKET) {			printf("Client connected!\n");			std::thread t(handle_client, client);			t.detach();		}	}	closesocket(server);	WSACleanup();	return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    SOCKET sock;    struct sockaddr_in server;    WSAStartup(MAKEWORD(2, 2), &wsa);    sock = socket(AF_INET, SOCK_STREAM, 0);    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Connection failed!\n");        return 1;    }    uint32_t n;    printf("Enter number of elements: ");    scanf("%u", &n);    if (n == 0) n = 1;    uint32_t* numbers = (uint32_t*)malloc(n * sizeof(uint32_t));    if (!numbers) {        printf("Memory allocation failed!\n");        closesocket(sock);        return 1;    }    for (uint32_t i = 0; i < n; i++) {        printf("numbers[%u] = ", i);        scanf("%u", &numbers[i]);    }    // Send number of elements    uint32_t n_net = htonl(n);    send(sock, (char*)&n_net, sizeof(n_net), 0);    // Send array elements    for (uint32_t i = 0; i < n; i++) {        uint32_t num_net = htonl(numbers[i]);        send(sock, (char*)&num_net, sizeof(num_net), 0);    }    // Receive sum    uint32_t sum_net;    recv(sock, (char*)&sum_net, sizeof(sum_net), 0);    uint32_t sum = ntohl(sum_net);    printf("Server returned sum = %u\n", sum);    free(numbers);        // free allocated memory    closesocket(sock);    WSACleanup();    return 0;}2.   A client sends to the server a string. The server returns the count of spaces in the string.--no threadsserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Bind failed\n");        closesocket(s);        WSACleanup();        return 1;    }    if (listen(s, 5) < 0) {        printf("Listen failed\n");        closesocket(s);        WSACleanup();        return 1;    }    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) {            printf("Accept failed: %d\n", WSAGetLastError());            continue;        }        printf("Connected client: %s:%d\n",            inet_ntoa(client.sin_addr),            ntohs(client.sin_port));        uint16_t len;        if(recv(c, (char*)&len, sizeof(len),0) != sizeof(len)) {            printf("Failed to receive length\n");            closesocket(c);            continue; 		}        len = ntohs(len);        char* buffer = (char*)malloc(len + 1);        if (!buffer) {            printf("Memmory allocation failed"); 			closesocket(c);            continue;        }        if (recv(c, buffer, len, 0) != len) {            printf("Error receiving data");            free(buffer); 			closesocket(c); 			continue;        }        buffer[len] = '\0';        uint16_t space_count = 0;        for (int i = 0; i < len; i++) {            if (buffer[i] == ' ') 				space_count++;        }        uint16_t net_space_count = htons(space_count); 		send(c, (char*)&net_space_count, sizeof(net_space_count), 0);        free(buffer); 		closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#include <string.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Error connecting to server: %d\n", WSAGetLastError());        closesocket(c);        WSACleanup();        return 1;    }    char buffer[1024];    printf("Enter a string: ");    fgets(buffer, sizeof(buffer), stdin);    size_t len = strlen(buffer);    if (len > 0 && buffer[len - 1] == '\n') {        buffer[len - 1] = '\0';        len--;    }    uint16_t net_len = htons(len);    send(c, (char*)&net_len, sizeof(net_len), 0);    send(c, buffer, len, 0);    uint16_t spaces, net_spaces; 	recv(c, (char*)&net_spaces, sizeof(net_spaces), 0); 	spaces = ntohs(net_spaces); 	printf("Number of spaces: %d\n", spaces); 	closesocket(c);    WSACleanup();    return 0;}--threadsserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <string.h>#include <thread>#pragma comment(lib, "ws2_32.lib") // Link Winsock library#define PORT 4321#define BUFFER 1024void* handle_client(int client) {	char buffer[BUFFER];	int bytes;	// Receive string from client	bytes = recv(client, buffer, BUFFER - 1, 0);	if (bytes <= 0) {		closesocket(client);		return 0;	}	buffer[bytes] = '\0';	// Count spaces	int spaces = 0;	for (int i = 0; i < bytes; i++) {		if (buffer[i] == ' ')			spaces++;	}	// Send result back	send(client, (char*)&spaces, sizeof(spaces), 0);	printf("Processed client: %d spaces\n", spaces);	closesocket(client);	return 0;}int main() {	WSADATA wsa;	SOCKET server, client;	struct sockaddr_in server_addr, client_addr;	int client_len = sizeof(client_addr);	// Initialize Winsock	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {		printf("Failed. Error Code: %d\n", WSAGetLastError());		return 1;	}	// Create server socket	server = socket(AF_INET, SOCK_STREAM, 0);	if (server == INVALID_SOCKET) {		printf("Could not create socket: %d\n", WSAGetLastError());		return 1;	}	server_addr.sin_family = AF_INET;	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(PORT);	if (bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {		printf("Bind failed: %d\n", WSAGetLastError());		return 1;	}	listen(server, 5);	printf("Server listening on port %d...\n", PORT);	while (1) {		client = accept(server, (struct sockaddr*)&client_addr, &client_len);		if (client != INVALID_SOCKET) {			printf("Client connected!\n");			std::thread t(handle_client, client);			t.detach();		}	}	closesocket(server);	WSACleanup();	return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <string.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321#define BUFFER 1024int main() {    WSADATA wsa;    SOCKET sock;    struct sockaddr_in server;    char message[BUFFER];    int spaces;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("Failed. Error Code: %d\n", WSAGetLastError());        return 1;    }    sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        printf("Could not create socket: %d\n", WSAGetLastError());        return 1;    }    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = inet_addr("192.168.1.136");    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Connection failed: %d\n", WSAGetLastError());        return 1;    }    printf("Connected to server. Enter a string: ");    fgets(message, BUFFER, stdin);    message[strcspn(message, "\n")] = 0; // remove newline    send(sock, message, strlen(message), 0);    recv(sock, (char*)&spaces, sizeof(spaces), 0);    printf("Server counted %d spaces.\n", spaces);    closesocket(sock);    WSACleanup();    return 0;}3.   A client sends to the server a string. The server returns the reversed string to the client (characters from the end to begging)--no threadserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Bind failed\n");        closesocket(s);        WSACleanup();        return 1;    }    if (listen(s, 5) < 0) {        printf("Listen failed\n");        closesocket(s);        WSACleanup();        return 1;    }    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) {            printf("Accept failed: %d\n", WSAGetLastError());            continue;        }        printf("Connected client: %s:%d\n",            inet_ntoa(client.sin_addr),            ntohs(client.sin_port));        uint16_t len;        if(recv(c, (char*)&len, sizeof(len),0) != sizeof(len)) {            printf("Failed to receive length\n");            closesocket(c);            continue; 		}        len = ntohs(len);        char* buffer = (char*)malloc(len + 1);        if (!buffer) {            printf("Memmory allocation failed"); 			closesocket(c);            continue;        }        if (recv(c, buffer, len, 0) != len) {            printf("Error receiving data");            free(buffer); 			closesocket(c); 			continue;        }        buffer[len] = '\0';        char* reversed = (char*)malloc(len + 1);        if (!reversed) {            printf("Memmory allocation failed"); 			free(reversed);            closesocket(c);            continue; 		}        for (int i = 0; i < len; i++) {            reversed[i] = buffer[len - 1 - i]; 		} 		send(c, reversed, len, 0);        free(buffer); 		free(reversed); 		closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#include <string.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1"); // server IP    if (connect(c, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Error connecting to server: %d\n", WSAGetLastError());        closesocket(c);        WSACleanup();        return 1;    }    char buffer[1024];    printf("Enter a string: ");    fgets(buffer, sizeof(buffer), stdin);    size_t len = strlen(buffer);    if (len > 0 && buffer[len - 1] == '\n') {        buffer[len - 1] = '\0';        len--;    }    uint16_t net_len = htons(len);    send(c, (char*)&net_len, sizeof(net_len), 0);    send(c, buffer, len, 0); 	char reversed[1024]; 	recv(c, reversed, len, 0); 	reversed[len] = '\0'; 	printf("Reversed array: %s\n", reversed); 	closesocket(c);    WSACleanup();    return 0;}--threadserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 4321void* handle_client(int client) {	// Receive string length (16-bit)	uint16_t len_net;	if (recv(client, (char*)&len_net, sizeof(len_net), 0) != sizeof(len_net)) {		closesocket(client);		return 0;	}	uint16_t len = ntohs(len_net);	if (len == 0) len = 1;	// Allocate buffer	char* buffer = (char*)malloc(len + 1);	if (!buffer) { closesocket(client); return 0; }	if (recv(client, buffer, len, 0) != len) {		free(buffer);		closesocket(client);		return 0;	}	buffer[len] = '\0';	// Reverse string	char* reversed = (char*)malloc(len + 1);	if (!reversed) { free(buffer); closesocket(client); return 0; }	for (int i = 0; i < len; i++) {		reversed[i] = buffer[len - 1 - i];	}	send(client, reversed, len, 0);	free(buffer);	free(reversed);	closesocket(client);	printf("Client handled, string reversed.\n");	return 0;}int main() {	WSADATA wsa;	SOCKET server, client;	struct sockaddr_in server_addr, client_addr;	int client_len = sizeof(client_addr);	WSAStartup(MAKEWORD(2, 2), &wsa);	server = socket(AF_INET, SOCK_STREAM, 0);	server_addr.sin_family = AF_INET;	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(PORT);	bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));	listen(server, 5);	printf("Server listening on port %d...\n", PORT);	while (1) {		SOCKET client = accept(server, (struct sockaddr*)&client_addr, &client_len);		if (client != INVALID_SOCKET) {			printf("Client connected!\n");			std::thread t(handle_client, client);			t.detach();		}	}	closesocket(server);	WSACleanup();	return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    SOCKET sock;    struct sockaddr_in server;    WSAStartup(MAKEWORD(2, 2), &wsa);    sock = socket(AF_INET, SOCK_STREAM, 0);    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Connection failed!\n");        return 1;    }    char buffer[1024];    printf("Enter a string: ");    fgets(buffer, sizeof(buffer), stdin);    size_t len = strlen(buffer);    if (len > 0 && buffer[len - 1] == '\n') {        buffer[len - 1] = '\0';        len--;    }    uint16_t net_len = htons(len);    send(sock, (char*)&net_len, sizeof(net_len), 0);    send(sock, buffer, len, 0);    char reversed[1024];    recv(sock, reversed, len, 0);    reversed[len] = '\0';    printf("Reversed array: %s\n", reversed);    closesocket(sock);    WSACleanup();    return 0;}4.   The client sends to the server two sorted array of chars. The server will merge sort the two arrays and return the result to the client.--no threadserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Bind failed\n");        closesocket(s);        WSACleanup();        return 1;    }    if (listen(s, 5) < 0) {        printf("Listen failed\n");        closesocket(s);        WSACleanup();        return 1;    }    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) {            printf("Accept failed: %d\n", WSAGetLastError());            continue;        }        printf("Connected client: %s:%d\n",            inet_ntoa(client.sin_addr),            ntohs(client.sin_port));        uint16_t len1, len2;        if(recv(c, (char*)&len1, sizeof(len1),0) != sizeof(len1)) {            printf("Failed to receive length\n");            closesocket(c);            continue; 		}        len1 = ntohs(len1);        char* buffer1 = (char*)malloc(len1 + 1);        if (!buffer1) {            printf("Memmory allocation failed"); 			closesocket(c);            continue;        }        if (recv(c, buffer1, len1, 0) != len1) {            printf("Error receiving data");            free(buffer1); 			closesocket(c); 			continue;        }        buffer1[len1] = '\0';        if (recv(c, (char*)&len2, sizeof(len2), 0) != sizeof(len2)) {            printf("Failed to receive length\n");            closesocket(c);            continue;        }        len2 = ntohs(len2);        char* buffer2 = (char*)malloc(len2 + 1);        if (!buffer2) {            printf("Memmory allocation failed");            closesocket(c);            continue;        }        if (recv(c, buffer2, len2, 0) != len2) {            printf("Error receiving data");            free(buffer2);            closesocket(c);            continue;        }        buffer1[len2] = '\0';        char* longBuffer = (char*)malloc(len1 + len2 + 1);        int i = 0, j = 0, k = 0;        while (i < len1 && j < len2)        {            if (buffer1[i] < buffer2[j])            { 				longBuffer[k++] = buffer1[i++];            }            else            {                longBuffer[k++] = buffer2[j++];            }        }        while (i < len1) 			longBuffer[k++] = buffer1[i++]; 		while (j < len2) 			longBuffer[k++] = buffer2[j++]; 		longBuffer[k] = '\0'; 		send(c, longBuffer, k, 0);        free(buffer1);        free(buffer2); 		free(longBuffer); 		closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#include <string.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("Error initializing Windows Sockets: %d\n", WSAGetLastError());        return -1;    }    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) {        printf("Error creating socket: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1"); // server IP    if (connect(c, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Error connecting to server: %d\n", WSAGetLastError());        closesocket(c);        WSACleanup();        return 1;    }    char buffer1[1024], buffer2[1024];    printf("Enter an ordered string: ");    fgets(buffer1, sizeof(buffer1), stdin);    size_t len1 = strlen(buffer1);    if (len1 > 0 && buffer1[len1 - 1] == '\n') {        buffer1[len1 - 1] = '\0';        len1--;    }    uint16_t net_len1 = htons(len1);    send(c, (char*)&net_len1, sizeof(net_len1), 0);    send(c, buffer1, len1, 0);    printf("Send an ordered string: ");    fgets(buffer2, sizeof(buffer2), stdin);    size_t len2 = strlen(buffer2);    if (len2 > 0 && buffer2[len2 - 1] == '\n') {        buffer2[len2 - 1] = '\0';        len2--; 	}    uint16_t net_len2 = htons(len2); 	send(c, (char*)&net_len2, sizeof(net_len2), 0);    send(c, buffer2, len2, 0); 	char longBuffer[2048]; 	recv(c, longBuffer, len1+len2+1, 0); 	longBuffer[len1+len2+1] = '\0'; 	printf("Ordered array: %s\n", longBuffer); 	closesocket(c);    WSACleanup();    return 0;}--threadserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 4321void* handle_client(int client) {        uint16_t len1, len2;    if (recv(c, (char*)&len1, sizeof(len1), 0) != sizeof(len1)) {        printf("Failed to receive length\n");        closesocket(c);        return 0;    }    len1 = ntohs(len1);    char* buffer1 = (char*)malloc(len1 + 1);    if (!buffer1) {        printf("Memmory allocation failed");        closesocket(c);        return 0;    }    if (recv(c, buffer1, len1, 0) != len1) {        printf("Error receiving data");        free(buffer1);        closesocket(c);        return 0;    }    buffer1[len1] = '\0';    if (recv(c, (char*)&len2, sizeof(len2), 0) != sizeof(len2)) {        printf("Failed to receive length\n");        closesocket(c);        return 0;    }    len2 = ntohs(len2);    char* buffer2 = (char*)malloc(len2 + 1);    if (!buffer2) {        printf("Memmory allocation failed");        closesocket(c);        return 0;    }    if (recv(c, buffer2, len2, 0) != len2) {        printf("Error receiving data");        free(buffer2);        closesocket(c);        return 0;    }    buffer2[len2] = '\0';    char* longBuffer = (char*)malloc(len1 + len2 + 1);    int i = 0, j = 0, k = 0;    while (i < len1 && j < len2)    {        if (buffer1[i] < buffer2[j])        {            longBuffer[k++] = buffer1[i++];        }        else        {            longBuffer[k++] = buffer2[j++];        }    }    while (i < len1)        longBuffer[k++] = buffer1[i++];    while (j < len2)        longBuffer[k++] = buffer2[j++];    longBuffer[k] = '\0';    send(c, longBuffer, k, 0);    free(buffer1);    free(buffer2);    free(longBuffer);    closesocket(c);    printf("Client handled, string reversed.\n");    return 0;}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        SOCKET client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");	    std::thread t(handle_client, client);	    t.detach();           }    }    closesocket(server);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    SOCKET c;    struct sockaddr_in server;    WSAStartup(MAKEWORD(2, 2), &wsa);    c = socket(AF_INET, SOCK_STREAM, 0);    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Connection failed!\n");        return 1;    }    char buffer1[1024], buffer2[1024];    printf("Enter an ordered string: ");    fgets(buffer1, sizeof(buffer1), stdin);    size_t len1 = strlen(buffer1);    if (len1 > 0 && buffer1[len1 - 1] == '\n') {        buffer1[len1 - 1] = '\0';        len1--;    }    uint16_t net_len1 = htons(len1);    send(c, (char*)&net_len1, sizeof(net_len1), 0);    send(c, buffer1, len1, 0);    printf("Send an ordered string: ");    fgets(buffer2, sizeof(buffer2), stdin);    size_t len2 = strlen(buffer2);    if (len2 > 0 && buffer2[len2 - 1] == '\n') {        buffer2[len2 - 1] = '\0';        len2--;    }    uint16_t net_len2 = htons(len2);    send(c, (char*)&net_len2, sizeof(net_len2), 0);    send(c, buffer2, len2, 0);    char longBuffer[2048];    recv(c, longBuffer, len1 + len2 + 1, 0);    longBuffer[len1 + len2 + 1] = '\0';    printf("Ordered array: %s\n", longBuffer);    closesocket(c);    WSACleanup();    return 0;}5.   The client sends to the server an integer. The server returns the list of divisors for the specified number.--no threadserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) { printf("Socket error\n"); return 1; }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) { printf("Accept failed\n"); continue; }        uint16_t a;        if (recv(c, (char*)&a, sizeof(a), 0) != sizeof(a)) {            closesocket(c);            continue;        }        a = ntohs(a);        uint16_t divisors[256] = { 0 };        int count = 0;        for (uint16_t i = 1; i <= a && count < 256; i++) {            if (a % i == 0) {                divisors[count++] = htons(i);            }        }        divisors[count] = 0;        send(c, (char*)divisors, (count + 1) * sizeof(uint16_t), 0);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) { printf("Socket error\n"); return 1; }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connect failed\n");        closesocket(c);        return 1;    }    uint16_t a;    printf("Enter a number: ");    scanf("%hu", &a);    uint16_t net_a = htons(a);    send(c, (char*) & net_a, sizeof(net_a), 0);    uint16_t divisors[256];    int n = recv(c, (char*)divisors, sizeof(divisors), 0) / sizeof(uint16_t);    printf("Divisors: ");    for (int i = 0; i < n; i++) {        uint16_t val = ntohs(divisors[i]);        if (val == 0) break;        printf("%d ", val);    }    printf("\n");    closesocket(c);    WSACleanup();    return 0;}--thread#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 4321void* handle_client(int client) {    uint16_t a;    if (recv(c, (char*)&a, sizeof(a), 0) != sizeof(a)) {        closesocket(c);        return 0;    }    a = ntohs(a);    uint16_t divisors[256] = { 0 };    int count = 0;    for (uint16_t i = 1; i <= a && count < 256; i++) {        if (a % i == 0) {            divisors[count++] = htons(i);        }    }    divisors[count] = 0;    send(c, (char*)divisors, (count + 1) * sizeof(uint16_t), 0);    printf("Client handled.\n");    return 0;}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        SOCKET client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");            // Allocate memory for SOCKET            SOCKET* pclient = (SOCKET*)malloc(sizeof(SOCKET));            if (!pclient) {                printf("Memory allocation failed!\n");                closesocket(client);                return 0;            }            *pclient = client;            std::thread t(handle_client, client);		t.detach();            }        }    }    closesocket(server);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    SOCKET c;    struct sockaddr_in server;    WSAStartup(MAKEWORD(2, 2), &wsa);    c = socket(AF_INET, SOCK_STREAM, 0);    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Connection failed!\n");        return 1;    }    uint16_t a;    printf("Enter a number: ");    scanf("%hu", &a);    uint16_t net_a = htons(a);    send(c, (char*)&net_a, sizeof(net_a), 0);    uint16_t divisors[256];    int n = recv(c, (char*)divisors, sizeof(divisors), 0) / sizeof(uint16_t);    printf("Divisors: ");    for (int i = 0; i < n; i++) {        uint16_t val = ntohs(divisors[i]);        if (val == 0) break;        printf("%d ", val);    }    printf("\n");    WSACleanup();    return 0;}6.   The client sends to the server a string and a character. The server returns to the client a list of all positions in the string where specified character is found.--no threadserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) { printf("Socket error\n"); return 1; }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) {            printf("Accept failed\n");            continue;        }        uint16_t len;        if (recv(c, (char*)&len, sizeof(len), 0) != sizeof(len)) {            printf("Receive length failed\n");            closesocket(c);            continue;        }        len = ntohs(len);        char* buffer = (char*)malloc(len + 1);        if (!buffer) {            printf("Memory allocation failed\n");            closesocket(c);            continue;        }        if (recv(c, buffer, len, 0) != len) {            printf("Receive data failed\n");            free(buffer);            closesocket(c);            continue;        }        buffer[len] = '\0';        char cr;        if (recv(c, (char*)&cr, sizeof(cr), 0) != sizeof(cr)) {            printf("Receive char failed\n");            free(buffer);            closesocket(c);            continue;        }        uint16_t positions[256];        uint16_t count = 0;        for (uint16_t i = 0; i < len; i++) {            if (buffer[i] == cr) {                positions[count++] = htons(i);            }        }        uint16_t net_count = htons(count);        send(c, (char*)&net_count, sizeof(net_count), 0);        send(c, (char*)positions, count * sizeof(uint16_t), 0);        free(buffer);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#include <string.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) {        printf("Socket error\n");        return 1;    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("192.168.1.131");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connect failed\n");        closesocket(c);        return 1;    }    char buffer[256];    printf("Enter string: ");    fgets(buffer, sizeof(buffer), stdin);    size_t len = strlen(buffer);    if (len > 0 && buffer[len - 1] == '\n') {        buffer[len - 1] = '\0';        len--;    }    uint16_t net_len = htons((uint16_t)len);    send(c, (char*)&net_len, sizeof(net_len), 0);    send(c, buffer, len, 0);    char cr;    printf("Enter character: ");    scanf(" %c", &cr);    send(c, (char*)&cr, sizeof(cr), 0);    uint16_t net_count;    recv(c, (char*)&net_count, sizeof(net_count), 0);    uint16_t count = ntohs(net_count);    uint16_t positions[256];    recv(c, (char*)positions, count * sizeof(uint16_t), 0);    printf("Character '%c' found at positions: ", cr);    for (int i = 0; i < count; i++) {        printf("%d ", ntohs(positions[i]));    }    printf("\n");    closesocket(c);    WSACleanup();    return 0;}--threadserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 1234void* handle_client(int client) {    // Receive string length (16-bit)    uint16_t len_net;    if (recv(client, (char*)&len_net, sizeof(len_net), 0) != sizeof(len_net)) {        closesocket(client);        return;    }    uint16_t len = ntohs(len_net);    if (len == 0) len = 1;    // Allocate buffer    char* buffer = (char*)malloc(len + 1);    if (!buffer) { closesocket(client); return; }    if (recv(client, buffer, len, 0) != len) {        free(buffer);        closesocket(client);        return;    }    buffer[len] = '\0';    // Receive character to find    char cr;    if (recv(client, &cr, sizeof(cr), 0) != sizeof(cr)) {        free(buffer);        closesocket(client);        return;    }    // Find all positions    uint16_t positions[256];    uint16_t count = 0;    for (uint16_t i = 0; i < len; i++) {        if (buffer[i] == cr) {            positions[count++] = htons(i);        }    }    // Send count and positions back    uint16_t net_count = htons(count);    send(client, (char*)&net_count, sizeof(net_count), 0);    if (count > 0) {        send(client, (char*)positions, count * sizeof(uint16_t), 0);    }    free(buffer);    closesocket(client);    printf("Client handled: '%c' found %d times\n", cr, count);}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed: %d\n", WSAGetLastError());        return 1;    }    server = socket(AF_INET, SOCK_STREAM, 0);    if (server == INVALID_SOCKET) {        printf("Socket creation failed: %d\n", WSAGetLastError());        return 1;    }    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    if (bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed: %d\n", WSAGetLastError());        return 1;    }    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before7.   The client sends to the server a string and two numbers (s, I, l). The sever returns to the client the substring of s starting at index I, of length l.--no threadserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#include <string.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) { printf("Socket error\n"); return 1; }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) {            printf("Accept failed\n");            continue;        }        uint16_t len;        if (recv(c, (char*)&len, sizeof(len), 0) != sizeof(len)) {            printf("Receive length failed\n");            closesocket(c);            continue;        }        len = ntohs(len);        char* buffer = (char*)malloc(len + 1);        if (!buffer) {            printf("Memory allocation failed\n");            closesocket(c);            continue;        }        if (recv(c, buffer, len, 0) != len) {            printf("Receive string failed\n");            free(buffer);            closesocket(c);            continue;        }        buffer[len] = '\0';        uint16_t I, L;        if (recv(c, (char*)&I, sizeof(I), 0) != sizeof(I) ||            recv(c, (char*)&L, sizeof(L), 0) != sizeof(L)) {            printf("Receive I or L failed\n");            free(buffer);            closesocket(c);            continue;        }        I = ntohs(I);        L = ntohs(L);        if (I >= len) {            send(c, "Invalid index", 13, 0);            free(buffer);            closesocket(c);            continue;        }        if (I + L > len) {            L = len - I;        }        char* substring = (char*)malloc(L + 1);        if (!substring) {            printf("Memory allocation failed\n");            free(buffer);            closesocket(c);            continue;        }        strncpy(substring, buffer + I, L);        substring[L] = '\0';        send(c, substring, strlen(substring), 0);        free(buffer);        free(substring);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#include <string.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) {        printf("Socket error\n");        return 1;    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("192.168.1.131"); // change if needed    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connect failed\n");        closesocket(c);        return 1;    }    char buffer[256];    printf("Enter string: ");    fgets(buffer, sizeof(buffer), stdin);    size_t len = strlen(buffer);    if (len > 0 && buffer[len - 1] == '\n') {        buffer[len - 1] = '\0';        len--;    }    uint16_t net_len = htons((uint16_t)len);    send(c, (char*)&net_len, sizeof(net_len), 0);    send(c, buffer, len, 0);    uint16_t I, L;    printf("Index: ");    scanf("%hu", &I);    printf("Length: ");    scanf("%hu", &L);    uint16_t net_I = htons(I);    uint16_t net_L = htons(L);    send(c, (char*)&net_I, sizeof(net_I), 0);    send(c, (char*)&net_L, sizeof(net_L), 0);    char substring[256];    int bytes = recv(c, substring, sizeof(substring) - 1, 0);    if (bytes > 0) {        substring[bytes] = '\0';        printf("Substring: %s\n", substring);    }    else {        printf("Failed to receive substring.\n");    }    closesocket(c);    WSACleanup();    return 0;}--threadserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#include <string.h>#pragma comment(lib, "ws2_32.lib")#define PORT 1234void* handle_client(int client) {    // Receive string length    uint16_t len_net;    if (recv(client, (char*)&len_net, sizeof(len_net), 0) != sizeof(len_net)) {        closesocket(client);        return;    }    uint16_t len = ntohs(len_net);    if (len == 0) len = 1;    char* buffer = (char*)malloc(len + 1);    if (!buffer) { closesocket(client); return; }    if (recv(client, buffer, len, 0) != len) {        free(buffer);        closesocket(client);        return;    }    buffer[len] = '\0';    // Receive I and L    uint16_t I_net, L_net;    if (recv(client, (char*)&I_net, sizeof(I_net), 0) != sizeof(I_net) ||        recv(client, (char*)&L_net, sizeof(L_net), 0) != sizeof(L_net)) {        free(buffer);        closesocket(client);        return;    }    uint16_t I = ntohs(I_net);    uint16_t L = ntohs(L_net);    if (I >= len) {        send(client, "Invalid index", 13, 0);        free(buffer);        closesocket(client);        return;    }    if (I + L > len) L = len - I;    char* substring = (char*)malloc(L + 1);    if (!substring) {        free(buffer);        closesocket(client);        return;    }    strncpy(substring, buffer + I, L);    substring[L] = '\0';    send(client, substring, strlen(substring), 0);    free(buffer);    free(substring);    closesocket(client);    printf("Client handled: substring sent.\n");}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before8.   The client sends to the server two arrays of integers. The server returns an arrays containing the common numbers found in both arrays.--no threadserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) { printf("Accept failed\n"); continue; }        uint16_t net_n1, net_n2;        recv(c, (char*)&net_n1, sizeof(net_n1), 0);        uint16_t n1 = ntohs(net_n1);        int* a1 = (int*)malloc(n1 * sizeof(int));        for (int i = 0; i < n1; i++) {            int net_val;            recv(c, (char*)&net_val, sizeof(net_val), 0);            a1[i] = ntohl(net_val);        }        recv(c, (char*)&net_n2, sizeof(net_n2), 0);        uint16_t n2 = ntohs(net_n2);        int* a2 = (int*)malloc(n2 * sizeof(int));        for (int i = 0; i < n2; i++) {            int net_val;            recv(c, (char*)&net_val, sizeof(net_val), 0);            a2[i] = ntohl(net_val);        }        int max_common = (n1 < n2 ? n1 : n2);        int* common = (int*)malloc(max_common * sizeof(int));        int k = 0;        // find common elements        for (int i = 0; i < n1; i++) {            for (int j = 0; j < n2; j++) {                if (a1[i] == a2[j]) {                    int already = 0;                    for (int x = 0; x < k; x++)                        if (common[x] == a1[i]) { already = 1; break; }                    if (!already) common[k++] = a1[i];                }            }        }        uint16_t net_k = htons(k);        send(c, (char*)&net_k, sizeof(net_k), 0);        for (int i = 0; i < k; i++) {            int net_val = htonl(common[i]);            send(c, (char*)&net_val, sizeof(net_val), 0);        }        printf("Processed client. Common count: %d\n", k);        free(a1); free(a2); free(common);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("192.168.1.131");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connection failed\n");        closesocket(c);        return 1;    }    uint16_t n1, n2;    printf("Enter number of elements for first array: ");    scanf("%hu", &n1);    int* arr1 = (int*)malloc(n1 * sizeof(int));  // correct size    printf("Enter %hu integers:\n", n1);    for (int i = 0; i < n1; i++) scanf("%d", &arr1[i]);    printf("Enter number of elements for second array: ");    scanf("%hu", &n2);    int* arr2 = (int*)malloc(n2 * sizeof(int));  // correct size    printf("Enter %hu integers:\n", n2);    for (int i = 0; i < n2; i++) scanf("%d", &arr2[i]);    // send first array    uint16_t net_n1 = htons(n1);    send(c, (char*)&net_n1, sizeof(net_n1), 0);    for (int i = 0; i < n1; i++) {        int net_val = htonl(arr1[i]);        send(c, (char*)&net_val, sizeof(net_val), 0);    }    // send second array    uint16_t net_n2 = htons(n2);    send(c, (char*)&net_n2, sizeof(net_n2), 0);    for (int i = 0; i < n2; i++) {        int net_val = htonl(arr2[i]);        send(c, (char*)&net_val, sizeof(net_val), 0);    }    // receive common array    uint16_t net_k;    if (recv(c, (char*)&net_k, sizeof(net_k), 0) != sizeof(net_k)) {        printf("Failed to receive result size\n");        free(arr1); free(arr2);        closesocket(c);        WSACleanup();        return 1;    }    uint16_t k = ntohs(net_k);    int* common = (int*)malloc(k * sizeof(int));  // correct size    for (int i = 0; i < k; i++) {        int net_val;        recv(c, (char*)&net_val, sizeof(net_val), 0);        common[i] = ntohl(net_val);    }    printf("Common elements (%hu): ", k);    for (int i = 0; i < k; i++) printf("%d ", common[i]);    printf("\n");    free(arr1); free(arr2); free(common);    closesocket(c);    WSACleanup();    return 0;}--threadserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 1234void* handle_client(int client) {    // Receive first array    uint16_t net_n1;    if (recv(client, (char*)&net_n1, sizeof(net_n1), 0) != sizeof(net_n1)) {        closesocket(client);        return;    }    uint16_t n1 = ntohs(net_n1);    int* a1 = (int*)malloc(n1 * sizeof(int));    for (int i = 0; i < n1; i++) {        int net_val;        recv(client, (char*)&net_val, sizeof(net_val), 0);        a1[i] = ntohl(net_val);    }    // Receive second array    uint16_t net_n2;    if (recv(client, (char*)&net_n2, sizeof(net_n2), 0) != sizeof(net_n2)) {        free(a1);        closesocket(client);        return;    }    uint16_t n2 = ntohs(net_n2);    int* a2 = (int*)malloc(n2 * sizeof(int));    for (int i = 0; i < n2; i++) {        int net_val;        recv(client, (char*)&net_val, sizeof(net_val), 0);        a2[i] = ntohl(net_val);    }    // Find common elements    int max_common = (n1 < n2 ? n1 : n2);    int* common = (int*)malloc(max_common * sizeof(int));    int k = 0;    for (int i = 0; i < n1; i++) {        for (int j = 0; j < n2; j++) {            if (a1[i] == a2[j]) {                int already = 0;                for (int x = 0; x < k; x++)                    if (common[x] == a1[i]) { already = 1; break; }                if (!already) common[k++] = a1[i];            }        }    }    // Send result    uint16_t net_k = htons(k);    send(client, (char*)&net_k, sizeof(net_k), 0);    for (int i = 0; i < k; i++) {        int net_val = htonl(common[i]);        send(client, (char*)&net_val, sizeof(net_val), 0);    }    printf("Client handled: common count = %d\n", k);    free(a1); free(a2); free(common);    closesocket(client);}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before9.   The client sends to the server two arrays of numbers. The server returns to the client a list of numbers that are present in the first arrays but not in the second.--no threadsserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) { printf("Accept failed\n"); continue; }        uint16_t net_n1, net_n2;        recv(c, (char*)&net_n1, sizeof(net_n1), 0);        uint16_t n1 = ntohs(net_n1);        int* a1 = (int*)malloc(n1 * sizeof(int));        for (int i = 0; i < n1; i++) {            int net_val;            recv(c, (char*)&net_val, sizeof(net_val), 0);            a1[i] = ntohl(net_val);        }        recv(c, (char*)&net_n2, sizeof(net_n2), 0);        uint16_t n2 = ntohs(net_n2);        int* a2 = (int*)malloc(n2 * sizeof(int));        for (int i = 0; i < n2; i++) {            int net_val;            recv(c, (char*)&net_val, sizeof(net_val), 0);            a2[i] = ntohl(net_val);        }        int max_common = (n1 < n2 ? n1 : n2);        int* uncommon = (int*)malloc(max_common * sizeof(int));        int k = 0;        for (int i = 0; i < n1; i++) {            int found = 0;            for (int j = 0; j < n2; j++) {                if (a1[i] == a2[j]) {                    found = 1;                    break;                }              }             if(!found) uncommon[k++] = a1[i];        }         uint16_t net_k = htons(k);        send(c, (char*)&net_k, sizeof(net_k), 0);        for (int i = 0; i < k; i++) {            int net_val = htonl(uncommon[i]);            send(c, (char*)&net_val, sizeof(net_val), 0);        }        printf("Processed client. Uncommon count: %d\n", k);        free(a1); free(a2); free(uncommon);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("192.168.1.131");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connection failed\n");        closesocket(c);        return 1;    }    uint16_t n1, n2;    printf("Enter number of elements for first array: ");    scanf("%hu", &n1);    int* arr1 = (int*)malloc(n1 * sizeof(int));  // correct size    printf("Enter %hu integers:\n", n1);    for (int i = 0; i < n1; i++) scanf("%d", &arr1[i]);    printf("Enter number of elements for second array: ");    scanf("%hu", &n2);    int* arr2 = (int*)malloc(n2 * sizeof(int));  // correct size    printf("Enter %hu integers:\n", n2);    for (int i = 0; i < n2; i++) scanf("%d", &arr2[i]);    // send first array    uint16_t net_n1 = htons(n1);    send(c, (char*)&net_n1, sizeof(net_n1), 0);    for (int i = 0; i < n1; i++) {        int net_val = htonl(arr1[i]);        send(c, (char*)&net_val, sizeof(net_val), 0);    }    // send second array    uint16_t net_n2 = htons(n2);    send(c, (char*)&net_n2, sizeof(net_n2), 0);    for (int i = 0; i < n2; i++) {        int net_val = htonl(arr2[i]);        send(c, (char*)&net_val, sizeof(net_val), 0);    }    // receive uncommon array    uint16_t net_k;    if (recv(c, (char*)&net_k, sizeof(net_k), 0) != sizeof(net_k)) {        printf("Failed to receive result size\n");        free(arr1); free(arr2);        closesocket(c);        WSACleanup();        return 1;    }    uint16_t k = ntohs(net_k);    int* uncommon = (int*)malloc(k * sizeof(int));    for (int i = 0; i < k; i++) {        int net_val;        recv(c, (char*)&net_val, sizeof(net_val), 0);        uncommon[i] = ntohl(net_val);    }    printf("Uncommon elements (%hu): ", k);    for (int i = 0; i < k; i++) printf("%d ", uncommon[i]);    printf("\n");    free(arr1); free(arr2); free(uncommon);    closesocket(c);    WSACleanup();    return 0;}--threadsserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 1234void* handle_client(int client) {    // Receive first array    uint16_t net_n1;    if (recv(client, (char*)&net_n1, sizeof(net_n1), 0) != sizeof(net_n1)) {        closesocket(client);        return;    }    uint16_t n1 = ntohs(net_n1);    int* a1 = (int*)malloc(n1 * sizeof(int));    for (int i = 0; i < n1; i++) {        int net_val;        recv(client, (char*)&net_val, sizeof(net_val), 0);        a1[i] = ntohl(net_val);    }    // Receive second array    uint16_t net_n2;    if (recv(client, (char*)&net_n2, sizeof(net_n2), 0) != sizeof(net_n2)) {        free(a1);        closesocket(client);        return;    }    uint16_t n2 = ntohs(net_n2);    int* a2 = (int*)malloc(n2 * sizeof(int));    for (int i = 0; i < n2; i++) {        int net_val;        recv(client, (char*)&net_val, sizeof(net_val), 0);        a2[i] = ntohl(net_val);    }    // Find elements in a1 not in a2    int max_uncommon = n1;    int* uncommon = (int*)malloc(max_uncommon * sizeof(int));    int k = 0;    for (int i = 0; i < n1; i++) {        int found = 0;        for (int j = 0; j < n2; j++) {            if (a1[i] == a2[j]) {                found = 1;                break;            }        }        if (!found) uncommon[k++] = a1[i];    }    // Send result    uint16_t net_k = htons(k);    send(client, (char*)&net_k, sizeof(net_k), 0);    for (int i = 0; i < k; i++) {        int net_val = htonl(uncommon[i]);        send(client, (char*)&net_val, sizeof(net_val), 0);    }    printf("Client handled: uncommon count = %d\n", k);    free(a1); free(a2); free(uncommon);    closesocket(client);}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before10.The client sends to the server two strings. The server sends back the character with the largest number of occurrences on the same positions in both strings together with its count.--no threadsserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) { printf("Accept failed\n"); continue; }        uint16_t net_len1, net_len2;        recv(c, (char*)&net_len1, sizeof(net_len1), 0);        recv(c, (char*)&net_len2, sizeof(net_len2), 0);        uint16_t len1 = ntohs(net_len1);        uint16_t len2 = ntohs(net_len2);        char* str1 = (char*)malloc(len1 + 1);        char* str2 = (char*)malloc(len2 + 1);        recv(c, str1, len1, 0);        recv(c, str2, len2, 0);        str1[len1] = '\0';        str2[len2] = '\0';        int min_len = (len1 < len2) ? len1 : len2;        int freq[256] = { 0 };        for (int i = 0; i < min_len; i++) {            if (str1[i] == str2[i]) freq[(unsigned char)str1[i]]++;        }        char max_ch = 0;        int max_count = 0;        for (int i = 0; i < 256; i++) {            if (freq[i] > max_count) {                max_count = freq[i];                max_ch = (char)i;            }        }        uint16_t net_max_count = htons(max_count);        send(c, &max_ch, sizeof(max_ch), 0);        send(c, (char*)&net_max_count, sizeof(net_max_count), 0);        free(str1);        free(str2);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("192.168.1.131"); // change as needed    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connection failed\n");        closesocket(c);        return 1;    }    char buffer1[256], buffer2[256];    printf("Enter first string: ");    fgets(buffer1, sizeof(buffer1), stdin);    buffer1[strcspn(buffer1, "\n")] = '\0'; // remove newline    printf("Enter second string: ");    fgets(buffer2, sizeof(buffer2), stdin);    buffer2[strcspn(buffer2, "\n")] = '\0'; // remove newline    uint16_t len1 = (uint16_t)strlen(buffer1);    uint16_t len2 = (uint16_t)strlen(buffer2);    uint16_t net_len1 = htons(len1);    uint16_t net_len2 = htons(len2);    // send lengths    send(c, (char*)&net_len1, sizeof(net_len1), 0);    send(c, (char*)&net_len2, sizeof(net_len2), 0);    // send strings    send(c, buffer1, len1, 0);    send(c, buffer2, len2, 0);    // receive result    char ch;    uint16_t net_count;    recv(c, &ch, sizeof(ch), 0);    recv(c, (char*)&net_count, sizeof(net_count), 0);    uint16_t count = ntohs(net_count);    printf("Most common character at same positions: '%c' with count: %hu\n", ch, count);    closesocket(c);    WSACleanup();    return 0;}--threadserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#include <string.h>#pragma comment(lib, "ws2_32.lib")#define PORT 1234void handle_client(int client) {    // Receive lengths    uint16_t net_len1, net_len2;    if (recv(client, (char*)&net_len1, sizeof(net_len1), 0) != sizeof(net_len1) ||        recv(client, (char*)&net_len2, sizeof(net_len2), 0) != sizeof(net_len2)) {        closesocket(client);        return;    }    uint16_t len1 = ntohs(net_len1);    uint16_t len2 = ntohs(net_len2);    char* str1 = (char*)malloc(len1 + 1);    char* str2 = (char*)malloc(len2 + 1);    if (!str1 || !str2) { free(str1); free(str2); closesocket(client); return; }    if (recv(client, str1, len1, 0) != len1 ||        recv(client, str2, len2, 0) != len2) {        free(str1); free(str2); closesocket(client); return;    }    str1[len1] = '\0';    str2[len2] = '\0';    // Count matching character frequencies at same positions    int min_len = (len1 < len2) ? len1 : len2;    int freq[256] = { 0 };    for (int i = 0; i < min_len; i++) {        if (str1[i] == str2[i]) freq[(unsigned char)str1[i]]++;    }    char max_ch = 0;    int max_count = 0;    for (int i = 0; i < 256; i++) {        if (freq[i] > max_count) {            max_count = freq[i];            max_ch = (char)i;        }    }    uint16_t net_max_count = htons(max_count);    send(client, &max_ch, sizeof(max_ch), 0);    send(client, (char*)&net_max_count, sizeof(net_max_count), 0);    printf("Client handled: max char '%c' count = %d\n", max_ch, max_count);    free(str1); free(str2);    closesocket(client);}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before11.Define a simple structure (e.g., a Person object with firstname, lastname, gender  and age). The client sends this structure to the server. The server increments the age and sends the updated structure back.--no threadsclient.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")typedef struct {    char firstname[32];    char lastname[32];    char gender; // 'M' or 'F'    uint8_t age;} Person;int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connection failed\n");        return 1;    }    Person p;    printf("Enter firstname: "); scanf("%31s", p.firstname);    printf("Enter lastname: "); scanf("%31s", p.lastname);    printf("Enter gender (M/F): "); scanf(" %c", &p.gender);    printf("Enter age: "); scanf("%hhu", &p.age);    send(c, (char*)&p, sizeof(Person), 0);    recv(c, (char*)&p, sizeof(Person), 0);    printf("Updated person: %s %s, gender %c, age %d\n",        p.firstname, p.lastname, p.gender, p.age);    closesocket(c);    WSACleanup();    return 0;}server.c#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")typedef struct {    char firstname[32];    char lastname[32];    char gender;    uint8_t age;} Person;int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) continue;        Person p;        recv(c, (char*)&p, sizeof(Person), 0);        p.age++; // increment age        send(c, (char*)&p, sizeof(Person), 0);        printf("Processed client: %s %s, new age %d\n", p.firstname, p.lastname, p.age);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}--threadsserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 1234typedef struct {    char firstname[32];    char lastname[32];    char gender;    uint8_t age;} Person;void handle_client(int client) {    Person p;    if (recv(client, (char*)&p, sizeof(Person), 0) != sizeof(Person)) {        closesocket(client);        return;    }    p.age++; // increment age    send(client, (char*)&p, sizeof(Person), 0);    printf("Processed client: %s %s, new age %d\n", p.firstname, p.lastname, p.age);    closesocket(client);}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Person server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before12.The client sends a date string in YYYY-MM-DD format. The server returns the day of the week corresponding to that date.--no threadsclient.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) return 1;    char date[11];    printf("Enter date YYYY-MM-DD: ");    scanf("%10s", date);    send(c, date, sizeof(date), 0);    char day[16];    recv(c, day, sizeof(day), 0);    printf("Day of the week: %s\n", day);    closesocket(c);    WSACleanup();    return 0;}server.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <time.h>#pragma comment(lib,"Ws2_32.lib")const char* weekdays[] = { "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday" };int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) continue;        char date[11];        recv(c, date, sizeof(date), 0);        int y, m, d;        sscanf(date, "%4d-%2d-%2d", &y, &m, &d);        struct tm t = { 0 };        t.tm_year = y - 1900;        t.tm_mon = m - 1;        t.tm_mday = d;        mktime(&t); // normalize, fills tm_wday        char day[16];        strcpy(day, weekdays[t.tm_wday]);        send(c, day, (int)strlen(day) + 1, 0);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}--threadsserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <time.h>#pragma comment(lib, "ws2_32.lib")#define PORT 1234const char* weekdays[] = { "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday" };void handle_client(int client) {    char date[11];    if (recv(client, date, sizeof(date), 0) != sizeof(date)) {        closesocket(client);        return;    }    int y, m, d;    sscanf(date, "%4d-%2d-%2d", &y, &m, &d);    struct tm t = {0};    t.tm_year = y - 1900;    t.tm_mon = m - 1;    t.tm_mday = d;    mktime(&t); // normalize, fills tm_wday    char day[16];    strcpy(day, weekdays[t.tm_wday]);    send(client, day, (int)strlen(day) + 1, 0);    printf("Processed client: %s -> %s\n", date, day);    closesocket(client);}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Day-of-week server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before13.The client sends a small text file to the server. The server saves the file and returns the length of the received file content as an unsigned integer--no threadsclient.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define PORT 1234#define MAX_FILENAME 256int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = inet_addr(SERVER_IP);    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connection failed\n");        closesocket(c);        return 1;    }    // Get filename    char filename[MAX_FILENAME];    printf("Enter filename to send: ");    scanf("%s", filename);    FILE* f = fopen(filename, "rb");    if (!f) { printf("Failed to open file '%s'\n", filename); closesocket(c); return 1; }    // Get file size    fseek(f, 0, SEEK_END);    long file_size = ftell(f);    fseek(f, 0, SEEK_SET);    char* buffer = (char*)malloc(file_size);    if (!buffer) { fclose(f); closesocket(c); return 1; }    fread(buffer, 1, file_size, f);    fclose(f);    // Send filename length and filename    uint16_t name_len = htons((uint16_t)strlen(filename));    send(c, (char*)&name_len, sizeof(name_len), 0);    send(c, filename, strlen(filename), 0);    // Send file content length and content    uint32_t content_len = htonl((uint32_t)file_size);    send(c, (char*)&content_len, sizeof(content_len), 0);    send(c, buffer, file_size, 0);    // Receive confirmation (file size)    uint32_t net_received;    if (recv(c, (char*)&net_received, sizeof(net_received), 0) == sizeof(net_received)) {        uint32_t received = ntohl(net_received);        printf("Server received %u bytes.\n", received);    }    free(buffer);    closesocket(c);    WSACleanup();    return 0;}server.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")#define PORT 1234#define MAX_FILENAME 256int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) { printf("Socket creation failed\n"); return 1; }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port %d...\n", PORT);    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) { printf("Accept failed\n"); continue; }        // Receive filename length        uint16_t net_name_len;        if (recv(c, (char*)&net_name_len, sizeof(net_name_len), 0) != sizeof(net_name_len)) {            printf("Failed to receive filename length\n");            closesocket(c);            continue;        }        uint16_t name_len = ntohs(net_name_len);        if (name_len >= MAX_FILENAME) name_len = MAX_FILENAME - 1;        // Receive filename        char filename[MAX_FILENAME];        if (recv(c, filename, name_len, 0) != name_len) {            printf("Failed to receive filename\n");            closesocket(c);            continue;        }        filename[name_len] = '\0';        // Open file for writing        FILE* f = fopen(filename, "wb");        if (!f) {            printf("Failed to open file '%s'\n", filename);            closesocket(c);            continue;        }        // Receive file content length        uint32_t net_content_len;        if (recv(c, (char*)&net_content_len, sizeof(net_content_len), 0) != sizeof(net_content_len)) {            printf("Failed to receive content length\n");            fclose(f);            closesocket(c);            continue;        }        uint32_t content_len = ntohl(net_content_len);        // Receive file content        char* buffer = (char*)malloc(content_len);        if (!buffer) { fclose(f); closesocket(c); continue; }        uint32_t received = 0;        while (received < content_len) {            int bytes = recv(c, buffer + received, content_len - received, 0);            if (bytes <= 0) break;            received += bytes;        }        fwrite(buffer, 1, received, f);        fclose(f);        free(buffer);        // Send back file size        uint32_t net_received = htonl(received);        send(c, (char*)&net_received, sizeof(net_received), 0);        printf("Saved file '%s' (%u bytes)\n", filename, received);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}--threadsserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <stdint.h>#include <thread>#pragma comment(lib, "Ws2_32.lib")#define PORT 1234#define MAX_FILENAME 256void handle_client(int client) {    // Receive filename length    uint16_t net_name_len;    if (recv(client, (char*)&net_name_len, sizeof(net_name_len), 0) != sizeof(net_name_len)) {        printf("Failed to receive filename length\n");        closesocket(client);        return;    }    uint16_t name_len = ntohs(net_name_len);    if (name_len >= MAX_FILENAME) name_len = MAX_FILENAME - 1;    // Receive filename    char filename[MAX_FILENAME];    if (recv(client, filename, name_len, 0) != name_len) {        printf("Failed to receive filename\n");        closesocket(client);        return;    }    filename[name_len] = '\0';    // Open file for writing    FILE* f = fopen(filename, "wb");    if (!f) {        printf("Failed to open file '%s'\n", filename);        closesocket(client);        return;    }    // Receive file content length    uint32_t net_content_len;    if (recv(client, (char*)&net_content_len, sizeof(net_content_len), 0) != sizeof(net_content_len)) {        printf("Failed to receive content length\n");        fclose(f);        closesocket(client);        return;    }    uint32_t content_len = ntohl(net_content_len);    // Receive file content    char* buffer = (char*)malloc(content_len);    if (!buffer) {        fclose(f);        closesocket(client);        return;    }    uint32_t received = 0;    while (received < content_len) {        int bytes = recv(client, buffer + received, content_len - received, 0);        if (bytes <= 0) break;        received += bytes;    }    fwrite(buffer, 1, received, f);    fclose(f);    free(buffer);    // Send back file size    uint32_t net_received = htonl(received);    send(client, (char*)&net_received, sizeof(net_received), 0);    printf("Saved file '%s' (%u bytes)\n", filename, received);    closesocket(client);}int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET server = socket(AF_INET, SOCK_STREAM, 0);    if (server == INVALID_SOCKET) {        printf("Socket creation failed\n");        return 1;    }    struct sockaddr_in server_addr, client_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    int client_len = sizeof(client_addr);    while (1) {        SOCKET client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            printf("Client connected!\n");            std::thread t(handle_client, client);            t.detach(); // detach to handle multiple clients        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as before14.The client sends an array of boolean values. The server counts how many true values are in the array and returns the count..--no threadsclient.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET c = socket(AF_INET, SOCK_STREAM, 0);    if (c == INVALID_SOCKET) {        printf("Socket creation failed\n");        return 1;    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("192.168.1.131"); // change as needed    if (connect(c, (struct sockaddr*)&server, sizeof(server)) != 0) {        printf("Connection failed\n");        closesocket(c);        return 1;    }    uint16_t n;    printf("Enter number of elements: ");    scanf("%hu", &n);    int* arr = (int*)malloc(n * sizeof(int));    if (!arr) {        printf("Memory allocation failed\n");        closesocket(c);        WSACleanup();        return 1;    }    printf("Enter %hu boolean values (0 or 1):\n", n);    for (int i = 0; i < n; i++) {        scanf("%d", &arr[i]);    }    // Send number of elements in network order    uint16_t net_n = htons(n);    send(c, (char*)&net_n, sizeof(net_n), 0);    // Send elements    for (int i = 0; i < n; i++) {        int net_val = htonl(arr[i]);        send(c, (char*)&net_val, sizeof(net_val), 0);    }    // Receive result    uint16_t net_count;    if (recv(c, (char*)&net_count, sizeof(net_count), 0) != sizeof(net_count)) {        printf("Failed to receive count from server\n");    }    else {        uint16_t count = ntohs(net_count);        printf("Server counted %hu TRUE values.\n", count);    }    free(arr);    closesocket(c);    WSACleanup();    return 0;}server.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <WinSock2.h>#include <stdint.h>#pragma comment(lib, "Ws2_32.lib")int main() {    WSADATA wsaData;    WSAStartup(MAKEWORD(2, 2), &wsaData);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Socket creation failed\n");        return 1;    }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("Server listening on port 1234...\n");    int client_len = sizeof(client);    while (1) {        SOCKET c = accept(s, (struct sockaddr*)&client, &client_len);        if (c == INVALID_SOCKET) {            printf("Accept failed\n");            continue;        }        uint16_t net_n;        if (recv(c, (char*)&net_n, sizeof(net_n), 0) != sizeof(net_n)) {            printf("Failed to receive n\n");            closesocket(c);            continue;        }        uint16_t n = ntohs(net_n);        int* arr = (int*)malloc(n * sizeof(int));        if (!arr) {            printf("Memory allocation failed\n");            closesocket(c);            continue;        }        for (int i = 0; i < n; i++) {            int net_val;            recv(c, (char*)&net_val, sizeof(net_val), 0);            arr[i] = ntohl(net_val);        }        int count = 0;        for (int i = 0; i < n; i++) {            if (arr[i] == 1)                count++;        }        uint16_t net_count = htons((uint16_t)count);        send(c, (char*)&net_count, sizeof(net_count), 0);        printf("Processed client. TRUE count: %d\n", count);        free(arr);        closesocket(c);    }    closesocket(s);    WSACleanup();    return 0;}--threadsserver.c#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 1234void handle_client(int client) {    uint16_t net_n;    if (recv(client, (char*)&net_n, sizeof(net_n), 0) != sizeof(net_n)) {        closesocket(client);        return;    }    uint16_t n = ntohs(net_n);    int* arr = (int*)malloc(n * sizeof(int));    if (!arr) { closesocket(client); return; }    for (int i = 0; i < n; i++) {        int net_val;        recv(client, (char*)&net_val, sizeof(net_val), 0);        arr[i] = ntohl(net_val);    }    int count = 0;    for (int i = 0; i < n; i++)        if (arr[i] == 1) count++;    uint16_t net_count = htons((uint16_t)count);    send(client, (char*)&net_count, sizeof(net_count), 0);    printf("Processed client. TRUE count: %d\n", count);    free(arr);    closesocket(client);}int main() {    WSADATA wsa;    SOCKET server, client;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(PORT);    bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server, 5);    printf("Array TRUE count server listening on port %d...\n", PORT);    while (1) {        client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client != INVALID_SOCKET) {            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server);    WSACleanup();    return 0;}client.csame as beforeLAB21.   The client takes a string from the command line and sends it to the server. The server interprets the string as a command with its parameters. It executes the command and returns the standard output and the exit code to the client.--tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <windows.h>#include <stdint.h>#include <thread>#pragma comment(lib, "ws2_32.lib")void handle_client(int client) {	char cmd[256];	int bytes = recv(client, cmd, sizeof(cmd) - 1, 0);	if (bytes <= 0) {		printf("Client disconnected.\n");		closesocket(client);		return;	}	cmd[bytes] = '\0';	printf("Received command: %s\n", cmd);	// Execute the command and capture output	FILE* fp = _popen(cmd, "r");	if (!fp) {		uint32_t error_code = htonl(1);		send(client, (char*)&error_code, sizeof(error_code), 0);		closesocket(client);		return;	}	char output[1024] = "";	fread(output, 1, sizeof(output) - 1, fp);	int exit_code = _pclose(fp);	// Send the output	uint32_t len = htonl(strlen(output));	send(client, (char*)&len, sizeof(len), 0);	send(client, output, strlen(output), 0);	// Send exit code	uint32_t code = htonl(exit_code);	send(client, (char*)&code, sizeof(code), 0);	printf("Sent output and exit code to client.\n");	closesocket(client);	return;}int main() {	WSADATA wsa;	SOCKET server, client;	struct sockaddr_in server_addr, client_addr;	int client_len = sizeof(client_addr);	WSAStartup(MAKEWORD(2, 2), &wsa);	server = socket(AF_INET, SOCK_STREAM, 0);	server_addr.sin_family = AF_INET;	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(4321);	bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr));	listen(server, 5);	printf("Server listening on port 4321...\n");	while (1) {		client = accept(server, (struct sockaddr*)&client_addr, &client_len);		if (client == INVALID_SOCKET) continue;		printf("Client connected: %s\n", inet_ntoa(client_addr.sin_addr));		std::thread t(handle_client, client);		t.detach();	}	closesocket(server);	WSACleanup();	return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <stdint.h>#pragma comment(lib, "ws2_32.lib")int main(int argc, char* argv[]) {    if (argc < 2) {        printf("Usage: %s <command>\n", argv[0]);        return 1;    }    WSADATA wsa;    SOCKET client;    struct sockaddr_in server_addr;    WSAStartup(MAKEWORD(2, 2), &wsa);    client = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(4321);    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(client, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Failed to connect to server.\n");        return 1;    }    // Combine command arguments into one string    char cmd[256] = "";    for (int i = 1; i < argc; i++) {        strcat(cmd, argv[i]);        if (i < argc - 1) strcat(cmd, " ");    }    send(client, cmd, strlen(cmd), 0);    // Receive output length    uint32_t len;    recv(client, (char*) & len, sizeof(len), 0);    len = ntohl(len);    // Receive output    char* buffer = (char*)malloc(len + 1);    memset(buffer, 0, len + 1);    recv(client, buffer, len, 0);    // Receive exit code    uint32_t code;    recv(client, (char*) & code, sizeof(code), 0);    code = ntohl(code);    printf("Command output:\n%s\n", buffer);    printf("Exit code: %d\n", code);    free(buffer);    closesocket(client);    WSACleanup();    return 0;}--udpclient.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <stdint.h>#pragma comment(lib, "ws2_32.lib")int main(int argc, char* argv[]) {    if (argc < 2) {        printf("Usage: %s <command>\n", argv[0]);        return 1;    }    WSADATA wsa;    SOCKET client;    struct sockaddr_in server_addr;    int server_len = sizeof(server_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    client = socket(AF_INET, SOCK_DGRAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(4321);    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    // Combine all command arguments into one string    char cmd[256] = "";    for (int i = 1; i < argc; i++) {        strcat(cmd, argv[i]);        if (i < argc - 1) strcat(cmd, " ");    }    // Send command    sendto(client, cmd, strlen(cmd), 0,        (struct sockaddr*)&server_addr, server_len);    // Receive output length    uint32_t len;    recvfrom(client, (char*)&len, sizeof(len), 0,        (struct sockaddr*)&server_addr, &server_len);    len = ntohl(len);    // Receive output    char* buffer = (char*)malloc(len + 1);    memset(buffer, 0, len + 1);    recvfrom(client, buffer, len, 0,        (struct sockaddr*)&server_addr, &server_len);    // Receive exit code    uint32_t code;    recvfrom(client, (char*)&code, sizeof(code), 0,        (struct sockaddr*)&server_addr, &server_len);    code = ntohl(code);    printf("Command output:\n%s\n", buffer);    printf("Exit code: %d\n", code);    free(buffer);    closesocket(client);    WSACleanup();    return 0;}server.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <stdint.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa;    SOCKET server;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    char cmd[256];    char output[1024];    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_DGRAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(4321);    if (bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed.\n");        return 1;    }    printf("UDP Server listening on port 4321...\n");    while (1) {        memset(cmd, 0, sizeof(cmd));        int bytes = recvfrom(server, cmd, sizeof(cmd) - 1, 0,            (struct sockaddr*)&client_addr, &client_len);        if (bytes <= 0) continue;        cmd[bytes] = '\0';        printf("Received command from %s: %s\n", inet_ntoa(client_addr.sin_addr), cmd);        // Execute the command        FILE* fp = _popen(cmd, "r");        if (!fp) {            uint32_t error_code = htonl(1);            sendto(server, (char*)&error_code, sizeof(error_code), 0,                (struct sockaddr*)&client_addr, client_len);            continue;        }        memset(output, 0, sizeof(output));        fread(output, 1, sizeof(output) - 1, fp);        int exit_code = _pclose(fp);        // Send output length        uint32_t len = htonl(strlen(output));        sendto(server, (char*)&len, sizeof(len), 0,            (struct sockaddr*)&client_addr, client_len);        // Send output        sendto(server, output, strlen(output), 0,            (struct sockaddr*)&client_addr, client_len);        // Send exit code        uint32_t code = htonl(exit_code);        sendto(server, (char*)&code, sizeof(code), 0,            (struct sockaddr*)&client_addr, client_len);        printf("Response sent to client.\n");    }    closesocket(server);    WSACleanup();    return 0;}2.   The client sends the complete path to a file. The server returns back the length of the file and its content in the case the file exists. When the file does not exist the server returns a length of -1 and no content. The client will store the content in a file with the same name as the input file with the suffix –copy appended (ex: for f.txt => f.txt-copy).--tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define PORT 4321// Thread function to handle one clientvoid handle_client(int c) {        uint16_t path_len_net;    int recv_bytes = recv(c, (char*)&path_len_net, sizeof(path_len_net), 0);    if (recv_bytes <= 0) {        closesocket(c);        return;    }    uint16_t path_len = ntohs(path_len_net);    char* path = (char*)malloc(path_len + 1);    if (!path) {        closesocket(c);        return;    }    recv(c, path, path_len, 0);    path[path_len] = '\0';    printf("Client requested file: %s\n", path);    FILE* f = fopen(path, "rb");    if (!f) {        int32_t len = htonl(-1);        send(c, (char*)&len, sizeof(len), 0);        printf("File not found.\n");        free(path);        closesocket(c);        return;    }    // Read file into buffer    fseek(f, 0, SEEK_END);    long size = ftell(f);    fseek(f, 0, SEEK_SET);    char* buffer = (char*)malloc(size);    if (!buffer) {        fclose(f);        closesocket(c);        free(path);        return;    }    fread(buffer, 1, size, f);    fclose(f);    // Send size + content    int32_t net_size = htonl(size);    send(c, (char*)&net_size, sizeof(net_size), 0);    send(c, buffer, size, 0);    printf("Sent %ld bytes to client.\n", size);    free(buffer);    free(path);    closesocket(c);    return;}int main() {    WSADATA wsa;    SOCKET server;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server = socket(AF_INET, SOCK_STREAM, 0);    if (server == INVALID_SOCKET) {        printf("Socket creation failed.\n");        return 1;    }    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("Bind failed.\n");        closesocket(server);        WSACleanup();        return 1;    }    listen(server, 5);    printf("Server listening on port %d...\n", PORT);    while (1) {        SOCKET client = accept(server, (struct sockaddr*)&client_addr, &client_len);        if (client == INVALID_SOCKET) continue;        printf("Client connected from %s:%d\n",            inet_ntoa(client_addr.sin_addr),            ntohs(client_addr.sin_port));        std::thread t(handle_client, client);		t.detach();    }    closesocket(server);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <stdint.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa;    SOCKET client;    struct sockaddr_in server_addr;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed.\n");        return 1;    }    client = socket(AF_INET, SOCK_STREAM, 0);    if (client == INVALID_SOCKET) {        printf("Socket creation failed.\n");        WSACleanup();        return 1;    }    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(4321);    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(client, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Connection to server failed.\n");        closesocket(client);        WSACleanup();        return 1;    }    char file_path[256];    printf("Enter the full path of the file: ");    fgets(file_path, sizeof(file_path), stdin);    file_path[strcspn(file_path, "\n")] = '\0';    send(client, file_path, strlen(file_path) + 1, 0);     int32_t net_size;    int bytes = recv(client, (char*)&net_size, sizeof(net_size), 0);    if (bytes <= 0) {        printf("Error receiving file size.\n");        closesocket(client);        WSACleanup();        return 1;    }    int32_t size = ntohl(net_size);    if (size == -1) {        printf("Server: file not found.\n");        closesocket(client);        WSACleanup();        return 0;    }    printf("Receiving file (%d bytes)...\n", size);    char* buffer = (char*)malloc(size);    if (!buffer) {        printf("Memory allocation failed.\n");        closesocket(client);        WSACleanup();        return 1;    }    int received = 0;    while (received < size) {        int r = recv(client, buffer + received, size - received, 0);        if (r <= 0) {            printf("Connection lost while receiving file.\n");            free(buffer);            closesocket(client);            WSACleanup();            return 1;        }        received += r;    }    char new_name[512];    snprintf(new_name, sizeof(new_name), "%s-copy", file_path);    FILE* f = fopen(new_name, "wb");    if (!f) {        printf("Cannot create output file.\n");        free(buffer);        closesocket(client);        WSACleanup();        return 1;    }    fwrite(buffer, 1, size, f);    fclose(f);    printf("File received and saved as '%s'.\n", new_name);    free(buffer);    closesocket(client);    WSACleanup();    return 0;}--udpclient.c#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <stdint.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa;    SOCKET client;    struct sockaddr_in server_addr;    int server_len = sizeof(server_addr);    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed.\n");        return 1;    }    client = socket(AF_INET, SOCK_DGRAM, 0);    if (client == INVALID_SOCKET) {        printf("Socket creation failed.\n");        WSACleanup();        return 1;    }    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(4321);    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    char file_path[256];    printf("Enter the full path of the file: ");    fgets(file_path, sizeof(file_path), stdin);    file_path[strcspn(file_path, "\n")] = '\0';    // Send request to server    sendto(client, file_path, strlen(file_path), 0,        (struct sockaddr*)&server_addr, server_len);    // Receive file size    int32_t net_size;    int bytes = recvfrom(client, (char*)&net_size, sizeof(net_size), 0,        (struct sockaddr*)&server_addr, &server_len);    if (bytes <= 0) {        printf("Failed to receive response.\n");        closesocket(client);        WSACleanup();        return 1;    }    int32_t size = ntohl(net_size);    if (size == -1) {        printf("Server: file not found.\n");        closesocket(client);        WSACleanup();        return 0;    }    printf("Receiving file (%d bytes)...\n", size);    // Receive file content    char* buffer = (char*)malloc(size);    if (!buffer) {        printf("Memory allocation failed.\n");        closesocket(client);        WSACleanup();        return 1;    }    int received = recvfrom(client, buffer, size, 0,        (struct sockaddr*)&server_addr, &server_len);    if (received <= 0) {        printf("Error receiving file content.\n");        free(buffer);        closesocket(client);        WSACleanup();        return 1;    }    char new_name[512];    snprintf(new_name, sizeof(new_name), "%s-copy", file_path);    FILE* f = fopen(new_name, "wb");    if (!f) {        printf("Cannot create output file.\n");        free(buffer);        closesocket(client);        WSACleanup();        return 1;    }    fwrite(buffer, 1, received, f);    fclose(f);    printf("File received and saved as '%s'.\n", new_name);    free(buffer);    closesocket(client);    WSACleanup();    return 0;}server.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdint.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    SOCKET server;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed.\n");        return 1;    }    server = socket(AF_INET, SOCK_DGRAM, 0);    if (server == INVALID_SOCKET) {        printf("Socket creation failed.\n");        WSACleanup();        return 1;    }    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("Bind failed.\n");        closesocket(server);        WSACleanup();        return 1;    }    printf("UDP Server listening on port %d...\n", PORT);    while (1) {        char file_path[256] = { 0 };        int bytes = recvfrom(server, file_path, sizeof(file_path) - 1, 0,            (struct sockaddr*)&client_addr, &client_len);        if (bytes <= 0)            continue;        file_path[bytes] = '\0';        printf("Client %s requested file: %s\n",            inet_ntoa(client_addr.sin_addr), file_path);        FILE* f = fopen(file_path, "rb");        if (!f) {            int32_t err = htonl(-1);            sendto(server, (char*)&err, sizeof(err), 0,                (struct sockaddr*)&client_addr, client_len);            printf("File not found.\n");            continue;        }        // Get file size        fseek(f, 0, SEEK_END);        long size = ftell(f);        fseek(f, 0, SEEK_SET);        // Read file content        char* buffer = (char*)malloc(size);        if (!buffer) {            fclose(f);            printf("Memory allocation failed.\n");            continue;        }        fread(buffer, 1, size, f);        fclose(f);        // Send size        int32_t net_size = htonl(size);        sendto(server, (char*)&net_size, sizeof(net_size), 0,            (struct sockaddr*)&client_addr, client_len);        // Send file content        sendto(server, buffer, size, 0,            (struct sockaddr*)&client_addr, client_len);        printf("Sent %ld bytes to client %s.\n", size,            inet_ntoa(client_addr.sin_addr));        free(buffer);    }    closesocket(server);    WSACleanup();    return 0;}3.   The server chooses a random float number <SRF>. Run multiple clients. Each client chooses a random float number <CRF> and send it to the server. When the server does not receive any incoming connection for at least 10 seconds it chooses the client that has guessed the best approximation (is closest) for its own number and sends it back the message “You have the best guess with an error of <SRV>-<CRF>”. It also sends to each other client the string “You lost !”. The server closes all connections after this.--tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#include <math.h>#include <thread>#include <mutex>#include <vector>#pragma comment(lib, "ws2_32.lib")#define PORT 4321#define MAX_CLIENTS 100struct Client {    SOCKET sock;    float guess;};std::vector<Client> clients;std::mutex mtx;  // Standard C++ mutexfloat server_number;void handle_client(SOCKET client_sock) {    float client_guess;    int bytes = recv(client_sock, (char*)&client_guess, sizeof(client_guess), 0);    if (bytes <= 0) {        closesocket(client_sock);        return;    }    {        std::lock_guard<std::mutex> lock(mtx);        clients.push_back({ client_sock, client_guess });    }    printf("Received guess %.2f from client %d\n", client_guess, (int)client_sock);}void choose_winner() {    std::lock_guard<std::mutex> lock(mtx);    if (clients.empty()) return;    float best_error = fabs(server_number - clients[0].guess);    int winner_index = 0;    for (int i = 1; i < (int)clients.size(); i++) {        float error = fabs(server_number - clients[i].guess);        if (error < best_error) {            best_error = error;            winner_index = i;        }    }    for (int i = 0; i < (int)clients.size(); i++) {        char msg[128];        if (i == winner_index) {            sprintf(msg, "✅ You won! Your guess %.2f was closest to %.2f (error %.2f)",                clients[i].guess, server_number, best_error);        }        else {            sprintf(msg, "❌ You lost! Your guess %.2f was off by %.2f",                clients[i].guess, fabs(server_number - clients[i].guess));        }        send(clients[i].sock, msg, (int)strlen(msg) + 1, 0);        closesocket(clients[i].sock);    }    printf("🏆 Winner: client %d, guess %.2f (server number %.2f)\n",        (int)clients[winner_index].sock,        clients[winner_index].guess,        server_number);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    srand((unsigned int)time(NULL));    server_number = ((float)rand() / RAND_MAX) * 100;    printf("🎲 Server number: %.2f\n", server_number);    SOCKET server_sock = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server_sock, 5);    printf("🟢 Server listening on port %d...\n", PORT);    fd_set readfds;    struct timeval timeout;    timeout.tv_sec = 10;    timeout.tv_usec = 0;    while (true) {        FD_ZERO(&readfds);        FD_SET(server_sock, &readfds);        int activity = select(0, &readfds, NULL, NULL, &timeout);        if (activity == 0) {            choose_winner();            break;        }        if (FD_ISSET(server_sock, &readfds)) {            struct sockaddr_in client_addr;            int addr_len = sizeof(client_addr);            SOCKET client = accept(server_sock, (struct sockaddr*)&client_addr, &addr_len);            if (client == INVALID_SOCKET)                continue;            printf("👤 Client connected from %s:%d\n",                inet_ntoa(client_addr.sin_addr),                ntohs(client_addr.sin_port));            std::thread t(handle_client, client);            t.detach();        }    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);    struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("Connection failed\n");        return 1;    }    srand((unsigned int)time(NULL));    float guess = ((float)rand() / RAND_MAX) * 100;    printf("My guess: %.2f\n", guess);    send(sock, (char*) & guess, sizeof(guess), 0);    char msg[100];    recv(sock, msg, sizeof(msg), 0);    printf("Server says: %s\n", msg);    closesocket(sock);    WSACleanup();    return 0;}--udpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#include <math.h>#include <vector>#include <thread>#include <mutex>#pragma comment(lib, "ws2_32.lib")#define PORT 4321#define TIMEOUT_SEC 10  // stop if no new guesses for 10stypedef struct {    struct sockaddr_in addr;    float guess;} Client;std::vector<Client> clients;std::mutex mtx;float server_number;SOCKET server_sock;time_t last_guess_time;void send_message(const char* msg, const struct sockaddr_in* addr) {    sendto(server_sock, msg, (int)strlen(msg) + 1, 0,        (struct sockaddr*)addr, sizeof(*addr));}// Handle each incoming guessvoid handle_guess(float guess, struct sockaddr_in client_addr) {    std::lock_guard<std::mutex> guard(mtx);    clients.push_back({ client_addr, guess });    last_guess_time = time(NULL);    printf("📨 Received guess %.2f from %s:%d\n",        guess,        inet_ntoa(client_addr.sin_addr),        ntohs(client_addr.sin_port));    // Acknowledge guess (but don't close client socket)    char ack[64];    sprintf(ack, "Guess %.2f received!", guess);    send_message(ack, &client_addr);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    server_sock = socket(AF_INET, SOCK_DGRAM, 0);    if (server_sock == INVALID_SOCKET) {        printf("❌ Socket creation failed\n");        WSACleanup();        return 1;    }    struct sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("❌ Bind failed\n");        closesocket(server_sock);        WSACleanup();        return 1;    }    srand((unsigned int)time(NULL));    server_number = ((float)rand() / RAND_MAX) * 100;    printf("🎮 Server started on port %d. Secret number: %.2f\n", PORT, server_number);    last_guess_time = time(NULL);    fd_set readfds;    struct timeval tv;    while (1) {        FD_ZERO(&readfds);        FD_SET(server_sock, &readfds);        tv.tv_sec = 1;  // check every second        tv.tv_usec = 0;        int activity = select(0, &readfds, NULL, NULL, &tv);        if (activity > 0) {            struct sockaddr_in client_addr;            int addr_len = sizeof(client_addr);            float guess;            int bytes = recvfrom(server_sock, (char*)&guess, sizeof(guess), 0,                (struct sockaddr*)&client_addr, &addr_len);            if (bytes == sizeof(guess)) {                std::thread(handle_guess, guess, client_addr).detach();            }        }        // Check for inactivity timeout        if (difftime(time(NULL), last_guess_time) >= TIMEOUT_SEC) {            printf("\n⏱ No guesses for %d seconds. Ending game.\n", TIMEOUT_SEC);            break;        }    }    // Determine winner    if (clients.empty()) {        printf("No guesses received.\n");    }    else {        float best_error = fabs(server_number - clients[0].guess);        int winner_index = 0;        for (int i = 1; i < clients.size(); i++) {            float err = fabs(server_number - clients[i].guess);            if (err < best_error) {                best_error = err;                winner_index = i;            }        }        printf("🏆 Winner: %.2f from %s:%d (error %.2f)\n",            clients[winner_index].guess,            inet_ntoa(clients[winner_index].addr.sin_addr),            ntohs(clients[winner_index].addr.sin_port),            best_error);        // Send final results to all clients        for (int i = 0; i < clients.size(); i++) {            char msg[128];            if (i == winner_index)                sprintf(msg, "🏆 You won! Your guess %.2f was closest to %.2f",                    clients[i].guess, server_number);            else                sprintf(msg, "❌ You lost! The number was %.2f", server_number);            send_message(msg, &clients[i].addr);        }    }    closesocket(server_sock);    WSACleanup();    printf("Server shut down.\n");    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#pragma comment(lib, "ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed\n");        return 1;    }    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) {        printf("Socket creation failed\n");        WSACleanup();        return 1;    }    struct sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    srand((unsigned int)time(NULL) ^ GetCurrentProcessId());    float guess = ((float)rand() / RAND_MAX) * 100;    printf("🎯 Sending my guess: %.2f\n", guess);    // Send the guess    sendto(sock, (char*)&guess, sizeof(guess), 0,        (struct sockaddr*)&server_addr, sizeof(server_addr));    // Optional: wait for server acknowledgment    fd_set readfds;    FD_ZERO(&readfds);    FD_SET(sock, &readfds);    struct timeval tv = { 5, 0 }; // wait max 5 sec for ack    int res = select(0, &readfds, NULL, NULL, &tv);    if (res > 0) {        char ack[256];        struct sockaddr_in from;        int fromlen = sizeof(from);        int bytes = recvfrom(sock, ack, sizeof(ack) - 1, 0,            (struct sockaddr*)&from, &fromlen);        if (bytes > 0) {            ack[bytes] = '\0';            printf("📨 Server acknowledgment: %s\n", ack);        }    }    else {        printf("⌛ No ack received\n");    }    // --- WAIT FOR FINAL RESULT ---    FD_ZERO(&readfds);    FD_SET(sock, &readfds);    tv.tv_sec = 15;  // wait max 15 sec for final message    tv.tv_usec = 0;    res = select(0, &readfds, NULL, NULL, &tv);    if (res > 0) {        char final_msg[256];        struct sockaddr_in from;        int fromlen = sizeof(from);        int bytes = recvfrom(sock, final_msg, sizeof(final_msg) - 1, 0,            (struct sockaddr*)&from, &fromlen);        if (bytes > 0) {            final_msg[bytes] = '\0';            printf("🏁 Server final message: %s\n", final_msg);        }    }    else {        printf("⌛ No final message received from server\n");    }    closesocket(sock);    WSACleanup();    return 0;}4.   The clients send an integer number N and an array of N float values. The server will merge sort the numbers received from all clients until it gets an empty array of floats (N=0). The server returns to each client the size of the merge-sorted array followed by the merge-sorted arrays of all floats from all clients.--tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <stdint.h>#include <thread>#include <mutex>#pragma comment(lib,"ws2_32.lib")#define PORT 4321#define MAX_CLIENTS 100float* all_numbers = nullptr;int total_numbers = 0;SOCKET client_sockets[MAX_CLIENTS];int client_count = 0;std::mutex mtx;bool stop_receiving = false;// Robust recv functionint recv_all(SOCKET sock, char* buffer, int len) {    int total = 0;    while (total < len) {        int r = recv(sock, buffer + total, len - total, 0);        if (r <= 0) return r;        total += r;    }    return total;}// Merge sort functionsvoid merge(float* arr, int left, int mid, int right) {    int n1 = mid - left + 1;    int n2 = right - mid;    float* L = (float*)malloc(n1 * sizeof(float));    float* R = (float*)malloc(n2 * sizeof(float));    for (int i = 0; i < n1; i++) L[i] = arr[left + i];    for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i];    int i = 0, j = 0, k = left;    while (i < n1 && j < n2) {        if (L[i] <= R[j]) arr[k++] = L[i++];        else arr[k++] = R[j++];    }    while (i < n1) arr[k++] = L[i++];    while (j < n2) arr[k++] = R[j++];    free(L); free(R);}void mergeSort(float* arr, int left, int right) {    if (left < right) {        int mid = left + (right - left) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}// Broadcast final array to all clientsvoid broadcast_final_array() {    if (total_numbers > 0)        mergeSort(all_numbers, 0, total_numbers - 1);    std::lock_guard<std::mutex> lock(mtx);    for (int i = 0; i < client_count; i++) {        int32_t size_net = htonl(total_numbers);        send(client_sockets[i], (char*)&size_net, sizeof(size_net), 0);        if (total_numbers > 0)            send(client_sockets[i], (char*)all_numbers, total_numbers * sizeof(float), 0);        closesocket(client_sockets[i]);    }}// Thread to handle each clientvoid handle_client(SOCKET client) {    int32_t n_net;    if (recv_all(client, (char*)&n_net, sizeof(n_net)) <= 0) {        closesocket(client);        return;    }    int32_t N = ntohl(n_net);    std::lock_guard<std::mutex> lock(mtx);    client_sockets[client_count++] = client;    if (N == 0) {        stop_receiving = true;        return; // Do NOT close socket yet    }    float* arr = (float*)malloc(N * sizeof(float));    if (recv_all(client, (char*)arr, N * sizeof(float)) <= 0) {        free(arr);        closesocket(client);        return;    }    all_numbers = (float*)realloc(all_numbers, (total_numbers + N) * sizeof(float));    for (int i = 0; i < N; i++) all_numbers[total_numbers + i] = arr[i];    total_numbers += N;    free(arr);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET server = socket(AF_INET, SOCK_STREAM, 0);    if (server == INVALID_SOCKET) { printf("Socket failed\n"); return 1; }    struct sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(server, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("Bind failed\n"); closesocket(server); return 1;    }    listen(server, MAX_CLIENTS);    printf("Server listening on port %d\n", PORT);    fd_set readfds;    struct timeval tv;    while (!stop_receiving) {        FD_ZERO(&readfds);        FD_SET(server, &readfds);        tv.tv_sec = 1;  // check every 1 second        tv.tv_usec = 0;        int ret = select(0, &readfds, NULL, NULL, &tv);        if (ret < 0) break;        if (FD_ISSET(server, &readfds)) {            struct sockaddr_in client_addr;            int len = sizeof(client_addr);            SOCKET client = accept(server, (struct sockaddr*)&client_addr, &len);            if (client != INVALID_SOCKET) {                printf("Client connected: %s:%d\n",                    inet_ntoa(client_addr.sin_addr),                    ntohs(client_addr.sin_port));                std::thread t(handle_client, client);                t.detach();            }        }    }    printf("N=0 received. Broadcasting final array to all clients...\n");    broadcast_final_array();    free(all_numbers);    closesocket(server);    WSACleanup();    printf("Server terminated.\n");    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <stdint.h>#pragma comment(lib,"ws2_32.lib")#define PORT 4321// Robust recv function to receive all bytesint recv_all(SOCKET sock, char* buffer, int len) {    int total = 0;    while (total < len) {        int r = recv(sock, buffer + total, len - total, 0);        if (r <= 0) return r;        total += r;    }    return total;}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) { printf("Socket failed\n"); return 1; }    struct sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = inet_addr("192.168.1.131"); // change if needed    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("Connect failed, WSAGetLastError = %d\n", WSAGetLastError());        return 1;    }    int N;    printf("Enter number of floats to send (0 to stop): ");    scanf("%d", &N);    int32_t N_net = htonl(N);    send(sock, (char*)&N_net, sizeof(N_net), 0);    if (N > 0) {        float* arr = (float*)malloc(N * sizeof(float));        for (int i = 0; i < N; i++) {            printf("Enter float #%d: ", i + 1);            scanf("%f", &arr[i]);        }        send(sock, (char*)arr, N * sizeof(float), 0);        free(arr);    }    printf("Waiting for final merge-sorted array from server...\n");    // Receive array size    int32_t size_net;    if (recv_all(sock, (char*)&size_net, sizeof(size_net)) <= 0) {        printf("Failed to receive array size.\n");        closesocket(sock); WSACleanup(); return 1;    }    int32_t size = ntohl(size_net);    if (size <= 0) {        printf("Server sent empty array.\n");        closesocket(sock); WSACleanup(); return 0;    }    float* sorted = (float*)malloc(size * sizeof(float));    if (recv_all(sock, (char*)sorted, size * sizeof(float)) <= 0) {        printf("Failed to receive array data.\n");        free(sorted); closesocket(sock); WSACleanup(); return 1;    }    printf("Merge-sorted array from server:\n");    for (int i = 0; i < size; i++) printf("%.2f ", sorted[i]);    printf("\n");    free(sorted);    closesocket(sock);    WSACleanup();    return 0;}--udpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <stdint.h>#include <time.h>#include <mutex>#pragma comment(lib,"ws2_32.lib")#define PORT 4321#define MAX_CLIENTS 100#define TIMEOUT_SECONDS 10float* all_numbers = nullptr;int total_numbers = 0;struct ClientInfo {    sockaddr_in addr;    int addr_len;};ClientInfo client_infos[MAX_CLIENTS];int client_count = 0;std::mutex mtx;bool stop_receiving = false;time_t last_activity;// Merge sort functionsvoid merge(float* arr, int left, int mid, int right) {    int n1 = mid - left + 1;    int n2 = right - mid;    float* L = (float*)malloc(n1 * sizeof(float));    float* R = (float*)malloc(n2 * sizeof(float));    for (int i = 0; i < n1; i++) L[i] = arr[left + i];    for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i];    int i = 0, j = 0, k = left;    while (i < n1 && j < n2) {        if (L[i] <= R[j]) arr[k++] = L[i++];        else arr[k++] = R[j++];    }    while (i < n1) arr[k++] = L[i++];    while (j < n2) arr[k++] = R[j++];    free(L); free(R);}void mergeSort(float* arr, int left, int right) {    if (left < right) {        int mid = left + (right - left) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}// Broadcast final array to all clientsvoid broadcast_final_array(SOCKET sock) {    if (total_numbers > 0)        mergeSort(all_numbers, 0, total_numbers - 1);    std::lock_guard<std::mutex> lock(mtx);    for (int i = 0; i < client_count; i++) {        int32_t size_net = htonl(total_numbers);        sendto(sock, (char*)&size_net, sizeof(size_net), 0,            (sockaddr*)&client_infos[i].addr, client_infos[i].addr_len);        if (total_numbers > 0)            sendto(sock, (char*)all_numbers, total_numbers * sizeof(float), 0,                (sockaddr*)&client_infos[i].addr, client_infos[i].addr_len);    }}void handle_packet(char* buffer, int len, sockaddr_in addr, int addr_len) {    if (len < sizeof(int32_t)) return;    int32_t N;    memcpy(&N, buffer, sizeof(int32_t));    N = ntohl(N);    std::lock_guard<std::mutex> lock(mtx);    // Add client if new    bool already_added = false;    for (int i = 0; i < client_count; i++) {        if (memcmp(&client_infos[i].addr, &addr, sizeof(addr)) == 0) {            already_added = true;            break;        }    }    if (!already_added) {        client_infos[client_count].addr = addr;        client_infos[client_count].addr_len = addr_len;        client_count++;    }    last_activity = time(NULL); // update last activity    if (N == 0) {        stop_receiving = true;        return;    }    if (len < sizeof(int32_t) + N * sizeof(float)) return;    float* arr = (float*)malloc(N * sizeof(float));    memcpy(arr, buffer + sizeof(int32_t), N * sizeof(float));    all_numbers = (float*)realloc(all_numbers, (total_numbers + N) * sizeof(float));    for (int i = 0; i < N; i++) all_numbers[total_numbers + i] = arr[i];    total_numbers += N;    free(arr);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET server = socket(AF_INET, SOCK_DGRAM, 0);    if (server == INVALID_SOCKET) { printf("Socket failed\n"); return 1; }    sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(server, (sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("Bind failed\n"); closesocket(server); return 1;    }    printf("UDP Server listening on port %d\n", PORT);    char buffer[4096];    sockaddr_in client_addr;    int client_addr_len = sizeof(client_addr);    last_activity = time(NULL);    while (!stop_receiving) {        fd_set readfds;        FD_ZERO(&readfds);        FD_SET(server, &readfds);        timeval tv;        tv.tv_sec = 1; // check every 1 second        tv.tv_usec = 0;        int ret = select(0, &readfds, NULL, NULL, &tv);        if (ret > 0 && FD_ISSET(server, &readfds)) {            int bytes = recvfrom(server, buffer, sizeof(buffer), 0,                (sockaddr*)&client_addr, &client_addr_len);            if (bytes > 0) {                handle_packet(buffer, bytes, client_addr, client_addr_len);            }        }        // Check timeout        if (difftime(time(NULL), last_activity) >= TIMEOUT_SECONDS && client_count > 0) {            printf("Timeout reached. Broadcasting final array...\n");            stop_receiving = true;        }    }    broadcast_final_array(server);    free(all_numbers);    closesocket(server);    WSACleanup();    printf("Server terminated.\n");    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <stdint.h>#pragma comment(lib,"ws2_32.lib")#define PORT 4321int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) { printf("Socket failed\n"); return 1; }    sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(PORT);    server_addr.sin_addr.s_addr = inet_addr("10.220.30.23"); // server IP    int N;    printf("Enter number of floats to send (0 to stop): ");    scanf("%d", &N);    char* buffer = (char*)malloc(sizeof(int32_t) + N * sizeof(float));    int32_t N_net = htonl(N);    memcpy(buffer, &N_net, sizeof(int32_t));    for (int i = 0; i < N; i++) {        float x;        printf("Enter float #%d: ", i + 1);        scanf("%f", &x);        memcpy(buffer + sizeof(int32_t) + i * sizeof(float), &x, sizeof(float));    }    sendto(sock, buffer, sizeof(int32_t) + N * sizeof(float), 0,        (sockaddr*)&server_addr, sizeof(server_addr));    free(buffer);    printf("Waiting for final merge-sorted array from server...\n");    // Receive array size    int32_t size_net;    sockaddr_in from_addr;    int from_len = sizeof(from_addr);    int ret = recvfrom(sock, (char*)&size_net, sizeof(size_net), 0,        (sockaddr*)&from_addr, &from_len);    if (ret <= 0) {        printf("Failed to receive array size.\n");        closesocket(sock);        return 1;    }    int32_t size = ntohl(size_net);    if (size <= 0) {        printf("Server sent empty array.\n");        closesocket(sock);        return 0;    }    float* arr = (float*)malloc(size * sizeof(float));    ret = recvfrom(sock, (char*)arr, size * sizeof(float), 0,        (sockaddr*)&from_addr, &from_len);    if (ret <= 0) {        printf("Failed to receive array data.\n");        free(arr);        closesocket(sock);        return 1;    }    printf("Merge-sorted array from server:\n");    for (int i = 0; i < size; i++) printf("%.2f ", arr[i]);    printf("\n");    free(arr);    closesocket(sock);    return 0;}5.   The client sends a domain name taken from the command line (Ex: www.google.com) to the server. The server opens a TCP connection to the IP address corresponding to the received domain name on port 80 (called HTTP-Srv). It sends on the TCP connection the string: “GET / HTTP/1.0\n\n” and relays the answer back to the client. When HTTP-Srv closes connection to the server, the server closes the connection to the client at its turn.--tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define MAX_BUFFER 4096void handle_client(int client) {    char domain[256];    int n;    // Receive domain name from client    n = recv(client, domain, sizeof(domain) - 1, 0);    if (n <= 0) { closesocket(client); return; }    domain[n] = '\0';    printf("Client requested domain: %s\n", domain);    // Resolve domain to IP    struct hostent* he = gethostbyname(domain);    if (!he) {        printf("Cannot resolve domain %s\n", domain);        closesocket(client);        return;    }    char* ip = inet_ntoa(*(struct in_addr*)he->h_addr_list[0]);    printf("Resolved IP: %s\n", ip);    // Connect to HTTP server    SOCKET http_sock = socket(AF_INET, SOCK_STREAM, 0);    if (http_sock == INVALID_SOCKET) { closesocket(client); return; }    struct sockaddr_in http_addr;    http_addr.sin_family = AF_INET;    http_addr.sin_port = htons(80);    http_addr.sin_addr.s_addr = inet_addr(ip);    if (connect(http_sock, (struct sockaddr*)&http_addr, sizeof(http_addr)) == SOCKET_ERROR) {        printf("Cannot connect to HTTP server\n");        closesocket(http_sock);        closesocket(client);        return;    }    // Send HTTP GET request    char request[] = "GET / HTTP/1.0\r\n\r\n";    send(http_sock, request, (int)strlen(request), 0);    // Relay HTTP response back to client    char buffer[MAX_BUFFER];    int received;    while ((received = recv(http_sock, buffer, MAX_BUFFER, 0)) > 0) {        send(client, buffer, received, 0);    }    printf("Finished relaying HTTP response for %s\n", domain);    closesocket(http_sock);    closesocket(client);    return;}int main() {    WSADATA wsa;    SOCKET server_sock;    struct sockaddr_in server_addr, client_addr;    int client_len = sizeof(client_addr);    WSAStartup(MAKEWORD(2, 2), &wsa);    server_sock = socket(AF_INET, SOCK_STREAM, 0);    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));    listen(server_sock, 5);    printf("Server listening on port %d\n", SERVER_PORT);    while (1) {        SOCKET client = accept(server_sock, (struct sockaddr*)&client_addr, &client_len);        printf("Client connected: %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));		std::thread(handle_client, client).detach();    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define MAX_BUFFER 4096int main(int argc, char* argv[]) {    WSADATA wsa;    SOCKET sock;    struct sockaddr_in server;    char domain[256];    char buffer[MAX_BUFFER];    int n;    // Initialize Winsock    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed!\n");        return 1;    }    // Get domain name from command-line argument or prompt    if (argc >= 2) {        strncpy(domain, argv[1], 255);        domain[255] = '\0'; // ensure null-terminated    }    else {        printf("Enter domain: ");        if (scanf("%255s", domain) != 1) {            printf("Invalid input!\n");            WSACleanup();            return 1;        }    }    // Create socket    sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        printf("Socket creation failed!\n");        WSACleanup();        return 1;    }    server.sin_family = AF_INET;    server.sin_port = htons(SERVER_PORT);    server.sin_addr.s_addr = inet_addr(SERVER_IP);    // Connect to proxy server    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {        printf("Cannot connect to server!\n");        closesocket(sock);        WSACleanup();        return 1;    }    // Send domain name    if (send(sock, domain, (int)strlen(domain), 0) == SOCKET_ERROR) {        printf("Failed to send domain!\n");        closesocket(sock);        WSACleanup();        return 1;    }    printf("\nConnected to server. Receiving HTTP response...\n\n");    // Receive HTTP response and print    while ((n = recv(sock, buffer, MAX_BUFFER, 0)) > 0) {        fwrite(buffer, 1, n, stdout);    }    if (n == SOCKET_ERROR) {        printf("\nError receiving data from server!\n");    }    else {        printf("\n\nConnection closed by server.\n");    }    closesocket(sock);    WSACleanup();    return 0;}--udpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define MAX_BUFFER 4096void handle_client(SOCKET server_sock, sockaddr_in client_addr, int client_addr_len, char* domain, int domain_len) {    domain[domain_len] = '\0';    printf("Client requested domain: %s\n", domain);    // Resolve domain    struct hostent* he = gethostbyname(domain);    if (!he) {        printf("Cannot resolve domain %s\n", domain);        char msg[] = "Cannot resolve domain\n";        sendto(server_sock, msg, (int)strlen(msg), 0, (sockaddr*)&client_addr, client_addr_len);        return;    }    char* ip = inet_ntoa(*(struct in_addr*)he->h_addr_list[0]);    printf("Resolved IP: %s\n", ip);    // Connect to HTTP server    SOCKET http_sock = socket(AF_INET, SOCK_STREAM, 0);    if (http_sock == INVALID_SOCKET) return;    struct sockaddr_in http_addr = {};    http_addr.sin_family = AF_INET;    http_addr.sin_port = htons(80);    http_addr.sin_addr.s_addr = inet_addr(ip);    if (connect(http_sock, (struct sockaddr*)&http_addr, sizeof(http_addr)) == SOCKET_ERROR) {        printf("Cannot connect to HTTP server\n");        closesocket(http_sock);        char msg[] = "Cannot connect to HTTP server\n";        sendto(server_sock, msg, (int)strlen(msg), 0, (sockaddr*)&client_addr, client_addr_len);        return;    }    // Send HTTP GET    char request[] = "GET / HTTP/1.0\r\n\r\n";    send(http_sock, request, (int)strlen(request), 0);    // Relay HTTP response back via UDP    char buffer[MAX_BUFFER];    int received;    while ((received = recv(http_sock, buffer, MAX_BUFFER, 0)) > 0) {        sendto(server_sock, buffer, received, 0, (sockaddr*)&client_addr, client_addr_len);    }    printf("Finished relaying HTTP response for %s\n", domain);    closesocket(http_sock);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET server_sock = socket(AF_INET, SOCK_DGRAM, 0);    if (server_sock == INVALID_SOCKET) { printf("Socket failed\n"); return 1; }    sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(server_sock, (sockaddr*)&server_addr, sizeof(server_addr)) < 0) {        printf("Bind failed\n"); closesocket(server_sock); return 1;    }    printf("UDP Server listening on port %d\n", SERVER_PORT);    while (1) {        char buffer[MAX_BUFFER];        sockaddr_in client_addr;        int client_len = sizeof(client_addr);        int n = recvfrom(server_sock, buffer, MAX_BUFFER - 1, 0, (sockaddr*)&client_addr, &client_len);        if (n > 0) {            std::thread(handle_client, server_sock, client_addr, client_len, buffer, n).detach();        }    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define MAX_BUFFER 4096int main(int argc, char* argv[]) {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) { printf("Socket failed\n"); return 1; }    sockaddr_in server_addr = {};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);    char domain[256];    if (argc >= 2) {        strncpy(domain, argv[1], 255);        domain[255] = '\0';    }    else {        printf("Enter domain: ");        scanf("%255s", domain);    }    sendto(sock, domain, (int)strlen(domain), 0, (sockaddr*)&server_addr, sizeof(server_addr));    printf("Receiving HTTP response...\n");    char buffer[MAX_BUFFER];    sockaddr_in from_addr;    int from_len = sizeof(from_addr);    int n;    while ((n = recvfrom(sock, buffer, MAX_BUFFER, 0, (sockaddr*)&from_addr, &from_len)) > 0) {        fwrite(buffer, 1, n, stdout);    }    printf("\n\nFinished receiving data.\n");    closesocket(sock);    WSACleanup();    return 0;}6.   The server chooses a random integer number. Each client generates a random integer number and send it to the server. The server answers with the message “larger” if the client has sent a smaller number than the server’s choice, or with message “smaller” if the client has send a larger number than the server’s choice. Each client continues generating a different random number (larger or smaller than the previous) according to the server’s indication. When a client guesses the server choice – the server sends back to the winner the message “You win – within x tries”. It also sends back to all other clients the message “You lost – after y retries!” (x and y are the number of tries of each respective client). The server closes all connections upon a win and it chooses a different random integer for the next game (set of clients)--tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#include <thread>#include <mutex>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define MAX_CLIENTS 10#define BUFFER_SIZE 256// ---------------- GLOBALS ----------------SOCKET clients[MAX_CLIENTS];int tries[MAX_CLIENTS];int client_count = 0;int secret_number;bool game_over = false;std::mutex mtx;// ---------------- FUNCTIONS ----------------void init_winsock() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed!\n");        exit(1);    }}SOCKET create_server_socket() {    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Failed to create server socket!\n");        exit(1);    }    struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed!\n");        closesocket(s);        exit(1);    }    if (listen(s, MAX_CLIENTS) == SOCKET_ERROR) {        printf("Listen failed!\n");        closesocket(s);        exit(1);    }    return s;}void broadcast_message(const char* msg, int exclude_idx = -1) {    std::lock_guard<std::mutex> lock(mtx);    for (int i = 0; i < client_count; i++) {        if (i != exclude_idx) {            send(clients[i], msg, (int)strlen(msg), 0);        }    }}void handle_client(int idx) {    SOCKET client = clients[idx];    int n;    int guess;    tries[idx] = 0;    while (!game_over) {        n = recv(client, (char*)&guess, sizeof(int), 0);        if (n <= 0)            break;        guess = ntohl(guess);        tries[idx]++;        std::lock_guard<std::mutex> lock(mtx);        if (game_over)            break;        char msg[BUFFER_SIZE];        if (guess < secret_number) {            strcpy(msg, "larger");        }        else if (guess > secret_number) {            strcpy(msg, "smaller");        }        else {            sprintf(msg, "You win - within %d tries", tries[idx]);            send(client, msg, (int)strlen(msg), 0);            // Notify other clients they lost            for (int i = 0; i < client_count; i++) {                if (i != idx) {                    sprintf(msg, "You lost - after %d tries!", tries[i]);                    send(clients[i], msg, (int)strlen(msg), 0);                }            }            game_over = true;            break;        }        send(client, msg, (int)strlen(msg), 0);    }    closesocket(client);}void start_game(SOCKET server_sock) {    secret_number = rand() % 100 + 1;    game_over = false;    client_count = 0;    printf("\nNew game! Secret number: %d\n", secret_number);    std::thread threads[MAX_CLIENTS];    while (!game_over && client_count < MAX_CLIENTS) {        struct sockaddr_in client_addr;        int client_len = sizeof(client_addr);        SOCKET client = accept(server_sock, (struct sockaddr*)&client_addr, &client_len);        if (client == INVALID_SOCKET)            continue;        std::lock_guard<std::mutex> lock(mtx);        clients[client_count] = client;        int* idx = (int*)malloc(sizeof(int));        *idx = client_count;        client_count++;        threads[*idx] = std::thread([idx]() {            handle_client(*idx);            free(idx);            });        threads[*idx].detach();        printf("Client connected: %s:%d\n",            inet_ntoa(client_addr.sin_addr),            ntohs(client_addr.sin_port));    }    // Wait until the game is over    while (!game_over)        Sleep(100);    std::lock_guard<std::mutex> lock(mtx);    for (int i = 0; i < client_count; i++) {        closesocket(clients[i]);    }}// ---------------- MAIN ----------------int main() {    srand((unsigned int)time(NULL));    init_winsock();    SOCKET server_sock = create_server_socket();    printf("Server listening on port %d\n", SERVER_PORT);    while (1) {        start_game(server_sock);        printf("Game ended. Ready for next game!\n");    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define BUFFER_SIZE 256SOCKET connect_to_server() {    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);    if (sock == INVALID_SOCKET) {        printf("Failed to create socket!\n");        exit(1);    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(SERVER_PORT);    server.sin_addr.s_addr = inet_addr(SERVER_IP);    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {        printf("Cannot connect to server!\n");        closesocket(sock);        exit(1);    }    return sock;}int make_guess(int lower, int upper) {    return lower + rand() % (upper - lower + 1);}void play_game(SOCKET sock) {    int lower = 1, upper = 100;    int guess;    char buffer[BUFFER_SIZE];    int n;    srand((unsigned int)time(NULL));    printf("Connected to server. Starting guesses...\n");    while (1) {        guess = make_guess(lower, upper);        printf("Sending guess: %d\n", guess);        int net_guess = htonl(guess);        send(sock, (char*)&net_guess, sizeof(int), 0);        n = recv(sock, buffer, BUFFER_SIZE, 0);        if (n <= 0) break;        buffer[n] = '\0';        printf("Server: %s\n", buffer);        if (strstr(buffer, "win") || strstr(buffer, "lost")) break;        if (strcmp(buffer, "larger") == 0) lower = guess + 1;        else if (strcmp(buffer, "smaller") == 0) upper = guess - 1;        Sleep(500);    }    printf("Game ended.\n");}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = connect_to_server();    play_game(sock);    closesocket(sock);    WSACleanup();    return 0;}--udpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#include <thread>#include <mutex>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define MAX_CLIENTS 10#define BUFFER_SIZE 256// ---------------- GLOBALS ----------------struct sockaddr_in client_addrs[MAX_CLIENTS];int client_count = 0;int tries[MAX_CLIENTS];int secret_number;bool game_over = false;std::mutex mtx;SOCKET server_sock;// ---------------- FUNCTIONS ----------------void init_winsock() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed!\n");        exit(1);    }}SOCKET create_server_socket() {    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    if (s == INVALID_SOCKET) {        printf("Failed to create UDP socket!\n");        exit(1);    }    struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed!\n");        closesocket(s);        exit(1);    }    printf("UDP Server listening on port %d\n", SERVER_PORT);    return s;}int find_or_add_client(struct sockaddr_in client_addr) {    std::lock_guard<std::mutex> lock(mtx);    for (int i = 0; i < client_count; i++) {        if (client_addrs[i].sin_addr.s_addr == client_addr.sin_addr.s_addr &&            client_addrs[i].sin_port == client_addr.sin_port) {            return i;        }    }    if (client_count < MAX_CLIENTS) {        client_addrs[client_count] = client_addr;        tries[client_count] = 0;        return client_count++;    }    return -1;}void handle_guess(int idx, int guess) {    std::lock_guard<std::mutex> lock(mtx);    if (game_over) return;    tries[idx]++;    char msg[BUFFER_SIZE];    struct sockaddr_in client_addr = client_addrs[idx];    int addr_len = sizeof(client_addr);    if (guess < secret_number) {        strcpy(msg, "larger");        sendto(server_sock, msg, (int)strlen(msg), 0, (sockaddr*)&client_addr, addr_len);    }    else if (guess > secret_number) {        strcpy(msg, "smaller");        sendto(server_sock, msg, (int)strlen(msg), 0, (sockaddr*)&client_addr, addr_len);    }    else {        sprintf(msg, "You win - within %d tries", tries[idx]);        sendto(server_sock, msg, (int)strlen(msg), 0, (sockaddr*)&client_addr, addr_len);        for (int i = 0; i < client_count; i++) {            if (i != idx) {                sprintf(msg, "You lost - after %d tries!", tries[i]);                sendto(server_sock, msg, (int)strlen(msg), 0,                    (sockaddr*)&client_addrs[i], sizeof(client_addrs[i]));            }        }        game_over = true;    }}void start_game() {    secret_number = rand() % 100 + 1;    client_count = 0;    game_over = false;    printf("\nNew game started! Secret number: %d\n", secret_number);    while (!game_over) {        struct sockaddr_in client_addr;        int addr_len = sizeof(client_addr);        int guess;        int n = recvfrom(server_sock, (char*)&guess, sizeof(int), 0,            (sockaddr*)&client_addr, &addr_len);        if (n <= 0) continue;        guess = ntohl(guess);        int idx = find_or_add_client(client_addr);        if (idx >= 0) {            handle_guess(idx, guess);        }    }}// ---------------- MAIN ----------------int main() {    srand((unsigned int)time(NULL));    init_winsock();    server_sock = create_server_socket();    while (1) {        start_game();        printf("Game ended. Waiting for next round...\n");    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define BUFFER_SIZE 256SOCKET create_client_socket(struct sockaddr_in* server_addr) {    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) {        printf("Failed to create UDP socket!\n");        exit(1);    }    server_addr->sin_family = AF_INET;    server_addr->sin_port = htons(SERVER_PORT);    server_addr->sin_addr.s_addr = inet_addr(SERVER_IP);    return sock;}int make_guess(int lower, int upper) {    return lower + rand() % (upper - lower + 1);}void play_game(SOCKET sock, struct sockaddr_in server_addr) {    int lower = 1, upper = 100;    int guess;    char buffer[BUFFER_SIZE];    int n;    int addr_len = sizeof(server_addr);    srand((unsigned int)time(NULL));    printf("Connected to UDP server. Starting guesses...\n");    while (1) {        guess = make_guess(lower, upper);        printf("Sending guess: %d\n", guess);        int net_guess = htonl(guess);        sendto(sock, (char*)&net_guess, sizeof(int), 0,            (sockaddr*)&server_addr, addr_len);        n = recvfrom(sock, buffer, BUFFER_SIZE, 0, NULL, NULL);        if (n <= 0) break;        buffer[n] = '\0';        printf("Server: %s\n", buffer);        if (strstr(buffer, "win") || strstr(buffer, "lost")) break;        if (strcmp(buffer, "larger") == 0) lower = guess + 1;        else if (strcmp(buffer, "smaller") == 0) upper = guess - 1;        Sleep(500);    }    printf("Game ended.\n");}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    struct sockaddr_in server_addr;    SOCKET sock = create_client_socket(&server_addr);    play_game(sock, server_addr);    closesocket(sock);    WSACleanup();    return 0;}7.   The client reads a username and a password from the standard input. It sends the username to the server. The server uses the getpwent system call repeatedly to find the password information about the username. If the entry for the username is found, the password field from the struct passwd is returned to the client. The client recovers the salt of the password and checks the input password with the received encrypted version using the crypt system call. If there is no user username, the server returns back to the client the empty string and closes the connection.--tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <thread>#include <mutex>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define BUFFER_SIZE 256std::mutex mtx;void init_winsock() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed!\n");        exit(1);    }}SOCKET create_server_socket() {    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Socket creation failed!\n");        exit(1);    }    struct sockaddr_in server_addr;    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed!\n");        closesocket(s);        exit(1);    }    listen(s, 5);    printf("Server listening on port %d...\n", SERVER_PORT);    return s;}// Simulated "getpwent" using a fileint get_user_password(const char* username, char* password_out) {    FILE* f = fopen("users.txt", "r");    if (!f) {        printf("Could not open users.txt\n");        return 0;    }    char line[BUFFER_SIZE];    while (fgets(line, sizeof(line), f)) {        char file_user[BUFFER_SIZE], file_pass[BUFFER_SIZE];        if (sscanf(line, "%[^:]:%s", file_user, file_pass) == 2) {            if (strcmp(file_user, username) == 0) {                strcpy(password_out, file_pass);                fclose(f);                return 1;            }        }    }    fclose(f);    return 0;}void handle_client(SOCKET client) {    char username[BUFFER_SIZE] = { 0 };    int n = recv(client, username, BUFFER_SIZE, 0);    if (n <= 0) {        closesocket(client);        return;    }    username[n] = '\0';    printf("Received username: %s\n", username);    char password[BUFFER_SIZE] = "";    if (get_user_password(username, password)) {        send(client, password, (int)strlen(password), 0);        printf("Sent password for %s\n", username);    }    else {        send(client, "", 0, 0);  // Empty string        printf("No such user: %s\n", username);    }    closesocket(client);}int main() {    init_winsock();    SOCKET server_sock = create_server_socket();    while (1) {        struct sockaddr_in client_addr;        int len = sizeof(client_addr);        SOCKET client = accept(server_sock, (struct sockaddr*)&client_addr, &len);        if (client == INVALID_SOCKET) continue;        printf("Client connected: %s:%d\n",            inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));        std::thread(handle_client, client).detach();    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define BUFFER_SIZE 256SOCKET connect_to_server() {    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    if (s == INVALID_SOCKET) {        printf("Socket creation failed!\n");        exit(1);    }    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(SERVER_PORT);    server.sin_addr.s_addr = inet_addr(SERVER_IP);    if (connect(s, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {        printf("Cannot connect to server!\n");        closesocket(s);        exit(1);    }    return s;}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = connect_to_server();    char username[BUFFER_SIZE], password[BUFFER_SIZE], server_pass[BUFFER_SIZE];    printf("Enter username: ");    fgets(username, BUFFER_SIZE, stdin);    username[strcspn(username, "\n")] = '\0'; // remove newline    printf("Enter password: ");    fgets(password, BUFFER_SIZE, stdin);    password[strcspn(password, "\n")] = '\0';    send(sock, username, (int)strlen(username), 0);    int n = recv(sock, server_pass, BUFFER_SIZE, 0);    if (n <= 0) {        printf("Server closed the connection or user not found.\n");        closesocket(sock);        WSACleanup();        return 0;    }    server_pass[n] = '\0';    if (strlen(server_pass) == 0) {        printf("No such user found on server.\n");    }    else if (strcmp(password, server_pass) == 0) {        printf("Login successful!\n");    }    else {        printf("Incorrect password.\n");    }    closesocket(sock);    WSACleanup();    return 0;}--udpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <thread>#include <mutex>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define BUFFER_SIZE 256std::mutex mtx;// Function to find password for a given usernamechar* get_password_for_user(const char* username) {    static char password[BUFFER_SIZE];    password[0] = '\0';  // clear buffer    FILE* f = fopen("users.txt", "r");    if (!f) {        printf("Error: Could not open users.txt!\n");        return password;    }    char line[BUFFER_SIZE];    while (fgets(line, sizeof(line), f)) {        char file_user[BUFFER_SIZE], file_pass[BUFFER_SIZE];        if (sscanf(line, "%[^:]:%s", file_user, file_pass) == 2) {            if (strcmp(file_user, username) == 0) {                strcpy(password, file_pass);                break;            }        }    }    fclose(f);    return password;}void handle_request(SOCKET sock, sockaddr_in client_addr, char* received) {    char username[BUFFER_SIZE], password[BUFFER_SIZE];    sscanf(received, "%s %s", username, password);    printf("Request from %s:%d -> username: %s\n",        inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), username);    char* stored_pass = get_password_for_user(username);    char response[BUFFER_SIZE];    if (strlen(stored_pass) == 0) {        strcpy(response, "NO_USER");    }    else if (strcmp(stored_pass, password) == 0) {        strcpy(response, "OK");    }    else {        strcpy(response, "WRONG_PASSWORD");    }    sendto(sock, response, (int)strlen(response), 0,        (sockaddr*)&client_addr, sizeof(client_addr));}int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed!\n");        return 1;    }    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) {        printf("Socket creation failed!\n");        WSACleanup();        return 1;    }    sockaddr_in server_addr{};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(sock, (sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed!\n");        closesocket(sock);        WSACleanup();        return 1;    }    printf("UDP Server listening on port %d...\n", SERVER_PORT);    char buffer[BUFFER_SIZE];    sockaddr_in client_addr{};    int client_len = sizeof(client_addr);    while (1) {        int ret = recvfrom(sock, buffer, sizeof(buffer) - 1, 0,            (sockaddr*)&client_addr, &client_len);        if (ret <= 0) continue;        buffer[ret] = '\0';        std::thread(handle_request, sock, client_addr, _strdup(buffer)).detach();    }    closesocket(sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define BUFFER_SIZE 256int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed!\n");        return 1;    }    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) {        printf("Socket creation failed!\n");        WSACleanup();        return 1;    }    sockaddr_in server_addr{};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);    char username[BUFFER_SIZE], password[BUFFER_SIZE];    printf("Enter username: ");    scanf("%s", username);    printf("Enter password: ");    scanf("%s", password);    char message[BUFFER_SIZE];    sprintf(message, "%s %s", username, password);    sendto(sock, message, (int)strlen(message), 0,        (sockaddr*)&server_addr, sizeof(server_addr));    char response[BUFFER_SIZE];    sockaddr_in from_addr{};    int from_len = sizeof(from_addr);    int ret = recvfrom(sock, response, sizeof(response) - 1, 0,        (sockaddr*)&from_addr, &from_len);    if (ret > 0) {        response[ret] = '\0';        printf("Server response: %s\n", response);    }    closesocket(sock);    WSACleanup();    return 0;}8.   Build a server that facilitates a peer-to-peer (P2P) file-sharing network. The server maintains a directory of files and connected peers. Clients can request files, and the server connects them to peers that have the requested files. Data transfers happens over TCP.--tcpserver.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#include <mutex>#include <cstring>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define MAX_FILES 100#define MAX_FILENAME 128#define BUFFER_SIZE 1024struct FileEntry {    char filename[MAX_FILENAME];    char peer_ip[32];    int peer_port;};FileEntry* directory;int file_count = 0;std::mutex mtx;void trim(char* str) {    int len = (int)strlen(str);    while (len > 0 && (str[len - 1] == '\n' || str[len - 1] == '\r')) {        str[len - 1] = '\0';        len--;    }}// Remove file from a peer after transfervoid remove_file_from_peer(const char* filename, const char* ip, int port) {    std::lock_guard<std::mutex> lock(mtx);    for (int i = 0; i < file_count; i++) {        if (strcmp(directory[i].filename, filename) == 0 &&            strcmp(directory[i].peer_ip, ip) == 0 &&            directory[i].peer_port == port) {            // Shift all entries left            for (int j = i; j < file_count - 1; j++)                directory[j] = directory[j + 1];            file_count--;            break;        }    }}void handle_client(SOCKET client) {    char buffer[BUFFER_SIZE];    struct sockaddr_in addr;    int len = sizeof(addr);    getpeername(client, (struct sockaddr*)&addr, &len);    int n = recv(client, buffer, BUFFER_SIZE - 1, 0);    if (n <= 0) { closesocket(client); return; }    buffer[n] = '\0';    trim(buffer);    printf("[Server] Received: %s\n", buffer);    if (strncmp(buffer, "REGISTER", 8) == 0) {        int port;        char filelist[BUFFER_SIZE];        sscanf(buffer + 8, "%d %[^\n]", &port, filelist);        char* token = strtok(filelist, ",");        std::lock_guard<std::mutex> lock(mtx);        while (token != NULL && file_count < MAX_FILES) {            trim(token);            strcpy(directory[file_count].filename, token);            strcpy(directory[file_count].peer_ip, inet_ntoa(addr.sin_addr));            directory[file_count].peer_port = port;            file_count++;            token = strtok(NULL, ",");        }        const char* msg = "Files registered.\n";        send(client, msg, (int)strlen(msg), 0);    }    else if (strncmp(buffer, "REQUEST", 7) == 0) {        char filename[MAX_FILENAME];        sscanf(buffer + 7, "%s", filename);        bool found = false;        std::lock_guard<std::mutex> lock(mtx);        for (int i = 0; i < file_count; i++) {            if (strcmp(directory[i].filename, filename) == 0) {                char msg[BUFFER_SIZE];                sprintf(msg, "PEER %s:%d\n", directory[i].peer_ip, directory[i].peer_port);                send(client, msg, (int)strlen(msg), 0);                found = true;                break;            }        }        if (!found) {            const char* msg = "NOTFOUND\n";            send(client, msg, (int)strlen(msg), 0);        }    }    else if (strncmp(buffer, "REMOVE", 6) == 0) {        char filename[MAX_FILENAME], ip[32];        int port;        sscanf(buffer + 7, "%s %s %d", filename, ip, &port);        remove_file_from_peer(filename, ip, port);        const char* msg = "File removed from previous peer.\n";        send(client, msg, (int)strlen(msg), 0);    }    else if (strncmp(buffer, "LIST", 4) == 0) {        int port;        sscanf(buffer + 5, "%d", &port);        char msg[BUFFER_SIZE] = "";        std::lock_guard<std::mutex> lock(mtx);        for (int i = 0; i < file_count; i++) {            if (directory[i].peer_port == port) {                strcat(msg, directory[i].filename);                strcat(msg, "\n");            }        }        send(client, msg, (int)strlen(msg), 0);    }    else {        const char* msg = "INVALID COMMAND\n";        send(client, msg, (int)strlen(msg), 0);    }    closesocket(client);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    directory = (FileEntry*)malloc(sizeof(FileEntry) * MAX_FILES);    SOCKET server_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server_addr{};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    bind(server_sock, (sockaddr*)&server_addr, sizeof(server_addr));    listen(server_sock, 10);    printf("Server started on port %d\n", SERVER_PORT);    while (1) {        sockaddr_in client_addr{};        int len = sizeof(client_addr);        SOCKET client = accept(server_sock, (sockaddr*)&client_addr, &len);        if (client == INVALID_SOCKET) continue;        printf("[Server] Client connected: %s:%d\n",            inet_ntoa(client_addr.sin_addr),            ntohs(client_addr.sin_port));        std::thread(handle_client, client).detach();    }    closesocket(server_sock);    WSACleanup();    free(directory);    return 0;}client.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#include <cstring>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define BUFFER_SIZE 1024void trim(char* str) {    int len = (int)strlen(str);    while (len > 0 && (str[len - 1] == '\n' || str[len - 1] == '\r')) {        str[len - 1] = '\0';        len--;    }}void send_to_server(const char* msg, char* response) {    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serv{};    serv.sin_family = AF_INET;    serv.sin_port = htons(SERVER_PORT);    serv.sin_addr.s_addr = inet_addr(SERVER_IP);    if (connect(s, (sockaddr*)&serv, sizeof(serv)) == SOCKET_ERROR) {        strcpy(response, "ERROR");        closesocket(s);        return;    }    send(s, msg, (int)strlen(msg), 0);    int n = recv(s, response, BUFFER_SIZE - 1, 0);    if (n > 0) response[n] = '\0';    else strcpy(response, "No response");    closesocket(s);}// Peer file servervoid peer_server(int port) {    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in addr{};    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = INADDR_ANY;    bind(s, (sockaddr*)&addr, sizeof(addr));    listen(s, 5);    printf("[Peer] File server running on port %d\n", port);    while (1) {        SOCKET c = accept(s, NULL, NULL);        if (c == INVALID_SOCKET) continue;        char buffer[BUFFER_SIZE];        int n = recv(c, buffer, BUFFER_SIZE - 1, 0);        if (n <= 0) { closesocket(c); continue; }        buffer[n] = '\0';        FILE* f = fopen(buffer, "rb");        if (!f) {            const char* msg = "NOTFOUND";            send(c, msg, (int)strlen(msg), 0);            closesocket(c);            continue;        }        while ((n = (int)fread(buffer, 1, BUFFER_SIZE, f)) > 0)            send(c, buffer, n, 0);        fclose(f);        closesocket(c);    }}// Download file from peervoid download_from_peer(const char* ip, int port, const char* filename) {    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in peer{};    peer.sin_family = AF_INET;    peer.sin_port = htons(port);    peer.sin_addr.s_addr = inet_addr(ip);    if (connect(s, (sockaddr*)&peer, sizeof(peer)) == SOCKET_ERROR) {        printf("Cannot connect to peer.\n");        closesocket(s);        return;    }    send(s, filename, (int)strlen(filename), 0);    FILE* f = fopen(filename, "wb");    if (!f) { printf("Cannot create file.\n"); closesocket(s); return; }    char buffer[BUFFER_SIZE];    int n;    while ((n = recv(s, buffer, BUFFER_SIZE, 0)) > 0)        fwrite(buffer, 1, n, f);    fclose(f);    closesocket(s);    printf("Downloaded '%s' from %s:%d\n", filename, ip, port);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    int my_port;    char files[BUFFER_SIZE];    printf("Enter your peer port: ");    scanf("%d", &my_port);    getchar(); // consume newline    printf("Enter files to share (comma separated): ");    fgets(files, BUFFER_SIZE, stdin);    trim(files);    char msg[BUFFER_SIZE], response[BUFFER_SIZE];    sprintf(msg, "REGISTER %d %s", my_port, files);    send_to_server(msg, response);    printf("[Server] %s\n", response);    std::thread(peer_server, my_port).detach();    while (1) {        printf("\nOptions:\n1. Request file\n2. Show my files\n3. Exit\nChoice: ");        int choice;        scanf("%d", &choice);        getchar();        if (choice == 1) {            char filename[BUFFER_SIZE];            printf("Enter filename to download: ");            scanf("%s", filename);            sprintf(msg, "REQUEST %s", filename);            send_to_server(msg, response);            printf("[Server] %s\n", response);            if (strncmp(response, "PEER", 4) == 0) {                char ip[32];                int port;                sscanf(response + 5, "%[^:]:%d", ip, &port);                download_from_peer(ip, port, filename);                // Remove from old peer                sprintf(msg, "REMOVE %s %s %d", filename, ip, port);                send_to_server(msg, response);                // Register under my peer                sprintf(msg, "REGISTER %d %s", my_port, filename);                send_to_server(msg, response);            }        }        else if (choice == 2) {            sprintf(msg, "LIST %d", my_port);            send_to_server(msg, response);            printf("Your current files:\n%s\n", response);        }        else if (choice == 3) break;    }    WSACleanup();    return 0;}--udpserver.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#include <mutex>#include <cstring>#pragma comment(lib, "Ws2_32.lib")#define SERVER_PORT 4321#define MAX_FILES 100#define MAX_FILENAME 128#define BUFFER_SIZE 1024struct FileEntry {    char filename[MAX_FILENAME];    char peer_ip[32];    int peer_port;};FileEntry* directory;int file_count = 0;std::mutex mtx;void trim(char* str) {    int len = (int)strlen(str);    while (len > 0 && (str[len - 1] == '\n' || str[len - 1] == '\r')) {        str[len - 1] = '\0';        len--;    }}void remove_file_from_peer(const char* filename, const char* ip, int port) {    std::lock_guard<std::mutex> lock(mtx);    for (int i = 0; i < file_count; i++) {        if (strcmp(directory[i].filename, filename) == 0 &&            strcmp(directory[i].peer_ip, ip) == 0 &&            directory[i].peer_port == port) {            for (int j = i; j < file_count - 1; j++)                directory[j] = directory[j + 1];            file_count--;            break;        }    }}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    directory = (FileEntry*)malloc(sizeof(FileEntry) * MAX_FILES);    SOCKET server_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in server_addr{};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(SERVER_PORT);    server_addr.sin_addr.s_addr = INADDR_ANY;    bind(server_sock, (sockaddr*)&server_addr, sizeof(server_addr));    printf("UDP Server started on port %d\n", SERVER_PORT);    char buffer[BUFFER_SIZE];    sockaddr_in client_addr;    int len = sizeof(client_addr);    while (1) {        int n = recvfrom(server_sock, buffer, BUFFER_SIZE - 1, 0,            (sockaddr*)&client_addr, &len);        if (n <= 0) continue;        buffer[n] = '\0';        trim(buffer);        printf("[Server] Received: %s\n", buffer);        char response[BUFFER_SIZE] = "";        if (strncmp(buffer, "REGISTER", 8) == 0) {            int port;            char filelist[BUFFER_SIZE];            sscanf(buffer + 8, "%d %[^\n]", &port, filelist);            char* token = strtok(filelist, ",");            std::lock_guard<std::mutex> lock(mtx);            while (token != NULL && file_count < MAX_FILES) {                trim(token);                strcpy(directory[file_count].filename, token);                strcpy(directory[file_count].peer_ip, inet_ntoa(client_addr.sin_addr));                directory[file_count].peer_port = port;                file_count++;                token = strtok(NULL, ",");            }            strcpy(response, "Files registered.\n");        }        else if (strncmp(buffer, "REQUEST", 7) == 0) {            char filename[MAX_FILENAME];            sscanf(buffer + 7, "%s", filename);            bool found = false;            std::lock_guard<std::mutex> lock(mtx);            for (int i = 0; i < file_count; i++) {                if (strcmp(directory[i].filename, filename) == 0) {                    sprintf(response, "PEER %s:%d\n", directory[i].peer_ip, directory[i].peer_port);                    found = true;                    break;                }            }            if (!found) strcpy(response, "NOTFOUND\n");        }        else if (strncmp(buffer, "REMOVE", 6) == 0) {            char filename[MAX_FILENAME], ip[32];            int port;            sscanf(buffer + 7, "%s %s %d", filename, ip, &port);            remove_file_from_peer(filename, ip, port);            strcpy(response, "File removed from previous peer.\n");        }        else if (strncmp(buffer, "LIST", 4) == 0) {            int port;            sscanf(buffer + 5, "%d", &port);            std::lock_guard<std::mutex> lock(mtx);            for (int i = 0; i < file_count; i++) {                if (directory[i].peer_port == port) {                    strcat(response, directory[i].filename);                    strcat(response, "\n");                }            }            if (strlen(response) == 0) strcpy(response, "No files.\n");        }        else strcpy(response, "INVALID COMMAND\n");        sendto(server_sock, response, (int)strlen(response), 0,            (sockaddr*)&client_addr, len);    }    closesocket(server_sock);    WSACleanup();    free(directory);    return 0;}client.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#include <cstring>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT 4321#define BUFFER_SIZE 1024void trim(char* str) {    int len = (int)strlen(str);    while (len > 0 && (str[len - 1] == '\n' || str[len - 1] == '\r')) {        str[len - 1] = '\0';        len--;    }}void send_to_server(SOCKET s, sockaddr_in* serv, const char* msg, char* response) {    int slen = sizeof(*serv);    sendto(s, msg, (int)strlen(msg), 0, (sockaddr*)serv, slen);    int n = recvfrom(s, response, BUFFER_SIZE - 1, 0, NULL, NULL);    if (n > 0) response[n] = '\0';    else strcpy(response, "No response");}// Peer file server (UDP)void peer_server(int port) {    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in addr{};    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = INADDR_ANY;    bind(s, (sockaddr*)&addr, sizeof(addr));    printf("[Peer] UDP file server on port %d\n", port);    char buffer[BUFFER_SIZE];    sockaddr_in client_addr;    int len = sizeof(client_addr);    while (1) {        int n = recvfrom(s, buffer, BUFFER_SIZE - 1, 0, (sockaddr*)&client_addr, &len);        if (n <= 0) continue;        buffer[n] = '\0';        FILE* f = fopen(buffer, "rb");        if (!f) {            const char* msg = "NOTFOUND";            sendto(s, msg, (int)strlen(msg), 0, (sockaddr*)&client_addr, len);            continue;        }        while ((n = (int)fread(buffer, 1, BUFFER_SIZE, f)) > 0)            sendto(s, buffer, n, 0, (sockaddr*)&client_addr, len);        fclose(f);    }}// Download file from peer (UDP)void download_from_peer(const char* ip, int port, const char* filename) {    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in peer{};    peer.sin_family = AF_INET;    peer.sin_port = htons(port);    peer.sin_addr.s_addr = inet_addr(ip);    int plen = sizeof(peer);    sendto(s, filename, (int)strlen(filename), 0, (sockaddr*)&peer, plen);    FILE* f = fopen(filename, "wb");    if (!f) { printf("Cannot create file.\n"); closesocket(s); return; }    char buffer[BUFFER_SIZE];    int n;    struct timeval tv = { 2, 0 }; // 2-second timeout    setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof(tv));    while ((n = recvfrom(s, buffer, BUFFER_SIZE, 0, NULL, NULL)) > 0)        fwrite(buffer, 1, n, f);    fclose(f);    closesocket(s);    printf("Downloaded '%s' from %s:%d (UDP)\n", filename, ip, port);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    int my_port;    char files[BUFFER_SIZE];    printf("Enter your peer port: ");    scanf("%d", &my_port);    getchar();    printf("Enter files to share (comma separated): ");    fgets(files, BUFFER_SIZE, stdin);    trim(files);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in serv{};    serv.sin_family = AF_INET;    serv.sin_port = htons(SERVER_PORT);    serv.sin_addr.s_addr = inet_addr(SERVER_IP);    char msg[BUFFER_SIZE], response[BUFFER_SIZE];    sprintf(msg, "REGISTER %d %s", my_port, files);    send_to_server(s, &serv, msg, response);    printf("[Server] %s\n", response);    std::thread(peer_server, my_port).detach();    while (1) {        printf("\nOptions:\n1. Request file\n2. Show my files\n3. Exit\nChoice: ");        int choice;        scanf("%d", &choice);        getchar();        if (choice == 1) {            char filename[BUFFER_SIZE];            printf("Enter filename to download: ");            scanf("%s", filename);            sprintf(msg, "REQUEST %s", filename);            send_to_server(s, &serv, msg, response);            printf("[Server] %s\n", response);            if (strncmp(response, "PEER", 4) == 0) {                char ip[32];                int port;                sscanf(response + 5, "%[^:]:%d", ip, &port);                download_from_peer(ip, port, filename);                sprintf(msg, "REMOVE %s %s %d", filename, ip, port);                send_to_server(s, &serv, msg, response);                sprintf(msg, "REGISTER %d %s", my_port, filename);                send_to_server(s, &serv, msg, response);            }        }        else if (choice == 2) {            sprintf(msg, "LIST %d", my_port);            send_to_server(s, &serv, msg, response);            printf("Your current files:\n%s\n", response);        }        else if (choice == 3) break;    }    closesocket(s);    WSACleanup();    return 0;}9.   Change the C Example Concurrent Number Guess Bellow to transmit with each answer to a client – the number of total clients that are competing. Also change the client to read the numbers from the standard input and launch a contest in the class during the lab . A client server implementation in c for the number guess problem. The server chooses a random number. The clients connect and send numbers to server. The server returns to each client a status message:·         ‘H’ – send a larger number·         ‘S’ – send a lower number·         ‘G’ – you guessed my number·         ‘L’ – another client guessed the number. You are a looser ! --tcpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <thread>#include <mutex>#include <vector>#include <algorithm>#include <time.h>#pragma comment(lib, "ws2_32.lib")struct Client {    SOCKET sock;    sockaddr_in addr;};std::vector<Client> clients;std::mutex client_mutex;std::mutex game_mutex;bool running = true;int secret_number = 0;void broadcast_lose(SOCKET winner_sock) {    std::lock_guard<std::mutex> lock(client_mutex);    for (auto& c : clients) {        if (c.sock == winner_sock) continue; // skip winner        char msg[64];        sprintf(msg, "L %d", (int)clients.size());        send(c.sock, msg, (int)strlen(msg), 0);    }}void handle_client(Client cli) {    char buffer[64];    int guess;    printf("[+] Client connected from %s:%d\n",        inet_ntoa(cli.addr.sin_addr),        ntohs(cli.addr.sin_port));    while (running) {        int bytes = recv(cli.sock, buffer, sizeof(buffer) - 1, 0);        if (bytes <= 0)            break;        buffer[bytes] = '\0';        guess = atoi(buffer);        char response[64];        bool guessed = false;        {            std::lock_guard<std::mutex> lock(game_mutex);            if (guess > secret_number) {                sprintf(response, "S %d", (int)clients.size()); // smaller            }            else if (guess < secret_number) {                sprintf(response, "H %d", (int)clients.size()); // higher            }            else {                sprintf(response, "G %d", (int)clients.size());                guessed = true;            }        }        send(cli.sock, response, (int)strlen(response), 0);        if (guessed) {            printf("[WINNER] %s:%d guessed %d!\n",                inet_ntoa(cli.addr.sin_addr),                ntohs(cli.addr.sin_port),                secret_number);            broadcast_lose(cli.sock);            // new round            {                std::lock_guard<std::mutex> lock(game_mutex);                secret_number = rand() % 100 + 1;            }            printf("[New Round] Secret = %d\n", secret_number);            break; // end this winner's thread, they can reconnect        }    }    {        std::lock_guard<std::mutex> lock(client_mutex);        closesocket(cli.sock);        clients.erase(            std::remove_if(clients.begin(), clients.end(),                [&](const Client& c) { return c.sock == cli.sock; }),            clients.end());    }    printf("[-] Client disconnected %s:%d\n",        inet_ntoa(cli.addr.sin_addr),        ntohs(cli.addr.sin_port));}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET server_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons(5000);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(server_sock, (sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {        printf("Bind failed: %d\n", WSAGetLastError());        return 1;    }    listen(server_sock, 5);    srand((unsigned)time(NULL));    secret_number = rand() % 100 + 1;    printf("[Server] Listening on port 5000, secret = %d\n", secret_number);    while (running) {        sockaddr_in client_addr{};        int len = sizeof(client_addr);        SOCKET client_sock = accept(server_sock, (sockaddr*)&client_addr, &len);        if (client_sock == INVALID_SOCKET)            continue;        Client cli;        cli.sock = client_sock;        cli.addr = client_addr;        {            std::lock_guard<std::mutex> lock(client_mutex);            clients.push_back(cli);        }        std::thread(handle_client, cli).detach();    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons(5000);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    if (connect(sock, (sockaddr*)&server, sizeof(server)) != 0) {        printf("[Error] Could not connect to server.\n");        return 1;    }    printf("Connected to server! Guess the number (1–100)\n");    char buffer[64];    int guess;    while (1) {        printf("Enter your guess: ");        if (scanf("%d", &guess) != 1) break;        sprintf(buffer, "%d", guess);        send(sock, buffer, (int)strlen(buffer), 0);        int bytes = recv(sock, buffer, sizeof(buffer) - 1, 0);        if (bytes <= 0) {            printf("Server disconnected.\n");            break;        }        buffer[bytes] = '\0';        char status;        int total;        sscanf(buffer, "%c %d", &status, &total);        if (status == 'H')            printf("Server: Send a larger number! (Players: %d)\n", total);        else if (status == 'S')            printf("Server: Send a smaller number! (Players: %d)\n", total);        else if (status == 'G') {            printf("🎉 You guessed it! (Players: %d)\n", total);            break;        }        else if (status == 'L') {            printf("💀 Another player guessed it! You lose! (Players: %d)\n", total);            break;        }    }    closesocket(sock);    WSACleanup();    return 0;}--udpserver.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <thread>#include <vector>#include <mutex>#include <algorithm>#include <time.h>#pragma comment(lib, "ws2_32.lib")struct Client {    sockaddr_in addr;};std::vector<Client> clients;std::mutex client_mutex;std::mutex game_mutex;bool running = true;int secret_number = 0;bool same_client(const sockaddr_in& a, const sockaddr_in& b) {    return (a.sin_addr.s_addr == b.sin_addr.s_addr && a.sin_port == b.sin_port);}void broadcast_lose(SOCKET sock, const sockaddr_in& winner) {    std::lock_guard<std::mutex> lock(client_mutex);    for (auto& c : clients) {        if (same_client(c.addr, winner)) continue; // skip winner        char msg[64];        sprintf(msg, "L %d", (int)clients.size());        sendto(sock, msg, (int)strlen(msg), 0,            (sockaddr*)&c.addr, sizeof(c.addr));    }}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons(5000);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(sock, (sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {        printf("Bind failed: %d\n", WSAGetLastError());        return 1;    }    srand((unsigned)time(NULL));    secret_number = rand() % 100 + 1;    printf("[Server] UDP Listening on port 5000, secret = %d\n", secret_number);    char buffer[64];    sockaddr_in cli_addr{};    int cli_len = sizeof(cli_addr);    while (running) {        int bytes = recvfrom(sock, buffer, sizeof(buffer) - 1, 0,            (sockaddr*)&cli_addr, &cli_len);        if (bytes <= 0) continue;        buffer[bytes] = '\0';        int guess = atoi(buffer);        // register client if new        {            std::lock_guard<std::mutex> lock(client_mutex);            bool exists = false;            for (auto& c : clients) {                if (same_client(c.addr, cli_addr)) { exists = true; break; }            }            if (!exists) {                clients.push_back({ cli_addr });                printf("[+] New client %s:%d (total=%d)\n",                    inet_ntoa(cli_addr.sin_addr),                    ntohs(cli_addr.sin_port),                    (int)clients.size());            }        }        char response[64];        bool guessed = false;        {            std::lock_guard<std::mutex> g_lock(game_mutex);            if (guess > secret_number) {                sprintf(response, "S %d", (int)clients.size());            }            else if (guess < secret_number) {                sprintf(response, "H %d", (int)clients.size());            }            else {                sprintf(response, "G %d", (int)clients.size());                guessed = true;            }        }        sendto(sock, response, (int)strlen(response), 0,            (sockaddr*)&cli_addr, sizeof(cli_addr));        if (guessed) {            printf("[WINNER] %s:%d guessed %d!\n",                inet_ntoa(cli_addr.sin_addr),                ntohs(cli_addr.sin_port),                secret_number);            // broadcast lose message immediately            broadcast_lose(sock, cli_addr);            // start new round            {                std::lock_guard<std::mutex> g_lock(game_mutex);                secret_number = rand() % 100 + 1;            }            printf("[New Round] Secret = %d\n", secret_number);        }    }    closesocket(sock);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons(5000);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    printf("Connected to server! Guess the number (1–100)\n");    char buffer[64];    int guess;    while (1) {        printf("Enter your guess: ");        if (scanf("%d", &guess) != 1) break;        sprintf(buffer, "%d", guess);        sendto(sock, buffer, (int)strlen(buffer), 0,            (sockaddr*)&server, sizeof(server));        sockaddr_in from{};        int fromlen = sizeof(from);        int bytes = recvfrom(sock, buffer, sizeof(buffer) - 1, 0,            (sockaddr*)&from, &fromlen);        if (bytes <= 0) {            printf("Server not responding.\n");            break;        }        buffer[bytes] = '\0';        char status;        int total;        sscanf(buffer, "%c %d", &status, &total);        if (status == 'H')            printf("Server: Send a larger number! (Players: %d)\n", total);        else if (status == 'S')            printf("Server: Send a smaller number! (Players: %d)\n", total);        else if (status == 'G') {            printf("🎉 You guessed it! (Players: %d)\n", total);            break;        }        else if (status == 'L') {            printf("💀 Another player guessed it! You lose! (Players: %d)\n", total);            break;        }    }    closesocket(sock);    WSACleanup();    return 0;}UDP - LAB 11.   A client sends to the server an array of numbers. Server returns the sum of the numbers.server.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {        printf("WSAStartup failed: %d\n", WSAGetLastError());        return -1;    }    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    if (s == INVALID_SOCKET) {        printf("Socket creation failed: %d\n", WSAGetLastError());        WSACleanup();        return 1;    }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(s, (struct sockaddr*)&server, sizeof(server)) < 0) {        printf("Bind failed\n");        closesocket(s);        WSACleanup();        return 1;    }    printf("UDP server listening on port 1234...\n");    while (1) {        int client_len = sizeof(client);        uint16_t n;        if (recvfrom(s, (char*)&n, sizeof(n), 0, (struct sockaddr*)&client, &client_len) != sizeof(n)) {            printf("Error receiving array size\n");            continue;        }        n = ntohs(n);        uint16_t* numbers = (uint16_t*)malloc(n * sizeof(uint16_t));        if (!numbers) continue;        int error = 0;        for (uint16_t i = 0; i < n; i++) {            uint16_t num;            if (recvfrom(s, (char*)&num, sizeof(num), 0, (struct sockaddr*)&client, &client_len) != sizeof(num)) {                printf("Error receiving number %d\n", i);                error = 1;                break;            }            numbers[i] = ntohs(num);        }        if (error) {            free(numbers);            continue;        }        uint16_t sum = 0;        for (uint16_t i = 0; i < n; i++) sum += numbers[i];        uint16_t net_sum = htons(sum);        sendto(s, (char*)&net_sum, sizeof(net_sum), 0, (struct sockaddr*)&client, sizeof(client));        free(numbers);    }    closesocket(s);    WSACleanup();    return 0;}client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <WinSock2.h>#include <cstdint>#pragma comment(lib,"Ws2_32.lib")int main() {    WSADATA wsaData;    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) return -1;    SOCKET c = socket(AF_INET, SOCK_DGRAM, 0);    if (c == INVALID_SOCKET) return 1;    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(1234);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    uint16_t n;    printf("How many numbers? ");    scanf("%hu", &n);    uint16_t* numbers = (uint16_t*)malloc(n * sizeof(uint16_t));    for (uint16_t i = 0; i < n; i++) {        printf("Number %d: ", i + 1);        scanf("%hu", &numbers[i]);    }    uint16_t net_n = htons(n);    sendto(c, (char*)&net_n, sizeof(net_n), 0, (struct sockaddr*)&server, sizeof(server));    for (uint16_t i = 0; i < n; i++) {        uint16_t net_num = htons(numbers[i]);        sendto(c, (char*)&net_num, sizeof(net_num), 0, (struct sockaddr*)&server, sizeof(server));    }    uint16_t net_sum, sum;    int server_len = sizeof(server);    recvfrom(c, (char*)&net_sum, sizeof(net_sum), 0, (struct sockaddr*)&server, &server_len);    sum = ntohs(net_sum);    printf("Sum = %hu\n", sum);    free(numbers);    closesocket(c);    WSACleanup();    return 0;}2.   A client sends to the server a string. The server returns the count of spaces in the string.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa; WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server, client;    int clen = sizeof(client);    server.sin_family = AF_INET;    server.sin_addr.s_addr = INADDR_ANY;    server.sin_port = htons(5000);    bind(s, (struct sockaddr*)&server, sizeof(server));    char buf[1024];    printf("UDP Server waiting on port 5000...\n");    while (1) {        int len = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&client, &clen);        if (len <= 0) continue;        buf[len] = '\0';        int spaces = 0;        for (int i = 0; i < len; i++) if (buf[i] == ' ') spaces++;        sprintf(buf, "%d", spaces);        sendto(s, buf, (int)strlen(buf), 0, (struct sockaddr*)&client, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa; WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(5000);    server.sin_addr.s_addr = inet_addr("127.0.0.1");    char msg[1024], buf[1024];    printf("Enter string: ");    fgets(msg, sizeof(msg), stdin);    sendto(s, msg, (int)strlen(msg), 0, (struct sockaddr*)&server, sizeof(server));    int slen = sizeof(server);    int len = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&server, &slen);    buf[len] = '\0';    printf("Number of spaces: %s\n", buf);}3.   A client sends to the server a string. The server returns the reversed string to the client (characters from the end to begging)SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa; WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli;    int clen = sizeof(cli);    srv.sin_family = AF_INET;    srv.sin_addr.s_addr = INADDR_ANY;    srv.sin_port = htons(5000);    bind(s, (struct sockaddr*)&srv, sizeof(srv));    char buf[1024];    printf("Server ready on port 5000\n");    while (1) {        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        buf[n] = '\0';        int len = strlen(buf);        for (int i = 0; i < len / 2; i++) {            char t = buf[i]; buf[i] = buf[len - 1 - i]; buf[len - 1 - i] = t;        }        sendto(s, buf, len, 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA wsa; WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv;    srv.sin_family = AF_INET;    srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char msg[1024], buf[1024];    printf("Enter string: ");    fgets(msg, sizeof(msg), stdin);    sendto(s, msg, (int)strlen(msg), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv);    int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0';    printf("Reversed: %s\n", buf);}4.   The client sends to the server two sorted array of chars. The server will merge sort the two arrays and return the result to the client.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli; int clen = sizeof(cli);    srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&srv, sizeof(srv));    char buf[1024];    printf("Server ready\n");    while (1) {        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        buf[n] = '\0';        char a[512], b[512];        sscanf(buf, "%s %s", a, b);        int i = 0, j = 0, k = 0;        char res[1024];        while (a[i] && b[j]) {            res[k++] = (a[i] < b[j]) ? a[i++] : b[j++];        }        while (a[i]) res[k++] = a[i++];        while (b[j]) res[k++] = b[j++];        res[k] = '\0';        sendto(s, res, (int)strlen(res), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w;    WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv;    srv.sin_family = AF_INET;    srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char a[256], b[256], buf[1024];    printf("Enter first sorted array (chars): ");    fgets(a, sizeof(a), stdin);    a[strcspn(a, "\n")] = 0;  // remove newline    printf("Enter second sorted array (chars): ");    fgets(b, sizeof(b), stdin);    b[strcspn(b, "\n")] = 0;  // remove newline    sprintf(buf, "%s %s", a, b);    sendto(s, buf, (int)strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv);    int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0';    printf("Merged: %s\n", buf);    closesocket(s);    WSACleanup();    return 0;}5.   The client sends to the server an integer. The server returns the list of divisors for the specified number.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli; int clen = sizeof(cli);    srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&srv, sizeof(srv));    char buf[1024];    while (1) {        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        buf[n] = '\0'; int x = atoi(buf);        char res[1024] = "";        for (int i = 1; i <= x; i++) if (x % i == 0) { char t[32]; sprintf(t, "%d ", i); strcat(res, t); }        sendto(s, res, (int)strlen(res), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET;    srv.sin_port = htons(5000); srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char buf[1024];    printf("Enter integer: "); fgets(buf, sizeof(buf), stdin);    buf[strcspn(buf, "\n")] = 0;    sendto(s, buf, (int)strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv); int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0'; printf("Divisors: %s\n", buf);}6.   The client sends to the server a string and a character. The server returns to the client a list of all positions in the string where specified character is found.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli; int clen = sizeof(cli);    srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&srv, sizeof(srv));    char buf[1024];    while (1) {        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        buf[n] = '\0';        char str[512], c; sscanf(buf, "%[^;];%c", str, &c);        char res[1024] = "";        for (int i = 0; str[i]; i++) if (str[i] == c) { char t[16]; sprintf(t, "%d ", i); strcat(res, t); }        sendto(s, res, (int)strlen(res), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET;    srv.sin_port = htons(5000); srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char str[512], c, buf[1024];    printf("Enter string: "); fgets(str, sizeof(str), stdin);    str[strcspn(str, "\n")] = 0;    printf("Enter character: "); scanf("%c", &c);    sprintf(buf, "%s;%c", str, c);    sendto(s, buf, (int)strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv); int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0'; printf("Positions: %s\n", buf);}7.   The client sends to the server a string and two numbers (s, I, l). The sever returns to the client the substring of s starting at index I, of length l.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli; int clen = sizeof(cli);    srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY; bind(s, (struct sockaddr*)&srv, sizeof(srv));    char buf[1024];    while (1) {        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        buf[n] = '\0';        char str[512]; int i, l;        sscanf(buf, "%[^;];%d;%d", str, &i, &l);        char res[512] = "";        strncpy(res, str + i, l); res[l] = '\0';        sendto(s, res, (int)strlen(res), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET;    srv.sin_port = htons(5000); srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char str[512], buf[1024]; int i, l;    printf("Enter string: "); fgets(str, sizeof(str), stdin);    str[strcspn(str, "\n")] = 0;    printf("Enter start index: "); scanf("%d", &i);    printf("Enter length: "); scanf("%d", &l);    sprintf(buf, "%s;%d;%d", str, i, l);    sendto(s, buf, (int)strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv); int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0'; printf("Substring: %s\n", buf);}8.   The client sends to the server two arrays of integers. The server returns an arrays containing the common numbers found in both arrays.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA w;    WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli;    srv.sin_family = AF_INET;    srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&srv, sizeof(srv));    printf("Server running on UDP port 5000...\n");    while (1) {        char buf[1024];        int clen = sizeof(cli);        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        if (n <= 0) continue;        buf[n] = '\0';        // Parse the two arrays        char a[512], b[512];        sscanf(buf, "%[^ ] %[^\n]", a, b);        int arr1[100], arr2[100], common[100];        int n1 = 0, n2 = 0, ncommon = 0;        char* tok = strtok(a, ",");        while (tok) {            arr1[n1++] = atoi(tok);            tok = strtok(NULL, ",");        }        tok = strtok(b, ",");        while (tok) {            arr2[n2++] = atoi(tok);            tok = strtok(NULL, ",");        }        for (int i = 0; i < n1; i++) {            for (int j = 0; j < n2; j++) {                if (arr1[i] == arr2[j]) {                    common[ncommon++] = arr1[i];                    break; // prevent duplicates per arr1 element                }            }        }        char out[512] = "";        for (int i = 0; i < ncommon; i++) {            char tmp[32];            sprintf(tmp, "%d,", common[i]);            strcat(out, tmp);        }        if (ncommon > 0) out[strlen(out) - 1] = '\0'; // remove last comma        sendto(s, out, (int)strlen(out), 0, (struct sockaddr*)&cli, clen);    }    closesocket(s);    WSACleanup();    return 0;}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA w;    WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv;    srv.sin_family = AF_INET;    srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char a[256], b[256], buf[512];    printf("Enter first array (comma separated): ");    fgets(a, sizeof(a), stdin);    a[strcspn(a, "\n")] = 0;    printf("Enter second array (comma separated): ");    fgets(b, sizeof(b), stdin);    b[strcspn(b, "\n")] = 0;    sprintf(buf, "%s %s", a, b);    sendto(s, buf, (int)strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv);    int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0';    printf("Common numbers: %s\n", buf);    closesocket(s);    WSACleanup();    return 0;}9.   The client sends to the server two arrays of numbers. The server returns to the client a list of numbers that are present in the first arrays but not in the second.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli;    srv.sin_family = AF_INET; srv.sin_port = htons(5000); srv.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&srv, sizeof(srv));    printf("Server running (UDP 5000)...\n");    while (1) {        char buf[1024]; int clen = sizeof(cli);        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        if (n <= 0) continue; buf[n] = '\0';        char a[512], b[512]; sscanf(buf, "%[^ ] %[^\n]", a, b);        int arr1[100], arr2[100], result[100];        int n1 = 0, n2 = 0, nr = 0;        char* tok = strtok(a, ",");        while (tok) { arr1[n1++] = atoi(tok); tok = strtok(NULL, ","); }        tok = strtok(b, ",");        while (tok) { arr2[n2++] = atoi(tok); tok = strtok(NULL, ","); }        for (int i = 0; i < n1; i++) {            int found = 0;            for (int j = 0; j < n2; j++) if (arr1[i] == arr2[j]) { found = 1; break; }            if (!found) result[nr++] = arr1[i];        }        char out[512] = "";        for (int i = 0; i < nr; i++) { char t[32]; sprintf(t, "%d,", result[i]); strcat(out, t); }        if (nr > 0) out[strlen(out) - 1] = '\0';        sendto(s, out, strlen(out), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char a[256], b[256], buf[512];    printf("Enter first array (comma separated): "); fgets(a, sizeof(a), stdin); a[strcspn(a, "\n")] = 0;    printf("Enter second array (comma separated): "); fgets(b, sizeof(b), stdin); b[strcspn(b, "\n")] = 0;    sprintf(buf, "%s %s", a, b);    sendto(s, buf, strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv); int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0';    printf("Numbers in first but not second: %s\n", buf);    closesocket(s); WSACleanup();}10.The client sends to the server two strings. The server sends back the character with the largest number of occurrences on the same positions in both strings together with its count.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli;    srv.sin_family = AF_INET; srv.sin_port = htons(5000); srv.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&srv, sizeof(srv));    printf("Server running...\n");    while (1) {        char buf[512]; int clen = sizeof(cli);        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        buf[n] = '\0';        char s1[256], s2[256]; sscanf(buf, "%[^ ] %[^\n]", s1, s2);        int count[256] = { 0 };        int len1 = strlen(s1), len2 = strlen(s2), len = len1 < len2 ? len1 : len2;        for (int i = 0; i < len; i++) if (s1[i] == s2[i]) count[(unsigned char)s1[i]]++;        char best = '?'; int bestc = 0;        for (int i = 0; i < 256; i++) if (count[i] > bestc) { bestc = count[i]; best = i; }        char out[64]; sprintf(out, "%c %d", best, bestc);        sendto(s, out, strlen(out), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char s1[256], s2[256], buf[512];    printf("Enter first string: "); fgets(s1, sizeof(s1), stdin); s1[strcspn(s1, "\n")] = 0;    printf("Enter second string: "); fgets(s2, sizeof(s2), stdin); s2[strcspn(s2, "\n")] = 0;    sprintf(buf, "%s %s", s1, s2);    sendto(s, buf, strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv); int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen); buf[n] = '\0';    printf("Most common char on same positions: %s\n", buf);    closesocket(s); WSACleanup();}11.Define a simple structure (e.g., a Person object with firstname, lastname, gender  and age). The client sends this structure to the server. The server increments the age and sends the updated structure back.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")typedef struct {    char fname[32];    char lname[32];    char gender[8];    int age;} Person;int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli;    srv.sin_family = AF_INET; srv.sin_port = htons(5000); srv.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&srv, sizeof(srv));    printf("Server running...\n");    while (1) {        Person p; int clen = sizeof(cli);        int n = recvfrom(s, (char*)&p, sizeof(p), 0, (struct sockaddr*)&cli, &clen);        p.age++;        sendto(s, (char*)&p, sizeof(p), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")typedef struct {    char fname[32];    char lname[32];    char gender[8];    int age;} Person;int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    Person p;    printf("First name: "); fgets(p.fname, sizeof(p.fname), stdin); p.fname[strcspn(p.fname, "\n")] = 0;    printf("Last name: "); fgets(p.lname, sizeof(p.lname), stdin); p.lname[strcspn(p.lname, "\n")] = 0;    printf("Gender: "); fgets(p.gender, sizeof(p.gender), stdin); p.gender[strcspn(p.gender, "\n")] = 0;    printf("Age: "); scanf("%d", &p.age);    sendto(s, (char*)&p, sizeof(p), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv);    recvfrom(s, (char*)&p, sizeof(p), 0, (struct sockaddr*)&srv, &slen);    printf("Updated age: %d\n", p.age);    closesocket(s); WSACleanup();}12.The client sends a date string in YYYY-MM-DD format. The server returns the day of the week corresponding to that date.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <time.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")const char* days[] = { "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday" };int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY; bind(s, (struct sockaddr*)&srv, sizeof(srv));    printf("Server running...\n");    while (1) {        char buf[64]; int clen = sizeof(cli);        int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&cli, &clen);        buf[n] = '\0';        int y, m, d; sscanf(buf, "%d-%d-%d", &y, &m, &d);        struct tm t = { 0 }; t.tm_year = y - 1900; t.tm_mon = m - 1; t.tm_mday = d;        mktime(&t);        sendto(s, days[t.tm_wday], (int)strlen(days[t.tm_wday]), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char buf[64];    printf("Enter date (YYYY-MM-DD): ");    fgets(buf, sizeof(buf), stdin); buf[strcspn(buf, "\n")] = 0;    sendto(s, buf, strlen(buf), 0, (struct sockaddr*)&srv, sizeof(srv));    int slen = sizeof(srv); int n = recvfrom(s, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&srv, &slen);    buf[n] = '\0';    printf("Day of week: %s\n", buf);    closesocket(s); WSACleanup();}13.The client sends a small text file to the server. The server saves the file and returns the length of the received file content as an unsigned integerSERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY; bind(s, (struct sockaddr*)&srv, sizeof(srv));    printf("Server running...\n");    while (1) {        char buf[2048]; int clen = sizeof(cli);        int n = recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&cli, &clen);        FILE* f = fopen("received.txt", "wb");        fwrite(buf, 1, n, f); fclose(f);        unsigned int len = n;        sendto(s, (char*)&len, sizeof(len), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <string.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    char filename[100]; printf("Enter filename to send: "); fgets(filename, sizeof(filename), stdin);    filename[strcspn(filename, "\n")] = 0;    FILE* f = fopen(filename, "rb"); if (!f) { printf("File not found!\n"); return 1; }    char buf[2048]; int n = fread(buf, 1, sizeof(buf), f); fclose(f);    sendto(s, buf, n, 0, (struct sockaddr*)&srv, sizeof(srv));    unsigned int len; int slen = sizeof(srv);    recvfrom(s, (char*)&len, sizeof(len), 0, (struct sockaddr*)&srv, &slen);    printf("Server received %u bytes\n", len);    closesocket(s); WSACleanup();}14.The client sends an array of boolean values. The server counts how many true values are in the array and returns the count.SERVER.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv, cli; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = INADDR_ANY; bind(s, (struct sockaddr*)&srv, sizeof(srv));    printf("Server running...\n");    while (1) {        int arr[100]; int clen = sizeof(cli);        int n = recvfrom(s, (char*)arr, sizeof(arr), 0, (struct sockaddr*)&cli, &clen);        int count = 0, len = n / sizeof(int);        for (int i = 0; i < len; i++) if (arr[i]) count++;        sendto(s, (char*)&count, sizeof(count), 0, (struct sockaddr*)&cli, clen);    }}CLIENT.C#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#pragma comment(lib,"ws2_32.lib")int main() {    WSADATA w; WSAStartup(MAKEWORD(2, 2), &w);    SOCKET s = socket(AF_INET, SOCK_DGRAM, 0);    struct sockaddr_in srv; srv.sin_family = AF_INET; srv.sin_port = htons(5000);    srv.sin_addr.s_addr = inet_addr("127.0.0.1");    int n; printf("How many booleans: "); scanf("%d", &n);    int arr[100];    for (int i = 0; i < n; i++) { int v; printf("Value %d (0/1): ", i + 1); scanf("%d", &v); arr[i] = v; }    sendto(s, (char*)arr, n * sizeof(int), 0, (struct sockaddr*)&srv, sizeof(srv));    int count; int slen = sizeof(srv);    recvfrom(s, (char*)&count, sizeof(count), 0, (struct sockaddr*)&srv, &slen);    printf("Number of true values: %d\n", count);    closesocket(s); WSACleanup();}LAB33.   Implement a UDP-based real-time collaborative whiteboard application where multiple clients can draw on a shared canvas. The server manages the canvas state and broadcasts updates to all clients. Use drawing primitives of type line, circle, ellipse, rectangles with contour colors and eventually fill.client.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <iostream>#include <thread>#include <winsock2.h>#include <string>#include <atomic>#pragma comment(lib, "ws2_32.lib")int UDP_PORT = 0; // Will be assigned dynamicallystd::atomic<bool> running(true);// Thread to listen for UDP updates from servervoid udp_listener(int port) {    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in addr{};    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = INADDR_ANY;    if (bind(udp_sock, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {        std::cerr << "[Error] UDP bind failed: " << WSAGetLastError() << std::endl;        return;    }    std::cout << "[UDP] Listening on port " << port << std::endl;    char buffer[256];    sockaddr_in from{};    int fromlen = sizeof(from);    // Set receive timeout    DWORD timeout = 1000; // 1 second    setsockopt(udp_sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));    while (running) {        int bytes = recvfrom(udp_sock, buffer, sizeof(buffer) - 1, 0,            (sockaddr*)&from, &fromlen);        if (bytes > 0) {            buffer[bytes] = '\0';            std::cout << "[Canvas update] " << buffer << std::endl;        }    }    closesocket(udp_sock);}// Thread to receive initial canvas state via TCPvoid tcp_receiver(SOCKET tcp_sock) {    char buffer[256];    std::string accumulated;    // Set receive timeout    DWORD timeout = 5000; // 5 seconds    setsockopt(tcp_sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));    std::cout << "[TCP] Receiving initial canvas state...\n";    while (true) {        int bytes = recv(tcp_sock, buffer, sizeof(buffer) - 1, 0);        if (bytes <= 0) {            if (WSAGetLastError() == WSAETIMEDOUT) {                std::cout << "[TCP] Canvas state received (timeout)\n";                break;            }            break;        }        buffer[bytes] = '\0';        accumulated += buffer;        // Process complete commands (separated by newlines)        size_t pos;        while ((pos = accumulated.find('\n')) != std::string::npos) {            std::string cmd = accumulated.substr(0, pos);            if (!cmd.empty()) {                std::cout << "[Initial state] " << cmd << std::endl;            }            accumulated.erase(0, pos + 1);        }    }    std::cout << "[TCP] Switched to command input mode\n";}int main(int argc, char* argv[]) {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    // Automatically assign UDP port or use provided one    if (argc > 1) {        UDP_PORT = atoi(argv[1]);    }    else {        // Create a temporary socket to get an available port        SOCKET temp_sock = socket(AF_INET, SOCK_DGRAM, 0);        sockaddr_in temp_addr{};        temp_addr.sin_family = AF_INET;        temp_addr.sin_port = 0; // Let OS assign port        temp_addr.sin_addr.s_addr = INADDR_ANY;        bind(temp_sock, (sockaddr*)&temp_addr, sizeof(temp_addr));        int addr_len = sizeof(temp_addr);        getsockname(temp_sock, (sockaddr*)&temp_addr, &addr_len);        UDP_PORT = ntohs(temp_addr.sin_port);        closesocket(temp_sock);        std::cout << "[Client] Automatically assigned UDP port: " << UDP_PORT << std::endl;    }    // Start UDP listener thread    std::thread listener_thread(udp_listener, UDP_PORT);    // TCP client for sending drawing commands    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons(6006);    server.sin_addr.s_addr = inet_addr("127.0.0.1"); // Changed to localhost for testing    std::cout << "[Client] Connecting to server...\n";    if (connect(tcp_sock, (sockaddr*)&server, sizeof(server)) != 0) {        std::cerr << "[Error] TCP connect failed: " << WSAGetLastError() << "\n";        std::cerr << "Make sure the server is running and the IP address is correct.\n";        running = false;        listener_thread.join();        WSACleanup();        return 1;    }    std::cout << "[Client] Connected to server!\n";    // Send UDP port to server    std::string port_str = std::to_string(UDP_PORT);    send(tcp_sock, port_str.c_str(), (int)port_str.size(), 0);    // Receive initial canvas state    std::thread receiver_thread(tcp_receiver, tcp_sock);    receiver_thread.join();    // Remove timeout for normal operation    DWORD timeout = 0;    setsockopt(tcp_sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));    std::cout << "\n[Client] Enter drawing commands:\n";    std::cout << "Examples:\n";    std::cout << "  line 10 10 100 100 red\n";    std::cout << "  circle 50 50 30 blue\n";    std::cout << "  rect 20 20 80 60 green fill\n";    std::cout << "  ellipse 100 100 40 20 yellow\n";    std::cout << "Type 'exit' to quit.\n\n";    std::string cmd;    while (running) {        std::getline(std::cin, cmd);        if (cmd == "exit") break;        if (cmd.empty()) continue;        int sent = send(tcp_sock, cmd.c_str(), (int)cmd.size(), 0);        if (sent == SOCKET_ERROR) {            std::cerr << "[Error] Failed to send command\n";            break;        }    }    running = false;    closesocket(tcp_sock);    listener_thread.join();    WSACleanup();    return 0;}server.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <iostream>#include <thread>#include <vector>#include <string>#include <winsock2.h>#include <mutex>#include <queue>#pragma comment(lib, "ws2_32.lib")struct ClientInfo {    sockaddr_in addr;};std::mutex canvas_mutex;std::vector<std::string> canvas_state; // Persistent canvas statestd::queue<std::string> pending_updates; // New updates to broadcaststd::mutex clients_mutex;std::vector<ClientInfo> udp_clients;bool running = true;// Thread to broadcast canvas updates via UDP to all clientsvoid udp_broadcast(SOCKET udp_sock) {    while (running) {        std::vector<std::string> updates_to_send;        // Get pending updates        {            std::lock_guard<std::mutex> lock(canvas_mutex);            while (!pending_updates.empty()) {                updates_to_send.push_back(pending_updates.front());                pending_updates.pop();            }        }        // Broadcast updates to all clients        if (!updates_to_send.empty()) {            std::lock_guard<std::mutex> lock(clients_mutex);            for (const auto& cmd : updates_to_send) {                std::cout << "[UDP Broadcast] " << cmd << " to " << udp_clients.size() << " clients\n";                for (const auto& client : udp_clients) {                    int sent = sendto(udp_sock, cmd.c_str(), (int)cmd.size(), 0,                        (sockaddr*)&client.addr, sizeof(client.addr));                    if (sent == SOCKET_ERROR) {                        std::cerr << "[Error] Failed to send to client: " << WSAGetLastError() << std::endl;                    }                }            }        }        Sleep(50);    }}// Thread to accept TCP clients and receive drawing commandsvoid tcp_listener(SOCKET tcp_sock) {    while (running) {        SOCKET client = accept(tcp_sock, nullptr, nullptr);        if (client != INVALID_SOCKET) {            std::thread([client]() {                char port_buf[16];                // First receive the UDP port from client                int n = recv(client, port_buf, sizeof(port_buf) - 1, 0);                if (n <= 0) {                    closesocket(client);                    return;                }                port_buf[n] = '\0';                int client_udp_port = atoi(port_buf);                // Determine client IP                sockaddr_in udp_addr;                int addr_len = sizeof(sockaddr_in);                getpeername(client, (sockaddr*)&udp_addr, &addr_len);                udp_addr.sin_port = htons(client_udp_port);                std::cout << "[New Client] " << inet_ntoa(udp_addr.sin_addr)                    << ":" << client_udp_port << std::endl;                // Register client for UDP                {                    std::lock_guard<std::mutex> lock(clients_mutex);                    bool exists = false;                    for (auto& c : udp_clients) {                        if (c.addr.sin_addr.s_addr == udp_addr.sin_addr.s_addr &&                            c.addr.sin_port == udp_addr.sin_port) {                            exists = true;                            break;                        }                    }                    if (!exists) {                        udp_clients.push_back({ udp_addr });                    }                }                // Send current canvas state to new client                {                    std::lock_guard<std::mutex> lock(canvas_mutex);                    for (const auto& cmd : canvas_state) {                        send(client, cmd.c_str(), (int)cmd.size(), 0);                        send(client, "\n", 1, 0); // Separator                        Sleep(10); // Small delay to avoid overwhelming the client                    }                }                // Now receive drawing commands                char buffer[256];                while (true) {                    int bytes = recv(client, buffer, sizeof(buffer) - 1, 0);                    if (bytes <= 0) break;                    buffer[bytes] = '\0';                    std::string cmd(buffer);                    std::cout << "[TCP] Received: " << cmd << std::endl;                    // Add to persistent state and pending updates                    {                        std::lock_guard<std::mutex> lock(canvas_mutex);                        canvas_state.push_back(cmd);                        pending_updates.push(cmd);                    }                }                // Remove client when disconnected                {                    std::lock_guard<std::mutex> lock(clients_mutex);                    udp_clients.erase(                        std::remove_if(udp_clients.begin(), udp_clients.end(),                            [&](const ClientInfo& c) {                                return c.addr.sin_addr.s_addr == udp_addr.sin_addr.s_addr &&                                    c.addr.sin_port == udp_addr.sin_port;                            }),                        udp_clients.end()                    );                }                std::cout << "[Client Disconnected] " << inet_ntoa(udp_addr.sin_addr)                    << ":" << client_udp_port << std::endl;                closesocket(client);                }).detach();        }    }}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    // UDP socket for broadcasting    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    // TCP socket for receiving commands    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in tcp_addr{};    tcp_addr.sin_family = AF_INET;    tcp_addr.sin_port = htons(6006);    tcp_addr.sin_addr.s_addr = INADDR_ANY;    bind(tcp_sock, (sockaddr*)&tcp_addr, sizeof(tcp_addr));    listen(tcp_sock, 5);    std::cout << "[Server] TCP listening on port 6006\n";    std::cout << "[Server] UDP broadcasting enabled\n";    // Start UDP broadcast thread    std::thread broadcast_thread(udp_broadcast, udp_sock);    // TCP listener runs in main thread    tcp_listener(tcp_sock);    running = false;    broadcast_thread.join();    closesocket(tcp_sock);    closesocket(udp_sock);    WSACleanup();    return 0;}LAB31.   The client sends periodical PING datagrams with a random content to a <server> and <port> specified in command line. The server returns back (echoes) the same packets (content). The client checks the content of the received packets to match what was sent and computes the round trip time and displays it to the user – for each sent packet.2.   Implement the Python concurrent example from lab2 to work with UDP. You no longer need threads to be able to serve multiple clients – so the implementation should be much shorter.3.   Implement a UDP-based real-time collaborative whiteboard application where multiple clients can draw on a shared canvas. The server manages the canvas state and broadcasts updates to all clients. Use drawing primitives of type line, circle, ellipse, rectangles with contour colors and eventually fill.client.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <iostream>#include <thread>#include <winsock2.h>#include <string>#include <atomic>#pragma comment(lib, "ws2_32.lib")int UDP_PORT = 0; // Will be assigned dynamicallystd::atomic<bool> running(true);// Thread to listen for UDP updates from servervoid udp_listener(int port) {    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in addr{};    addr.sin_family = AF_INET;    addr.sin_port = htons(port);    addr.sin_addr.s_addr = INADDR_ANY;    if (bind(udp_sock, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {        std::cerr << "[Error] UDP bind failed: " << WSAGetLastError() << std::endl;        return;    }    std::cout << "[UDP] Listening on port " << port << std::endl;    char buffer[256];    sockaddr_in from{};    int fromlen = sizeof(from);    // Set receive timeout    DWORD timeout = 1000; // 1 second    setsockopt(udp_sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));    while (running) {        int bytes = recvfrom(udp_sock, buffer, sizeof(buffer) - 1, 0,            (sockaddr*)&from, &fromlen);        if (bytes > 0) {            buffer[bytes] = '\0';            std::cout << "[Canvas update] " << buffer << std::endl;        }    }    closesocket(udp_sock);}// Thread to receive initial canvas state via TCPvoid tcp_receiver(SOCKET tcp_sock) {    char buffer[256];    std::string accumulated;    // Set receive timeout    DWORD timeout = 5000; // 5 seconds    setsockopt(tcp_sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));    std::cout << "[TCP] Receiving initial canvas state...\n";    while (true) {        int bytes = recv(tcp_sock, buffer, sizeof(buffer) - 1, 0);        if (bytes <= 0) {            if (WSAGetLastError() == WSAETIMEDOUT) {                std::cout << "[TCP] Canvas state received (timeout)\n";                break;            }            break;        }        buffer[bytes] = '\0';        accumulated += buffer;        // Process complete commands (separated by newlines)        size_t pos;        while ((pos = accumulated.find('\n')) != std::string::npos) {            std::string cmd = accumulated.substr(0, pos);            if (!cmd.empty()) {                std::cout << "[Initial state] " << cmd << std::endl;            }            accumulated.erase(0, pos + 1);        }    }    std::cout << "[TCP] Switched to command input mode\n";}int main(int argc, char* argv[]) {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    // Automatically assign UDP port or use provided one    if (argc > 1) {        UDP_PORT = atoi(argv[1]);    }    else {        // Create a temporary socket to get an available port        SOCKET temp_sock = socket(AF_INET, SOCK_DGRAM, 0);        sockaddr_in temp_addr{};        temp_addr.sin_family = AF_INET;        temp_addr.sin_port = 0; // Let OS assign port        temp_addr.sin_addr.s_addr = INADDR_ANY;        bind(temp_sock, (sockaddr*)&temp_addr, sizeof(temp_addr));        int addr_len = sizeof(temp_addr);        getsockname(temp_sock, (sockaddr*)&temp_addr, &addr_len);        UDP_PORT = ntohs(temp_addr.sin_port);        closesocket(temp_sock);        std::cout << "[Client] Automatically assigned UDP port: " << UDP_PORT << std::endl;    }    // Start UDP listener thread    std::thread listener_thread(udp_listener, UDP_PORT);    // TCP client for sending drawing commands    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons(6006);    server.sin_addr.s_addr = inet_addr("127.0.0.1"); // Changed to localhost for testing    std::cout << "[Client] Connecting to server...\n";    if (connect(tcp_sock, (sockaddr*)&server, sizeof(server)) != 0) {        std::cerr << "[Error] TCP connect failed: " << WSAGetLastError() << "\n";        std::cerr << "Make sure the server is running and the IP address is correct.\n";        running = false;        listener_thread.join();        WSACleanup();        return 1;    }    std::cout << "[Client] Connected to server!\n";    // Send UDP port to server    std::string port_str = std::to_string(UDP_PORT);    send(tcp_sock, port_str.c_str(), (int)port_str.size(), 0);    // Receive initial canvas state    std::thread receiver_thread(tcp_receiver, tcp_sock);    receiver_thread.join();    // Remove timeout for normal operation    DWORD timeout = 0;    setsockopt(tcp_sock, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));    std::cout << "\n[Client] Enter drawing commands:\n";    std::cout << "Examples:\n";    std::cout << "  line 10 10 100 100 red\n";    std::cout << "  circle 50 50 30 blue\n";    std::cout << "  rect 20 20 80 60 green fill\n";    std::cout << "  ellipse 100 100 40 20 yellow\n";    std::cout << "Type 'exit' to quit.\n\n";    std::string cmd;    while (running) {        std::getline(std::cin, cmd);        if (cmd == "exit") break;        if (cmd.empty()) continue;        int sent = send(tcp_sock, cmd.c_str(), (int)cmd.size(), 0);        if (sent == SOCKET_ERROR) {            std::cerr << "[Error] Failed to send command\n";            break;        }    }    running = false;    closesocket(tcp_sock);    listener_thread.join();    WSACleanup();    return 0;}server.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <iostream>#include <thread>#include <vector>#include <string>#include <winsock2.h>#include <mutex>#include <queue>#pragma comment(lib, "ws2_32.lib")struct ClientInfo {    sockaddr_in addr;};std::mutex canvas_mutex;std::vector<std::string> canvas_state; // Persistent canvas statestd::queue<std::string> pending_updates; // New updates to broadcaststd::mutex clients_mutex;std::vector<ClientInfo> udp_clients;bool running = true;// Thread to broadcast canvas updates via UDP to all clientsvoid udp_broadcast(SOCKET udp_sock) {    while (running) {        std::vector<std::string> updates_to_send;                // Get pending updates        {            std::lock_guard<std::mutex> lock(canvas_mutex);            while (!pending_updates.empty()) {                updates_to_send.push_back(pending_updates.front());                pending_updates.pop();            }        }                // Broadcast updates to all clients        if (!updates_to_send.empty()) {            std::lock_guard<std::mutex> lock(clients_mutex);            for (const auto& cmd : updates_to_send) {                std::cout << "[UDP Broadcast] " << cmd << " to " << udp_clients.size() << " clients\n";                for (const auto& client : udp_clients) {                    int sent = sendto(udp_sock, cmd.c_str(), (int)cmd.size(), 0,                        (sockaddr*)&client.addr, sizeof(client.addr));                    if (sent == SOCKET_ERROR) {                        std::cerr << "[Error] Failed to send to client: " << WSAGetLastError() << std::endl;                    }                }            }        }                Sleep(50);    }}// Thread to accept TCP clients and receive drawing commandsvoid tcp_listener(SOCKET tcp_sock) {    while (running) {        SOCKET client = accept(tcp_sock, nullptr, nullptr);        if (client != INVALID_SOCKET) {            std::thread([client]() {                char port_buf[16];                                // First receive the UDP port from client                int n = recv(client, port_buf, sizeof(port_buf) - 1, 0);                if (n <= 0) {                    closesocket(client);                    return;                }                port_buf[n] = '\0';                int client_udp_port = atoi(port_buf);                                // Determine client IP                sockaddr_in udp_addr;                int addr_len = sizeof(sockaddr_in);                getpeername(client, (sockaddr*)&udp_addr, &addr_len);                udp_addr.sin_port = htons(client_udp_port);                                std::cout << "[New Client] " << inet_ntoa(udp_addr.sin_addr)                           << ":" << client_udp_port << std::endl;                                // Register client for UDP                {                    std::lock_guard<std::mutex> lock(clients_mutex);                    bool exists = false;                    for (auto& c : udp_clients) {                        if (c.addr.sin_addr.s_addr == udp_addr.sin_addr.s_addr &&                            c.addr.sin_port == udp_addr.sin_port) {                            exists = true;                            break;                        }                    }                    if (!exists) {                        udp_clients.push_back({ udp_addr });                    }                }                                // Send current canvas state to new client                {                    std::lock_guard<std::mutex> lock(canvas_mutex);                    for (const auto& cmd : canvas_state) {                        send(client, cmd.c_str(), (int)cmd.size(), 0);                        send(client, "\n", 1, 0); // Separator                        Sleep(10); // Small delay to avoid overwhelming the client                    }                }                                // Now receive drawing commands                char buffer[256];                while (true) {                    int bytes = recv(client, buffer, sizeof(buffer) - 1, 0);                    if (bytes <= 0) break;                    buffer[bytes] = '\0';                                        std::string cmd(buffer);                    std::cout << "[TCP] Received: " << cmd << std::endl;                                        // Add to persistent state and pending updates                    {                        std::lock_guard<std::mutex> lock(canvas_mutex);                        canvas_state.push_back(cmd);                        pending_updates.push(cmd);                    }                }                                // Remove client when disconnected                {                    std::lock_guard<std::mutex> lock(clients_mutex);                    udp_clients.erase(                        std::remove_if(udp_clients.begin(), udp_clients.end(),                            [&](const ClientInfo& c) {                                return c.addr.sin_addr.s_addr == udp_addr.sin_addr.s_addr &&                                       c.addr.sin_port == udp_addr.sin_port;                            }),                        udp_clients.end()                    );                }                                std::cout << "[Client Disconnected] " << inet_ntoa(udp_addr.sin_addr)                           << ":" << client_udp_port << std::endl;                                closesocket(client);            }).detach();        }    }}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);        // UDP socket for broadcasting    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);        // TCP socket for receiving commands    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);        sockaddr_in tcp_addr{};    tcp_addr.sin_family = AF_INET;    tcp_addr.sin_port = htons(6006);    tcp_addr.sin_addr.s_addr = INADDR_ANY;        bind(tcp_sock, (sockaddr*)&tcp_addr, sizeof(tcp_addr));    listen(tcp_sock, 5);        std::cout << "[Server] TCP listening on port 6006\n";    std::cout << "[Server] UDP broadcasting enabled\n";        // Start UDP broadcast thread    std::thread broadcast_thread(udp_broadcast, udp_sock);        // TCP listener runs in main thread    tcp_listener(tcp_sock);        running = false;    broadcast_thread.join();        closesocket(tcp_sock);    closesocket(udp_sock);    WSACleanup();        return 0;}4.   Implement the Chat server example (see the link bellow) using UDP and TCP –only this time each client should contact the server just for registration. All communication happens directly between the peers (clients) without passing trough the server. Each client maintains an endpoint (TCP/UDP) with the server just for learning the arrival/departure of other clients. You create a mesh architecture where all clients connect directly between each others.client.c// client.cpp// Interactive terminal version — asks for name and UDP port at runtime.// Uses TCP for registration and UDP for direct chat.#include <winsock2.h>#include <ws2tcpip.h>#include <iostream>#include <sstream>#include <string>#include <vector>#include <thread>#include <mutex>#include <algorithm>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_PORT "5000"#define BUF_SIZE 1024struct Peer {    std::string name;    std::string ip;    std::string port;    sockaddr_in addr;};std::vector<Peer> peers;std::mutex peer_mutex;SOCKET udp_sock = INVALID_SOCKET;void udp_recv_thread() {    char buf[BUF_SIZE];    sockaddr_in from{};    int fromlen = sizeof(from);    while (true) {        int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);        if (r <= 0) continue;        buf[r] = '\0';        std::cout << "[PEER] " << buf << std::endl;    }}void server_recv_thread(SOCKET srv_sock) {    std::string recvbuf;    char buf[BUF_SIZE];    while (true) {        int r = recv(srv_sock, buf, sizeof(buf), 0);        if (r <= 0) {            std::cout << "Server connection closed\n";            return;        }        recvbuf.append(buf, buf + r);        size_t pos;        while ((pos = recvbuf.find('\n')) != std::string::npos) {            std::string line = recvbuf.substr(0, pos);            if (!line.empty() && line.back() == '\r') line.pop_back();            recvbuf.erase(0, pos + 1);            std::istringstream iss(line);            std::string cmd;            iss >> cmd;            if (cmd == "NEW") {                Peer p;                iss >> p.name >> p.ip >> p.port;                if (p.name.empty() || p.ip.empty() || p.port.empty()) continue;                p.addr.sin_family = AF_INET;                p.addr.sin_port = htons((u_short)atoi(p.port.c_str()));                inet_pton(AF_INET, p.ip.c_str(), &p.addr.sin_addr);                {                    std::lock_guard<std::mutex> lock(peer_mutex);                    auto it = std::find_if(peers.begin(), peers.end(), [&](const Peer& q) { return q.name == p.name; });                    if (it == peers.end()) peers.push_back(p);                }                std::cout << "[SERVER] New peer: " << p.name << " " << p.ip << ":" << p.port << std::endl;            }            else if (cmd == "LEFT") {                std::string name;                iss >> name;                std::lock_guard<std::mutex> lock(peer_mutex);                peers.erase(std::remove_if(peers.begin(), peers.end(), [&](const Peer& q) { return q.name == name; }), peers.end());                std::cout << "[SERVER] Peer left: " << name << std::endl;            }        }    }}int main() {    std::string name, udp_port;    std::cout << "Enter your name: ";    std::getline(std::cin, name);    std::cout << "Enter UDP port (e.g. 7001): ";    std::getline(std::cin, udp_port);    if (name.empty() || udp_port.empty()) {        std::cerr << "Name and UDP port are required.\n";        return 1;    }    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        std::cerr << "WSAStartup failed.\n";        return 1;    }    // UDP socket for peer-to-peer chat    udp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    sockaddr_in myaddr{};    myaddr.sin_family = AF_INET;    myaddr.sin_addr.s_addr = INADDR_ANY;    myaddr.sin_port = htons((u_short)atoi(udp_port.c_str()));    if (bind(udp_sock, (sockaddr*)&myaddr, sizeof(myaddr)) != 0) {        std::cerr << "Failed to bind UDP socket. Try another port.\n";        return 1;    }    std::thread(udp_recv_thread).detach();    // TCP connection to server    addrinfo hints{}, * res;    hints.ai_family = AF_INET;    hints.ai_socktype = SOCK_STREAM;    if (getaddrinfo(SERVER_IP, SERVER_PORT, &hints, &res) != 0) {        std::cerr << "getaddrinfo failed.\n";        return 1;    }    SOCKET srv_sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);    if (connect(srv_sock, res->ai_addr, (int)res->ai_addrlen) != 0) {        std::cerr << "Failed to connect to server.\n";        freeaddrinfo(res);        return 1;    }    freeaddrinfo(res);    // Register with server    std::string reg = "REGISTER " + name + " " + udp_port + "\n";    send(srv_sock, reg.c_str(), (int)reg.size(), 0);    std::thread(server_recv_thread, srv_sock).detach();    std::cout << "\nConnected to server.\n";    std::cout << "Type messages to send via UDP (type /quit to exit)\n\n";    std::string line;    while (std::getline(std::cin, line)) {        if (line == "/quit") break;        std::lock_guard<std::mutex> lock(peer_mutex);        for (auto& p : peers) {            sendto(udp_sock, line.c_str(), (int)line.size(), 0,                (sockaddr*)&p.addr, sizeof(p.addr));        }    }    std::string unreg = "UNREGISTER " + name + "\n";    send(srv_sock, unreg.c_str(), (int)unreg.size(), 0);    closesocket(srv_sock);    closesocket(udp_sock);    WSACleanup();    return 0;}server.c// server.cpp// TCP registration server using Winsock2 + std::thread (C++)// Robust line-oriented parsing: accumulate TCP stream and process full lines.#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <iostream>#include <string>#include <vector>#include <thread>#include <mutex>#include <sstream>#include <algorithm>#pragma comment(lib, "Ws2_32.lib")#define TCP_PORT "5000"#define BUF_SIZE 1024struct ClientInfo {    SOCKET sock;    std::string name;    std::string ip;    std::string udp_port;    bool active;};std::vector<ClientInfo> clients;std::mutex client_mutex;void broadcast(const std::string& msg, SOCKET exclude = INVALID_SOCKET) {    std::lock_guard<std::mutex> lock(client_mutex);    for (auto& c : clients) {        if (c.active && c.sock != exclude) {            send(c.sock, msg.c_str(), (int)msg.size(), 0);        }    }}void mark_client_left_and_broadcast(SOCKET s) {    std::lock_guard<std::mutex> lock(client_mutex);    for (auto& c : clients) {        if (c.sock == s && c.active) {            std::string left_msg = "LEFT " + c.name + "\n";            std::cout << left_msg;            // mark inactive            c.active = false;            // broadcast after marking            broadcast(left_msg, INVALID_SOCKET);            closesocket(c.sock);            return;        }    }}void handle_client(SOCKET client_sock) {    std::string recvbuf;                 // accumulate bytes from recv()    char buf[BUF_SIZE];    // First read until we get a REGISTER line, but handle general stream:    while (true) {        int r = recv(client_sock, buf, (int)sizeof(buf), 0);        if (r <= 0) {            // peer closed or error            mark_client_left_and_broadcast(client_sock);            return;        }        recvbuf.append(buf, buf + r);        // process complete lines        size_t pos;        while ((pos = recvbuf.find('\n')) != std::string::npos) {            std::string line = recvbuf.substr(0, pos);            // strip trailing '\r' if present            if (!line.empty() && line.back() == '\r') line.pop_back();            recvbuf.erase(0, pos + 1);            // parse the line using istringstream (robust tokenization)            std::istringstream iss(line);            std::string cmd;            iss >> cmd;            if (cmd == "REGISTER") {                std::string name, udp_port;                iss >> name >> udp_port;                if (name.empty() || udp_port.empty()) {                    // invalid register line -- ignore or optionally send error                    std::string em = "ERROR invalid REGISTER\n";                    send(client_sock, em.c_str(), (int)em.size(), 0);                    continue;                }                sockaddr_in addr; int alen = sizeof(addr);                getpeername(client_sock, (sockaddr*)&addr, &alen);                std::string ip = inet_ntoa(addr.sin_addr);                {                    std::lock_guard<std::mutex> lock(client_mutex);                    clients.push_back({ client_sock, name, ip, udp_port, true });                }                // Send existing peers to new client                {                    std::lock_guard<std::mutex> lock(client_mutex);                    for (auto& c : clients) {                        if (c.active && c.sock != client_sock) {                            std::string msg = "NEW " + c.name + " " + c.ip + " " + c.udp_port + "\n";                            send(client_sock, msg.c_str(), (int)msg.size(), 0);                        }                    }                }                // Broadcast new client to others                std::string join_msg = "NEW " + name + " " + ip + " " + udp_port + "\n";                broadcast(join_msg, client_sock);                std::cout << "Registered " << name << " @ " << ip << ":" << udp_port << std::endl;            }            else if (cmd == "UNREGISTER") {                std::string name;                iss >> name;                if (!name.empty()) {                    std::lock_guard<std::mutex> lock(client_mutex);                    for (auto& c : clients) {                        if (c.active && c.name == name) {                            c.active = false;                            closesocket(c.sock);                            std::string left_msg = "LEFT " + name + "\n";                            broadcast(left_msg, INVALID_SOCKET);                            std::cout << "Unregistered " << name << std::endl;                            break;                        }                    }                }            }            else {                // any other command/data: ignore or extend protocol            }        }        // continue reading more bytes    }}int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        std::cerr << "WSAStartup failed\n"; return 1;    }    addrinfo hints{};    hints.ai_family = AF_INET;    hints.ai_socktype = SOCK_STREAM;    hints.ai_flags = AI_PASSIVE;    addrinfo* res = NULL;    if (getaddrinfo(NULL, TCP_PORT, &hints, &res) != 0) {        std::cerr << "getaddrinfo failed\n"; return 1;    }    SOCKET listen_sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);    if (listen_sock == INVALID_SOCKET) { std::cerr << "socket failed\n"; return 1; }    if (bind(listen_sock, res->ai_addr, (int)res->ai_addrlen) == SOCKET_ERROR) {        std::cerr << "bind failed\n"; return 1;    }    freeaddrinfo(res);    if (listen(listen_sock, 10) == SOCKET_ERROR) {        std::cerr << "listen failed\n"; return 1;    }    std::cout << "Server listening on TCP port " << TCP_PORT << std::endl;    while (true) {        SOCKET client_sock = accept(listen_sock, NULL, NULL);        if (client_sock == INVALID_SOCKET) {            std::cerr << "accept failed\n";            continue;        }        // spawn detached thread to handle stream parsing        std::thread(handle_client, client_sock).detach();    }    closesocket(listen_sock);    WSACleanup();    return 0;}5.      Write an UDP broadcast application that serves as client and server at the same time. The application is started with the network broadcast address (<NBCAST>) as argument in the command line.1.       Upon launching the application listens on UDP port 7777.2.    Every 3 seconds the application sends a UDP broadcast message to NBCAST port 7777 with the format: TIMEQUERY\0 (string)3.    Whenever the application receives a TIMEQUERY demand it answers to the source IP:port with a string message: TIME HH:MM:SS\0 (current time) using unicast.4.    Every 10 seconds the application sends a UDP broadcast message to NBCAST port 7777 with the format:  DATEQUERY\0 (string)5.    Whenever the application receives a DATEQUERY demand it answers to the source IP:port with a string message: DATE DD:MM:YYYY\0 (current date) using unicast.6.    The application will keep a list of peers (that answer to broadcast – IP:portno) and update the information anytime a unicast message is received upon a broadcast.7.    When an entry in a list does not have any answer for 3 consecutive broadcasts it will be removed from the list.8.    The list will be displayed (ip,date, time) on the screen upon each update (using a screen positioning api like conio or by erasing the screen before each update).9.    Every malformed request/response received will be counted and displayed at the end of a screen update. You will have a list of malformed messages displayed with their source IP address. The list should be limited in size and implemented as a queue. Recent messages are added to the head and old messages are moving towards the tail. #define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#include <ws2tcpip.h>#include <time.h>#include <thread>       #include <chrono>       #include <string.h>#include <stdlib.h>#pragma comment(lib, "ws2_32.lib")#define PORT 7777SOCKET sock;const char* peerIPs[] = {    "10.51.0.182", "10.51.1.126"};int peerCount = 2;void receiver_thread() {    struct sockaddr_in from;    int fromlen = sizeof(from);    char buf[128];    while (1) {        int bytes = recvfrom(sock, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&from, &fromlen);        if (bytes > 0) {            buf[bytes] = '\0';            char* srcip = inet_ntoa(from.sin_addr);            if (strcmp(buf, "TIMEQUERY") == 0) {                time_t now = time(NULL);                struct tm* t = localtime(&now);                char msg[64];                sprintf(msg, "TIME %02d:%02d:%02d", t->tm_hour, t->tm_min, t->tm_sec);                sendto(sock, msg, strlen(msg) + 1, 0, (struct sockaddr*)&from, fromlen);                printf("Received TIMEQUERY from %s -> Sent TIME\n", srcip);            }            else if (strcmp(buf, "DATEQUERY") == 0) {                time_t now = time(NULL);                struct tm* t = localtime(&now);                char msg[64];                sprintf(msg, "DATE %02d:%02d:%04d", t->tm_mday, t->tm_mon + 1, t->tm_year + 1900);                sendto(sock, msg, strlen(msg) + 1, 0, (struct sockaddr*)&from, fromlen);                printf("Received DATEQUERY from %s -> Sent DATE\n", srcip);            }            else if (strncmp(buf, "TIME ", 5) == 0 || strncmp(buf, "DATE ", 5) == 0) {                printf("Reply from %s: %s\n", srcip, buf);            }            else {                printf("Malformed from %s: %s\n", srcip, buf);            }        }    }}void sender_thread() {    struct sockaddr_in dest;    dest.sin_family = AF_INET;    dest.sin_port = htons(PORT);    int counter = 0;    while (1) {        std::this_thread::sleep_for(std::chrono::seconds(1));        counter++;        if (counter % 3 == 0) {            for (int i = 0; i < peerCount; i++) {                dest.sin_addr.s_addr = inet_addr(peerIPs[i]);                sendto(sock, "TIMEQUERY", 10, 0, (struct sockaddr*)&dest, sizeof(dest));            }            printf("Sent TIMEQUERY to peers.\n");        }        if (counter % 10 == 0) {            for (int i = 0; i < peerCount; i++) {                dest.sin_addr.s_addr = inet_addr(peerIPs[i]);                sendto(sock, "DATEQUERY", 10, 0, (struct sockaddr*)&dest, sizeof(dest));            }            printf("Sent DATEQUERY to peers.\n");        }    }}int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed.\n");        return 1;    }    sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) {        printf("Socket creation failed.\n");        WSACleanup();        return 1;    }    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(PORT);    addr.sin_addr.s_addr = INADDR_ANY;    if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {        printf("Bind failed.\n");        closesocket(sock);        WSACleanup();        return 1;    }    printf("UDP Peer running on port %d\n", PORT);    std::thread recvThread(receiver_thread);    std::thread sendThread(sender_thread);    recvThread.join();    sendThread.join();    closesocket(sock);    WSACleanup();    return 0;}-----------------------// udp_peer_win.cpp// Windows UDP peer application:// - Listens on UDP port 7777// - Sends TIMEQUERY every 3s, DATEQUERY every 10s using CreateTimerQueueTimer// - Replies to TIMEQUERY/DATEQUERY with unicast TIME/DATE// - Maintains peer list and malformed queue// - Uses std::thread and std::mutex for concurrency//// Build with Visual Studio (x64/x86), C++17 or newer.#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <windows.h>#include <iostream>#include <vector>#include <string>#include <mutex>#include <thread>#include <chrono>#include <ctime>#include <algorithm>#pragma comment(lib, "ws2_32.lib")constexpr int PORT = 7777;constexpr int MAX_MALFORMED = 20;constexpr int MAX_PEERS = 100;// ----- Data structures -----struct Peer {    std::string ip;    std::string date; // "DD:MM:YYYY" or "-"    std::string time; // "HH:MM:SS" or "-"    int missed = 0;   // counts consecutive TIME broadcasts with NO reply};struct MalformedMsg {    std::string ip;    std::string msg;    std::string when; // timestamp of reception};// ----- Globals -----SOCKET g_sock = INVALID_SOCKET;std::vector<std::string> peerIPs = {    // Put your peers here. Example:    "10.51.0.182"    // "192.168.1.100",    // "192.168.1.101"};std::vector<Peer> peers;std::vector<MalformedMsg> malformed; // recent firststd::mutex mtx;HANDLE g_timerQueue = nullptr;HANDLE g_timeTimer = nullptr; // every 3sHANDLE g_dateTimer = nullptr; // every 10s// ----- Utility functions -----static std::string now_time_str() {    time_t t = time(nullptr);    tm local_tm;    localtime_s(&local_tm, &t);    char buf[16];    sprintf_s(buf, "%02d:%02d:%02d", local_tm.tm_hour, local_tm.tm_min, local_tm.tm_sec);    return std::string(buf);}static std::string now_date_str() {    time_t t = time(nullptr);    tm local_tm;    localtime_s(&local_tm, &t);    char buf[16];    sprintf_s(buf, "%02d:%02d:%04d", local_tm.tm_mday, local_tm.tm_mon + 1, local_tm.tm_year + 1900);    return std::string(buf);}void display_status_locked() {    // assumes mtx is locked#ifdef _WIN32    system("cls");#else    system("clear");#endif    std::cout << "===== PEERS (ip, date, time, missed) =====\n";    for (const auto& p : peers) {        std::cout << p.ip << " | Date: " << p.date << " | Time: " << p.time << " | Missed: " << p.missed << "\n";    }    std::cout << "\n===== MALFORMED MESSAGES (recent first) =====\n";    for (const auto& m : malformed) {        std::cout << "[" << m.when << "] " << m.ip << " -> " << m.msg << "\n";    }    std::cout << "\n(Press Ctrl+C to exit)\n";}void display_status() {    std::lock_guard<std::mutex> lock(mtx);    display_status_locked();}void add_or_update_peer_on_response(const std::string& ip, const std::string& datePart, const std::string& timePart) {    std::lock_guard<std::mutex> lock(mtx);    // Look for peer    for (auto& p : peers) {        if (p.ip == ip) {            if (!datePart.empty() && datePart != "-") p.date = datePart;            if (!timePart.empty() && timePart != "-") p.time = timePart;            p.missed = 0;            display_status_locked();            return;        }    }    // Add new    if ((int)peers.size() < MAX_PEERS) {        Peer np;        np.ip = ip;        np.date = datePart.empty() ? "-" : datePart;        np.time = timePart.empty() ? "-" : timePart;        np.missed = 0;        peers.push_back(np);    }    display_status_locked();}void add_malformed(const std::string& ip, const std::string& msg) {    std::lock_guard<std::mutex> lock(mtx);    MalformedMsg mm;    mm.ip = ip;    mm.msg = msg;    mm.when = now_time_str();    // Insert at head (recent first). If full, drop tail.    malformed.insert(malformed.begin(), mm);    if ((int)malformed.size() > MAX_MALFORMED) malformed.pop_back();    display_status_locked();}// Called after sending TIMEQUERY: increase missed counters and remove peers with missed >= 3void increment_missed_and_prune() {    std::lock_guard<std::mutex> lock(mtx);    for (auto& p : peers) p.missed++;    // remove those with missed >= 3    peers.erase(std::remove_if(peers.begin(), peers.end(),        [](const Peer& p) { return p.missed >= 3; }), peers.end());    display_status_locked();}// ----- Send helpers -----void send_to_peer_ip(const char* ip, const char* message) {    sockaddr_in dest{};    dest.sin_family = AF_INET;    dest.sin_port = htons(PORT);    dest.sin_addr.s_addr = inet_addr(ip);    int len = (int)strlen(message) + 1; // include null per protocol    int s = sendto(g_sock, message, len, 0, (sockaddr*)&dest, sizeof(dest));    (void)s; // ignore errors for brevity; could log}// ----- Callbacks for timers -----// Time timer: every 3s -> send TIMEQUERY to all peers and increment missed & pruneVOID CALLBACK TimeTimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {    (void)TimerOrWaitFired;    (void)lpParameter;    // Send TIMEQUERY to all peerIPs    for (const auto& ip : peerIPs) {        send_to_peer_ip(ip.c_str(), "TIMEQUERY");    }    // After sending, increment missed (they must reply to reset)    increment_missed_and_prune();}// Date timer: every 10s -> send DATEQUERY to all peersVOID CALLBACK DateTimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {    (void)TimerOrWaitFired;    (void)lpParameter;    for (const auto& ip : peerIPs) {        send_to_peer_ip(ip.c_str(), "DATEQUERY");    }}// ----- Receiver thread -----void receiver_loop() {    char buf[512];    sockaddr_in from;    int fromlen = sizeof(from);    while (true) {        int bytes = recvfrom(g_sock, buf, (int)sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);        if (bytes == SOCKET_ERROR) {            int err = WSAGetLastError();            // If socket closed/etc, break            std::cerr << "recvfrom error: " << err << "\n";            break;        }        if (bytes <= 0) continue;        buf[bytes] = '\0';        char* srcIpC = inet_ntoa(from.sin_addr);        std::string srcIp = srcIpC ? srcIpC : "unknown";        std::string msg(buf);        // Determine if message is a request or a response        if (msg == "TIMEQUERY") {            // Reply with unicast TIME HH:MM:SS\0            std::string t = now_time_str();            char out[64];            sprintf_s(out, "TIME %s", t.c_str());            sendto(g_sock, out, (int)strlen(out) + 1, 0, (sockaddr*)&from, fromlen);            // no peer update needed (request)            {                std::lock_guard<std::mutex> lock(mtx);                // display a log (not required by spec but helpful)                display_status_locked();            }        }        else if (msg == "DATEQUERY") {            std::string d = now_date_str();            char out[64];            sprintf_s(out, "DATE %s", d.c_str());            sendto(g_sock, out, (int)strlen(out) + 1, 0, (sockaddr*)&from, fromlen);            {                std::lock_guard<std::mutex> lock(mtx);                display_status_locked();            }        }        else if (msg.rfind("TIME ", 0) == 0) {            // Response: "TIME HH:MM:SS"            std::string timePart = msg.substr(5);            add_or_update_peer_on_response(srcIp, "-", timePart);        }        else if (msg.rfind("DATE ", 0) == 0) {            // Response: "DATE DD:MM:YYYY"            std::string datePart = msg.substr(5);            add_or_update_peer_on_response(srcIp, datePart, "-");        }        else {            // malformed            add_malformed(srcIp, msg);        }    }}// ----- Setup socket -----// returns true on successbool setup_socket_and_options() {    // create socket    g_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    if (g_sock == INVALID_SOCKET) {        std::cerr << "socket() failed: " << WSAGetLastError() << "\n";        return false;    }    // allow broadcast (so program can broadcast if needed)    BOOL broadcast = TRUE;    if (setsockopt(g_sock, SOL_SOCKET, SO_BROADCAST, (const char*)&broadcast, sizeof(broadcast)) == SOCKET_ERROR) {        std::cerr << "setsockopt(SO_BROADCAST) failed: " << WSAGetLastError() << "\n";        // not fatal, continue    }    // optional: allow reuse of address    BOOL reuse = TRUE;    if (setsockopt(g_sock, SOL_SOCKET, SO_REUSEADDR, (const char*)&reuse, sizeof(reuse)) == SOCKET_ERROR) {        // not fatal    }    // bind to port 7777 on all interfaces    sockaddr_in addr{};    addr.sin_family = AF_INET;    addr.sin_port = htons(PORT);    addr.sin_addr.S_un.S_addr = INADDR_ANY;    if (bind(g_sock, (sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {        std::cerr << "bind() failed: " << WSAGetLastError() << "\n";        closesocket(g_sock);        g_sock = INVALID_SOCKET;        return false;    }    return true;}// ----- Main -----int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        std::cerr << "WSAStartup failed\n";        return 1;    }    if (!setup_socket_and_options()) {        WSACleanup();        return 1;    }    // Create timer queue    g_timerQueue = CreateTimerQueue();    if (g_timerQueue == nullptr) {        std::cerr << "CreateTimerQueue failed: " << GetLastError() << "\n";        closesocket(g_sock);        WSACleanup();        return 1;    }    // Create TIME timer (every 3000 ms)    if (!CreateTimerQueueTimer(&g_timeTimer, g_timerQueue, TimeTimerCallback, nullptr, 0, 3000, 0)) {        std::cerr << "CreateTimerQueueTimer (time) failed: " << GetLastError() << "\n";    }    // Create DATE timer (every 10000 ms)    if (!CreateTimerQueueTimer(&g_dateTimer, g_timerQueue, DateTimerCallback, nullptr, 0, 10000, 0)) {        std::cerr << "CreateTimerQueueTimer (date) failed: " << GetLastError() << "\n";    }    // Start receiver thread (this blocks until program exits)    std::thread recvThread(receiver_loop);    // Initial display    display_status();    // Main thread waits for receiver to finish (in practice Ctrl+C)    recvThread.join();    // Cleanup timers & socket (unreachable in normal Ctrl+C exit, but included for completeness)    if (g_timeTimer) DeleteTimerQueueTimer(g_timerQueue, g_timeTimer, nullptr);    if (g_dateTimer) DeleteTimerQueueTimer(g_timerQueue, g_dateTimer, nullptr);    if (g_timerQueue) DeleteTimerQueue(g_timerQueue);    if (g_sock != INVALID_SOCKET) {        closesocket(g_sock);        g_sock = INVALID_SOCKET;    }    WSACleanup();    return 0;}#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <stdio.h>#include <winsock2.h>#include <ws2tcpip.h>#include <time.h>#include <thread>       #include <chrono>       #include <string.h>#include <stdlib.h> #pragma comment(lib, "ws2_32.lib") #define PORT 7777 SOCKET sock; const char* peerIPs[] = {    "10.51.0.182"};int peerCount = 1; void receiver_thread() {    struct sockaddr_in from;    int fromlen = sizeof(from);    char buf[128];     while (1) {        int bytes = recvfrom(sock, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&from, &fromlen);        if (bytes > 0) {            buf[bytes] = '\0';            char* srcip = inet_ntoa(from.sin_addr);             if (strcmp(buf, "TIMEQUERY") == 0) {                time_t now = time(NULL);                struct tm* t = localtime(&now);                char msg[64];                sprintf(msg, "TIME %02d:%02d:%02d", t->tm_hour, t->tm_min, t->tm_sec);                sendto(sock, msg, strlen(msg) + 1, 0, (struct sockaddr*)&from, fromlen);                printf("Received TIMEQUERY from %s -> Sent TIME\n", srcip);            }            else if (strcmp(buf, "DATEQUERY") == 0) {                time_t now = time(NULL);                struct tm* t = localtime(&now);                char msg[64];                sprintf(msg, "DATE %02d:%02d:%04d", t->tm_mday, t->tm_mon + 1, t->tm_year + 1900);                sendto(sock, msg, strlen(msg) + 1, 0, (struct sockaddr*)&from, fromlen);                printf("Received DATEQUERY from %s -> Sent DATE\n", srcip);            }            else if (strncmp(buf, "TIME ", 5) == 0 || strncmp(buf, "DATE ", 5) == 0) {                printf("Reply from %s: %s\n", srcip, buf);            }            else {                printf("Malformed from %s: %s\n", srcip, buf);            }        }    }} void sender_thread() {    struct sockaddr_in dest;    dest.sin_family = AF_INET;    dest.sin_port = htons(PORT);     int counter = 0;    while (1) {        std::this_thread::sleep_for(std::chrono::seconds(1));        counter++;         if (counter % 3 == 0) {            //for (int i = 0; i < peerCount; i++) {            dest.sin_addr.s_addr = inet_addr("10.51.7.255");                sendto(sock, "TIMEQUERY", 10, 0, (struct sockaddr*)&dest, sizeof(dest));            //}            printf("Sent TIMEQUERY to peers.\n");        }         if (counter % 10 == 0) {            //for (int i = 0; i < peerCount; i++) {                dest.sin_addr.s_addr = inet_addr("10.51.7.255");                sendto(sock, "DATEQUERY", 10, 0, (struct sockaddr*)&dest, sizeof(dest));            //}            printf("Sent DATEQUERY to peers.\n");        }    }} int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed.\n");        return 1;    }     sock = socket(AF_INET, SOCK_DGRAM, 0);    if (sock == INVALID_SOCKET) {        printf("Socket creation failed.\n");        WSACleanup();        return 1;    }    char broadcast = '1';      //     This option is needed on the socket in order to be able to receive broadcast messages     //   If not set the receiver will not receive broadcast messages in the local network.     if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast)) < 0) { exit(0); }    struct sockaddr_in addr;    addr.sin_family = AF_INET;    addr.sin_port = htons(PORT);    addr.sin_addr.s_addr = INADDR_ANY;     if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {        printf("Bind failed.\n");        closesocket(sock);        WSACleanup();        return 1;    }     printf("UDP Peer running on port %d\n", PORT);     std::thread recvThread(receiver_thread);    std::thread sendThread(sender_thread);     recvThread.join();    sendThread.join();     closesocket(sock);    WSACleanup();    return 0;} Write a pair of TCP/IP applications (SERVER, CLIENT) where each CLIENT connects to the SERVER on port 7000 over TCP. The server keeps a list of all connected CLIENTS (ip and port) and sends that list to each CLIENT upon connection. The server also sends incremental changes to the list to each of the connected CLIENTS whenever a new CLIENT arrives or when a CLIENT closes its TCP connection to the server. Each CLIENT reads messages from the standard input and sends that message over UDP to all the other CLIENTS registered to the server (the list is kept by each CLIENT and updated by the SERVER). Users can type in messages at the standard input and each message will be sent by the CLIENT to all other registered CLIENTS through UDP. Whenever the user enters a message with the content “QUIT” - that CLIENT disconnects its TCP connection from the SERVER and closes its UDP socket (the “QUIT” message is not sent to all other clients). Upon receiving a list incremental update, each CLIENT displays a message stating the client action (Ex: : Client 192.168.0.3:5000 has disconnected” or “Client 192.168.0.3:5000 has connected”)  server.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <thread>#include <vector>#include <mutex>#include <cstdio>#include <cstdlib>#include <cstring>#pragma comment(lib, "ws2_32.lib")struct ClientInfo {    char ip[32];    int udp_port;    SOCKET tcp_sock;};std::vector<ClientInfo> clients;std::mutex clients_mutex;void broadcast(const char* msg, SOCKET exclude_sock = INVALID_SOCKET) {    std::lock_guard<std::mutex> lock(clients_mutex);    for (const auto& c : clients) {        if (c.tcp_sock != exclude_sock) {            send(c.tcp_sock, msg, (int)strlen(msg), 0);        }    }}void send_client_list(SOCKET sock) {    std::lock_guard<std::mutex> lock(clients_mutex);    char buf[1024] = "LIST ";    for (const auto& c : clients) {        char tmp[64];        sprintf(tmp, "%s:%d ", c.ip, c.udp_port);        strcat(buf, tmp);    }    send(sock, buf, (int)strlen(buf), 0);}void handle_client(SOCKET client_sock) {    char buffer[512] = { 0 };    // Receive client's UDP port number first    int bytes = recv(client_sock, buffer, sizeof(buffer) - 1, 0);    if (bytes <= 0) {        closesocket(client_sock);        return;    }    int udp_port = atoi(buffer);    sockaddr_in addr{};    int len = sizeof(addr);    getpeername(client_sock, (sockaddr*)&addr, &len);    char* ip = inet_ntoa(addr.sin_addr);    ClientInfo info;    strcpy(info.ip, ip);    info.udp_port = udp_port;    info.tcp_sock = client_sock;    {        std::lock_guard<std::mutex> lock(clients_mutex);        clients.push_back(info);    }    printf("Client %s:%d connected.\n", ip, udp_port);    // Send the full list to this client    send_client_list(client_sock);    // Notify others    char join_msg[128];    sprintf(join_msg, "JOIN %s:%d", ip, udp_port);    broadcast(join_msg, client_sock);    // Keep receiving until client disconnects    while (true) {        int r = recv(client_sock, buffer, sizeof(buffer) - 1, 0);        if (r <= 0) break;  // disconnected    }    // Remove from list    {        std::lock_guard<std::mutex> lock(clients_mutex);        for (auto it = clients.begin(); it != clients.end(); ++it) {            if (it->tcp_sock == client_sock) {                clients.erase(it);                break;            }        }    }    printf("Client %s:%d disconnected.\n", ip, udp_port);    char leave_msg[128];    sprintf(leave_msg, "LEAVE %s:%d", ip, udp_port);    broadcast(leave_msg, client_sock);    closesocket(client_sock);}int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("Failed to initialize Winsock.\n");        return 1;    }    SOCKET server_sock = socket(AF_INET, SOCK_STREAM, 0);    if (server_sock == INVALID_SOCKET) {        printf("Socket creation failed.\n");        WSACleanup();        return 1;    }    sockaddr_in server_addr{};    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = INADDR_ANY;    server_addr.sin_port = htons(7000);    if (bind(server_sock, (sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed.\n");        closesocket(server_sock);        WSACleanup();        return 1;    }    listen(server_sock, 5);    printf("Server listening on port 7000...\n");    while (true) {        sockaddr_in client_addr{};        int len = sizeof(client_addr);        SOCKET client_sock = accept(server_sock, (sockaddr*)&client_addr, &len);        if (client_sock != INVALID_SOCKET) {            std::thread(handle_client, client_sock).detach();        }    }    closesocket(server_sock);    WSACleanup();    return 0;}clientcpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <thread>#include <vector>#include <mutex>#include <cstdio>#include <cstdlib>#include <cstring>#pragma comment(lib, "ws2_32.lib")struct Peer {    char ip[32];    int port;};std::vector<Peer> peers;std::mutex peers_mutex;SOCKET udp_sock;void udp_receive_thread() {    char buf[512];    sockaddr_in from;    int fromlen = sizeof(from);    while (true) {        int bytes = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);        if (bytes > 0) {            buf[bytes] = '\0';            printf("UDP from %s:%d -> %s\n", inet_ntoa(from.sin_addr), ntohs(from.sin_port), buf);        }    }}void tcp_listener(SOCKET sock) {    char buf[512];    while (true) {        int bytes = recv(sock, buf, sizeof(buf) - 1, 0);        if (bytes <= 0) break;        buf[bytes] = '\0';        if (strncmp(buf, "LIST ", 5) == 0) {            std::lock_guard<std::mutex> lock(peers_mutex);            peers.clear();            char* token = strtok(buf + 5, " ");            while (token) {                Peer p;                sscanf(token, "%[^:]:%d", p.ip, &p.port);                peers.push_back(p);                token = strtok(NULL, " ");            }            printf("Updated peer list (%zu peers)\n", peers.size());        }        else if (strncmp(buf, "JOIN ", 5) == 0) {            Peer p;            sscanf(buf + 5, "%[^:]:%d", p.ip, &p.port);            {                std::lock_guard<std::mutex> lock(peers_mutex);                peers.push_back(p);            }            printf("Client %s:%d has connected\n", p.ip, p.port);        }        else if (strncmp(buf, "LEAVE ", 6) == 0) {            char ip[32];            int port;            sscanf(buf + 6, "%[^:]:%d", ip, &port);            std::lock_guard<std::mutex> lock(peers_mutex);            for (auto it = peers.begin(); it != peers.end(); ++it) {                if (strcmp(it->ip, ip) == 0 && it->port == port) {                    peers.erase(it);                    break;                }            }            printf("Client %s:%d has disconnected\n", ip, port);        }    }    printf("Server closed TCP connection.\n");}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    if (tcp_sock == INVALID_SOCKET) {        printf("TCP socket creation failed.\n");        return 1;    }    char server_ip[32];    printf("Enter server IP: ");    scanf("%s", server_ip);    sockaddr_in server_addr{};    server_addr.sin_family = AF_INET;    server_addr.sin_port = htons(7000);    server_addr.sin_addr.s_addr = inet_addr(server_ip);    if (connect(tcp_sock, (sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Failed to connect to server.\n");        closesocket(tcp_sock);        WSACleanup();        return 1;    }    // Setup UDP socket    udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in local_addr{};    local_addr.sin_family = AF_INET;    local_addr.sin_addr.s_addr = INADDR_ANY;    local_addr.sin_port = 0;  // Let system choose port    bind(udp_sock, (sockaddr*)&local_addr, sizeof(local_addr));    sockaddr_in temp;    int len = sizeof(temp);    getsockname(udp_sock, (sockaddr*)&temp, &len);    int udp_port = ntohs(temp.sin_port);    // Send our UDP port to the server via TCP    char port_str[16];    sprintf(port_str, "%d", udp_port);    send(tcp_sock, port_str, (int)strlen(port_str), 0);    printf("Connected to server. My UDP port: %d\n", udp_port);    std::thread tcp_thread(tcp_listener, tcp_sock);    std::thread udp_thread(udp_receive_thread);    char msg[512];    while (true) {        printf("> ");        scanf(" %[^\n]", msg);        if (strcmp(msg, "QUIT") == 0) break;        std::lock_guard<std::mutex> lock(peers_mutex);        for (const auto& p : peers) {            sockaddr_in peer_addr{};            peer_addr.sin_family = AF_INET;            peer_addr.sin_port = htons(p.port);            peer_addr.sin_addr.s_addr = inet_addr(p.ip);            sendto(udp_sock, msg, (int)strlen(msg), 0, (sockaddr*)&peer_addr, sizeof(peer_addr));        }    }    closesocket(tcp_sock);    closesocket(udp_sock);    WSACleanup();    printf("Disconnected.\n");    tcp_thread.detach();    udp_thread.detach();    return 0;}Implement a distributed quiz to assess your students' ability to perform simplearithmetical expressions, using both TCP and UDP for communication.Don’t focus on actually implementing the logic of solving the arithmeticalexpression on the client side. You can get a maximum grade even if yousend random values as the student’s answer.Server (teacher)Broadcasts port 7777, from 2 to 2 seconds, a list of simple arithmetical expressions as a string, in which thearithmetical expressions are separated by a semicolon (;).For example, the server might send the string “10+2;4/2;3+1”, and there are three questions: 10+2, 4/2 and 3+ 1.The server will also handle TCP connections from each student to get the answers from the quiz. After astudent sends the N answers (where N is the number of questions), the server computes the score and sends itto the student via TCP.The quiz will end after 12 seconds. After this amount of time has passed, the server stops broadcasting the testand waits for all the answers from the students that are already connected to the test.Clients (students):The students listen on UDP on port 7777 to get the test from the server (teacher).Upon receiving the test, the students connect to the server using a TCP connection on port 1234, and thensend their answers to the server (teacher). First the student sends the question index and then the answer forthat question (pay attention, these are numerical data!). For example, to send the answer for the first question,the student first sends the value 0 (the index of the question) and then 12 (the answer for that question).A student can send at most N answers (where N is the number of questions)!Rubric:1p: Default4p: Sending, through TCP a string and then a several numbers.2.5p: Using both TCP and UDP for communication.2.5p: Server (teacher) can handle multiple clients at onceclient.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <cstdio>#include <cstdlib>#include <cstring>#include <thread>#include <ctime>#pragma comment(lib, "ws2_32.lib")void listen_udp(char* server_ip, char* quiz) {    SOCKET udpSock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in addr{};    addr.sin_family = AF_INET;    addr.sin_port = htons(7777);    addr.sin_addr.s_addr = INADDR_ANY;    bind(udpSock, (sockaddr*)&addr, sizeof(addr));    sockaddr_in sender{};    int len = sizeof(sender);    int n = recvfrom(udpSock, quiz, 255, 0, (sockaddr*)&sender, &len);    if (n > 0) {        quiz[n] = '\0';        strcpy(server_ip, inet_ntoa(sender.sin_addr));        printf("[CLIENT] Received quiz from %s: %s\n", server_ip, quiz);    }    closesocket(udpSock);}void send_answers(const char* server_ip, const char* quiz) {    SOCKET tcpSock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in srv{};    srv.sin_family = AF_INET;    srv.sin_port = htons(1234);    srv.sin_addr.s_addr = inet_addr(server_ip);    if (connect(tcpSock, (sockaddr*)&srv, sizeof(srv)) == SOCKET_ERROR) {        printf("[CLIENT] Failed to connect to server.\n");        return;    }    // Split quiz    char quiz_copy[256];    strcpy(quiz_copy, quiz);    int qCount = 0;    char* token = strtok(quiz_copy, ";");    while (token) {        qCount++;        token = strtok(NULL, ";");    }    printf("[CLIENT] Sending random answers...\n");    srand((unsigned)time(0));    for (int i = 0; i < qCount; i++) {        int idx = htonl(i);        int ans = htonl(rand() % 20 + 1);        send(tcpSock, (char*)&idx, sizeof(int), 0);        send(tcpSock, (char*)&ans, sizeof(int), 0);        printf("[CLIENT] Sent answer Q%d -> %d\n", i, ntohl(ans));        std::this_thread::sleep_for(std::chrono::milliseconds(300));    }    int score = 0;    int r = recv(tcpSock, (char*)&score, sizeof(int), 0);    if (r > 0) {        score = ntohl(score);        printf("[CLIENT] Final score: %d\n", score);    }    closesocket(tcpSock);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    char server_ip[32];    char quiz[256];    listen_udp(server_ip, quiz);    send_answers(server_ip, quiz);    WSACleanup();    return 0;}server.c#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <thread>#include <vector>#include <mutex>#include <cstdio>#include <cstdlib>#include <cstring>#include <ctime>#include <string>#include <sstream>#pragma comment(lib, "ws2_32.lib")std::mutex mtx;bool quiz_active = true;std::vector<std::string> expressions;std::vector<int> correct_answers;// --- Simple evaluator for +, -, *, / ---int evaluate_expression(const std::string& expr) {    int a, b;    char op;    if (sscanf(expr.c_str(), "%d%c%d", &a, &op, &b) != 3)        return 0;    switch (op) {    case '+': return a + b;    case '-': return a - b;    case '*': return a * b;    case '/': return (b != 0) ? a / b : 0;    default: return 0;    }}void udp_broadcast() {    SOCKET udpSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    if (udpSock == INVALID_SOCKET) {        printf("UDP socket error\n");        return;    }    BOOL bcast = TRUE;    setsockopt(udpSock, SOL_SOCKET, SO_BROADCAST, (char*)&bcast, sizeof(bcast));    sockaddr_in baddr{};    baddr.sin_family = AF_INET;    baddr.sin_port = htons(7777);    baddr.sin_addr.s_addr = inet_addr("255.255.255.255");    // Build quiz string    char quizStr[512] = { 0 };    for (size_t i = 0; i < expressions.size(); i++) {        strcat(quizStr, expressions[i].c_str());        if (i < expressions.size() - 1) strcat(quizStr, ";");    }    printf("[SERVER] Broadcasting quiz every 2 seconds for 12 seconds...\n");    int counter = 0;    while (quiz_active && counter < 6) { // 6 * 2s = 12s        sendto(udpSock, quizStr, (int)strlen(quizStr), 0, (sockaddr*)&baddr, sizeof(baddr));        printf("[SERVER] Broadcasted quiz: %s\n", quizStr);        std::this_thread::sleep_for(std::chrono::seconds(2));        counter++;    }    printf("[SERVER] Broadcast ended. Waiting for remaining TCP answers...\n");    closesocket(udpSock);    quiz_active = false;}void handle_student(SOCKET clientSock, sockaddr_in addr) {    char client_ip[32];    strcpy(client_ip, inet_ntoa(addr.sin_addr));    printf("[SERVER] Student connected from %s\n", client_ip);    int totalQuestions = (int)expressions.size();    int answers[10] = { 0 };    bool answered[10] = { false };    int recvCount = 0;    while (recvCount < totalQuestions) {        int qIdx = -1, ans = 0;        int n1 = recv(clientSock, (char*)&qIdx, sizeof(int), 0);        if (n1 <= 0) break;        int n2 = recv(clientSock, (char*)&ans, sizeof(int), 0);        if (n2 <= 0) break;        qIdx = ntohl(qIdx);        ans = ntohl(ans);        if (qIdx >= 0 && qIdx < totalQuestions && !answered[qIdx]) {            answers[qIdx] = ans;            answered[qIdx] = true;            recvCount++;            printf("[SERVER] Received from %s: Q%d -> %d\n", client_ip, qIdx, ans);        }    }    // Compute score    int score = 0;    for (int i = 0; i < totalQuestions; i++) {        if (answered[i] && answers[i] == correct_answers[i])            score++;    }    int netScore = htonl(score);    send(clientSock, (char*)&netScore, sizeof(int), 0);    printf("[SERVER] Sent score %d to %s\n", score, client_ip);    closesocket(clientSock);}void tcp_server() {    SOCKET serverSock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in srv{};    srv.sin_family = AF_INET;    srv.sin_addr.s_addr = INADDR_ANY;    srv.sin_port = htons(1234);    bind(serverSock, (sockaddr*)&srv, sizeof(srv));    listen(serverSock, 5);    printf("[SERVER] Listening for TCP answers on port 1234...\n");    while (true) {        sockaddr_in cli{};        int len = sizeof(cli);        SOCKET clientSock = accept(serverSock, (sockaddr*)&cli, &len);        if (clientSock != INVALID_SOCKET) {            std::thread(handle_student, clientSock, cli).detach();        }    }    closesocket(serverSock);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    // Ask teacher to input quiz    char input[512];    printf("Enter arithmetic expressions separated by semicolons (e.g. 2+2;3*4;6/2):\n> ");    fgets(input, sizeof(input), stdin);    input[strcspn(input, "\n")] = 0; // remove newline    char* token = strtok(input, ";");    while (token) {        std::string expr = token;        expressions.push_back(expr);        correct_answers.push_back(evaluate_expression(expr));        token = strtok(NULL, ";");    }    printf("[SERVER] Loaded %zu expressions.\n", expressions.size());    std::thread udpThread(udp_broadcast);    std::thread tcpThread(tcp_server);    udpThread.join();    tcpThread.join();    WSACleanup();    return 0;}Implementarea in C a unei perechi de programe client/server care comunica prin socket-uri TCP/IP pentru rezolvarea problemelor:1. Schimb de mesaje intre client si server pentru obtinerea problemei de la test.2. Se da un sir de caractere si un caracter. Se cere sa se elimine din sir prima aparitie a caracterului.3. Se da un numar. Se cere sa se afiseze toate numerele prime mai mici ca numarul dat.4. Un client trimite unui server doua siruri de numere. Serverul va returna clientului sirul de numere care se regaseste in cel de-al doilea sirdar nu se regasesc in primul.5. Un client trimite unui server doua siruri de caractere. Serverul ii raspunde clientului cu caracterul care se regaseste de cele mai multe ori pepozitii identice in cele doua siruri si cu numarul de aparitii ale acestui caracter.CLIENT.C#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")#define PORT 12345#define SERVER_IP "127.0.0.1"#define BUF_SIZE 1024int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = inet_addr(SERVER_IP);    connect(s, (struct sockaddr*)&server, sizeof(server));    int option;    printf("Selectati problema (1-5): ");    scanf("%d", &option);    getchar();    int net_opt = htonl(option);    send(s, (char*)&net_opt, sizeof(int), 0);    char buf[BUF_SIZE] = { 0 };    switch (option) {    case 1:        printf("Introduceti mesaj: ");        fgets(buf, BUF_SIZE, stdin);        buf[strcspn(buf, "\n")] = 0;        send(s, buf, strlen(buf) + 1, 0);        recv(s, buf, BUF_SIZE, 0);        printf("Raspuns server: %s\n", buf);        break;    case 2: {        char str[256], ch;        printf("Introduceti sirul: ");        fgets(str, sizeof(str), stdin);        str[strcspn(str, "\n")] = 0;        printf("Caracterul de eliminat: ");        scanf("%c", &ch);        send(s, str, strlen(str) + 1, 0);        send(s, &ch, 1, 0);        recv(s, buf, BUF_SIZE, 0);        printf("Rezultat: %s\n", buf);        break;    }    case 3: {        int num;        printf("Introduceti un numar: ");        scanf("%d", &num);        num = htonl(num);        send(s, (char*)&num, sizeof(int), 0);        recv(s, buf, BUF_SIZE, 0);        printf("Numere prime: %s\n", buf);        break;    }    case 4: {        char s1[256], s2[256];        printf("Primul sir de numere (ex: 1 2 3 4): ");        fgets(s1, sizeof(s1), stdin);        s1[strcspn(s1, "\n")] = 0;        printf("Al doilea sir de numere: ");        fgets(s2, sizeof(s2), stdin);        s2[strcspn(s2, "\n")] = 0;        send(s, s1, strlen(s1) + 1, 0);        send(s, s2, strlen(s2) + 1, 0);        recv(s, buf, BUF_SIZE, 0);        printf("Rezultat: %s\n", buf);        break;    }    case 5: {        char s1[256], s2[256];        printf("Primul sir: ");        fgets(s1, sizeof(s1), stdin);        s1[strcspn(s1, "\n")] = 0;        printf("Al doilea sir: ");        fgets(s2, sizeof(s2), stdin);        s2[strcspn(s2, "\n")] = 0;        send(s, s1, strlen(s1) + 1, 0);        send(s, s2, strlen(s2) + 1, 0);        recv(s, buf, BUF_SIZE, 0);        printf("Rezultat (caracter si nr aparitii): %s\n", buf);        break;    }    }    closesocket(s);    WSACleanup();    return 0;}SERVER.C#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#pragma comment(lib, "ws2_32.lib")#define PORT 12345#define BUF_SIZE 1024// Helper: verifică dacă un număr este primint is_prime(int n) {    if (n < 2) return 0;    for (int i = 2; i * i <= n; i++)        if (n % i == 0) return 0;    return 1;}void handle_client(SOCKET client_sock) {    int option;    recv(client_sock, (char*)&option, sizeof(int), 0);    option = ntohl(option);    char buf[BUF_SIZE] = { 0 };    if (option == 1) {        recv(client_sock, buf, BUF_SIZE, 0);        printf("[Server] Received: %s\n", buf);        sprintf(buf, "Server: Am primit mesajul tau!");        send(client_sock, buf, strlen(buf) + 1, 0);    }    else if (option == 2) {        char str[256], ch;        recv(client_sock, str, sizeof(str), 0);        recv(client_sock, &ch, 1, 0);        for (int i = 0; i < strlen(str); i++) {            if (str[i] == ch) {                memmove(&str[i], &str[i + 1], strlen(str) - i);                break;            }        }        send(client_sock, str, strlen(str) + 1, 0);    }    else if (option == 3) {        int num;        recv(client_sock, (char*)&num, sizeof(int), 0);        num = ntohl(num);        char primes[512] = "";        for (int i = 2; i < num; i++) {            if (is_prime(i)) {                char tmp[16];                sprintf(tmp, "%d ", i);                strcat(primes, tmp);            }        }        send(client_sock, primes, strlen(primes) + 1, 0);    }    else if (option == 4) {        char s1[256], s2[256];        recv(client_sock, s1, sizeof(s1), 0);        recv(client_sock, s2, sizeof(s2), 0);        int n1[50], n2[50], i = 0, j = 0, x;        char* tok = strtok(s1, " ");        while (tok) { n1[i++] = atoi(tok); tok = strtok(NULL, " "); }        int len1 = i;        tok = strtok(s2, " ");        while (tok) { n2[j++] = atoi(tok); tok = strtok(NULL, " "); }        int len2 = j;        char result[256] = "";        for (int b = 0; b < len2; b++) {            int found = 0;            for (int a = 0; a < len1; a++) {                if (n2[b] == n1[a]) { found = 1; break; }            }            if (!found) {                char tmp[16];                sprintf(tmp, "%d ", n2[b]);                strcat(result, tmp);            }        }        send(client_sock, result, strlen(result) + 1, 0);    }    else if (option == 5) {        char s1[256], s2[256];        recv(client_sock, s1, sizeof(s1), 0);        recv(client_sock, s2, sizeof(s2), 0);        int freq[256] = { 0 };        int len = strlen(s1);        if (strlen(s2) < len) len = strlen(s2);        for (int i = 0; i < len; i++)            if (s1[i] == s2[i]) freq[(unsigned char)s1[i]]++;        int max = 0, best = '?';        for (int i = 0; i < 256; i++)            if (freq[i] > max) { max = freq[i]; best = (char)i; }        sprintf(buf, "%c %d", best, max);        send(client_sock, buf, strlen(buf) + 1, 0);    }    closesocket(client_sock);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(PORT);    server.sin_addr.s_addr = INADDR_ANY;    bind(s, (struct sockaddr*)&server, sizeof(server));    listen(s, 5);    printf("[Server] Listening on port %d...\n", PORT);    while (1) {        sockaddr_in client;        int c = sizeof(client);        SOCKET new_socket = accept(s, (struct sockaddr*)&client, &c);        if (new_socket != INVALID_SOCKET) {            printf("[Server] Client connected.\n");            handle_client(new_socket);        }    }    closesocket(s);    WSACleanup();    return 0;}"""Implement a server application that generates a random integer P and communicates to the clients the number of digits ofthat number – when the client connects.Implement a client application that receives from a server the number of digits of P. The client generates a randomdigit every N seconds and sends the digit to the server. The server answers with the positions where the digit is foundon the server’s number.Spawn multiple clients. The server will announce all clients when it has a winner using UDP. You should design a methodfor the server to infer the IP and port where is should communicate with each peer over UDP.server.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <ws2tcpip.h>#include <time.h>#include <thread>#include <vector>#include <mutex>#pragma comment(lib, "ws2_32.lib")#define TCP_PORT 12345#define BUF_SIZE 256struct ClientInfo {    SOCKET tcp_sock;    sockaddr_in addr;    int udp_port;};std::vector<ClientInfo> clients;std::mutex mtx;char secret[32];int digits_count;bool game_over = false;void send_udp_announcement(const char* msg) {    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    for (auto& c : clients) {        sockaddr_in udpAddr = c.addr;        udpAddr.sin_port = htons(c.udp_port);        sendto(udp_sock, msg, (int)strlen(msg) + 1, 0, (sockaddr*)&udpAddr, sizeof(udpAddr));    }    closesocket(udp_sock);}void handle_client(ClientInfo client) {    send(client.tcp_sock, (char*)&digits_count, sizeof(int), 0);    while (!game_over) {        int guess;        int r = recv(client.tcp_sock, (char*)&guess, sizeof(int), 0);        if (r <= 0) break;        guess = ntohl(guess);        char response[128] = "";        int found = 0;        for (int i = 0; i < digits_count; i++) {            if (secret[i] - '0' == guess) {                char tmp[8];                sprintf(tmp, "%d ", i);                strcat(response, tmp);                found++;            }        }        if (!found) strcpy(response, "none");        send(client.tcp_sock, response, (int)strlen(response) + 1, 0);        // Optional logic: if guessed all digits, mark winner        static int total_found = 0;        total_found += found;        if (total_found >= digits_count && !game_over) {            game_over = true;            char msg[128];            sprintf(msg, "Winner: %s:%d", inet_ntoa(client.addr.sin_addr), ntohs(client.addr.sin_port));            send_udp_announcement(msg);        }    }    closesocket(client.tcp_sock);}int main() {    srand((unsigned)time(NULL));    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    // Generate secret number    digits_count = 4;    for (int i = 0; i < digits_count; i++)        secret[i] = '0' + (rand() % 10);    secret[digits_count] = '\0';    printf("Secret number: %s\n", secret);    SOCKET server_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server;    server.sin_family = AF_INET;    server.sin_port = htons(TCP_PORT);    server.sin_addr.s_addr = INADDR_ANY;    bind(server_sock, (sockaddr*)&server, sizeof(server));    listen(server_sock, 5);    printf("Server listening on port %d...\n", TCP_PORT);    while (!game_over) {        sockaddr_in client_addr;        int len = sizeof(client_addr);        SOCKET client_sock = accept(server_sock, (sockaddr*)&client_addr, &len);        if (client_sock == INVALID_SOCKET) continue;        int udp_port;        recv(client_sock, (char*)&udp_port, sizeof(int), 0);        udp_port = ntohl(udp_port);        ClientInfo ci{ client_sock, client_addr, udp_port };        {            std::lock_guard<std::mutex> lock(mtx);            clients.push_back(ci);        }        printf("Client %s:%d connected (UDP %d)\n",            inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), udp_port);        std::thread(handle_client, ci).detach();    }    closesocket(server_sock);    WSACleanup();    return 0;}client.c#define _CRT_SECURE_NO_WARNINGS#define _WINSOCK_DEPRECATED_NO_WARNINGS#include <stdio.h>#include <stdlib.h>#include <string.h>#include <winsock2.h>#include <time.h>#include <thread>#pragma comment(lib, "ws2_32.lib")#define SERVER_IP "127.0.0.1"#define TCP_PORT 12345#define UDP_PORT 55555void listen_udp() {    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in addr{};    addr.sin_family = AF_INET;    addr.sin_port = htons(UDP_PORT);    addr.sin_addr.s_addr = INADDR_ANY;    bind(udp_sock, (sockaddr*)&addr, sizeof(addr));    char buf[256];    sockaddr_in from;    int fromlen = sizeof(from);    while (1) {        int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);        if (r > 0) {            buf[r] = 0;            printf("\n[UDP] %s\n", buf);            if (strstr(buf, "Winner")) break;        }    }    closesocket(udp_sock);}int main() {    srand((unsigned)time(NULL));    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons(TCP_PORT);    server.sin_addr.s_addr = inet_addr(SERVER_IP);    connect(sock, (sockaddr*)&server, sizeof(server));    // Send UDP port    int udp_port_net = htonl(UDP_PORT);    send(sock, (char*)&udp_port_net, sizeof(int), 0);    int digits_count;    recv(sock, (char*)&digits_count, sizeof(int), 0);    printf("The secret number has %d digits.\n", digits_count);    std::thread(listen_udp).detach();    while (1) {        int guess = rand() % 10;        int net_guess = htonl(guess);        send(sock, (char*)&net_guess, sizeof(int), 0);        char resp[128];        int r = recv(sock, resp, sizeof(resp) - 1, 0);        if (r <= 0) break;        resp[r] = 0;        printf("Sent %d → positions: %s\n", guess, resp);        if (strstr(resp, "none") == NULL && strlen(resp) > 0)            printf("[Client] Found digit %d!\n", guess);        Sleep(2000); // 2 seconds    }    closesocket(sock);    WSACleanup();    return 0;}Proiect - „Număr Echilibrat” (TCP + UDP, doi clienti)Se doreste implementarea unui proiect de tip -"Număr Echilibrat" intre un server si mai multi clienti, folosind o conexiune hibridă TCP/UDP.1. Etapa de conectare (TCP)- Serverul pornește și asteaptă conexiuni TCP din partea clienților.- Fiecare client se conectează la server si transmite numele de utilizator (ID).Dună ce s-a creat conexiunea, serverul trimite prin TCP un mesaj catre fiecare clientpentru a comuta pe comunicare UDP.- Serverul inchide conexiunile TCP si incepe comunicarea UDP.2. Comunicarea (UDP)-Jocul se desfasoară prin mesaje UDP intre server si clienti- Fiecare client trimite serverului numere intregi pozitive- Transmiterea numerelor continuă până când clientul trimite numărul 0. moment în carejocul acelui client se incheie.3. Funcționarea serveruluiServerul primește fiecare număr și il afișează pe ecran.- Pentru fiecare număr primit (diferit de 0), serverul calculează și trimite clientului numechilibrat imediat următor.- Un număr este considerat echilibrat dacă suma cifrelor de pe pozițiile impare este esuma cifrelor de pe pozițiile pare.Exemple:. Dacă clientul trimite 130, serverul răspunde cu 132.4. Încheierea problemei- Comunicarea pentru fiecare client se termină când acesta trimite numărul 0.client.cpp// client.cpp — "Număr Echilibrat" Client (TCP + UDP Hybrid)// Windows / Winsock2 version// Uses sockaddr_in + std::thread + scanf/printf// Author: GPT-5 (2025)#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <thread>#pragma comment(lib, "Ws2_32.lib")#define SERVER_IP "127.0.0.1"#define SERVER_TCP_PORT 5000#define SERVER_UDP_PORT 6000#define BUF_SIZE 1024void udp_receive(SOCKET udp_sock) {    char buf[BUF_SIZE];    struct sockaddr_in from;    int fromlen = sizeof(from);    while (1) {        int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&from, &fromlen);        if (r <= 0) continue;        buf[r] = '\0';        printf("[SERVER -> YOU] Next balanced number: %s\n", buf);    }}int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed.\n");        return 1;    }    char name[100];    char udp_port[10];    printf("Enter your name: ");    scanf("%s", name);    printf("Enter your UDP port (e.g. 7001): ");    scanf("%s", udp_port);    // ---- TCP REGISTER ----    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    if (tcp_sock == INVALID_SOCKET) {        printf("TCP socket creation failed.\n");        WSACleanup();        return 1;    }    struct sockaddr_in serv;    serv.sin_family = AF_INET;    serv.sin_port = htons(SERVER_TCP_PORT);    serv.sin_addr.s_addr = inet_addr(SERVER_IP);    if (connect(tcp_sock, (struct sockaddr*)&serv, sizeof(serv)) == SOCKET_ERROR) {        printf("Cannot connect to server.\n");        closesocket(tcp_sock);        WSACleanup();        return 1;    }    char msg[BUF_SIZE];    sprintf(msg, "REGISTER %s %s\n", name, udp_port);    send(tcp_sock, msg, (int)strlen(msg), 0);    char buf[BUF_SIZE];    int r = recv(tcp_sock, buf, sizeof(buf) - 1, 0);    if (r > 0) {        buf[r] = '\0';        printf("[SERVER TCP] %s", buf);    }    // Wait for SWITCH_UDP message    while (1) {        r = recv(tcp_sock, buf, sizeof(buf) - 1, 0);        if (r <= 0) {            printf("Server closed TCP connection.\n");            break;        }        buf[r] = '\0';        if (strstr(buf, "SWITCH_UDP")) {            printf("Server instructed to switch to UDP communication.\n");            break;        }    }    closesocket(tcp_sock);    // ---- UDP COMMUNICATION ----    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    if (udp_sock == INVALID_SOCKET) {        printf("UDP socket creation failed.\n");        WSACleanup();        return 1;    }    struct sockaddr_in myaddr;    myaddr.sin_family = AF_INET;    myaddr.sin_port = htons(atoi(udp_port));    myaddr.sin_addr.s_addr = INADDR_ANY;    if (bind(udp_sock, (struct sockaddr*)&myaddr, sizeof(myaddr)) != 0) {        printf("UDP bind failed. Try another port.\n");        closesocket(udp_sock);        WSACleanup();        return 1;    }    std::thread recv_thread(udp_receive, udp_sock);    recv_thread.detach();    struct sockaddr_in serv_udp;    serv_udp.sin_family = AF_INET;    serv_udp.sin_port = htons(SERVER_UDP_PORT);    serv_udp.sin_addr.s_addr = inet_addr(SERVER_IP);    printf("\nNow sending numbers to server (UDP mode).\n");    printf("Enter numbers (0 to quit):\n");    while (1) {        int num;        printf("Enter number: ");        scanf("%d", &num);        char sendbuf[64];        sprintf(sendbuf, "%d", num);        sendto(udp_sock, sendbuf, (int)strlen(sendbuf), 0,            (struct sockaddr*)&serv_udp, sizeof(serv_udp));        if (num == 0) {            printf("Session ended.\n");            break;        }    }    closesocket(udp_sock);    WSACleanup();    return 0;}server.cpp// server.cpp — "Număr Echilibrat" (TCP + UDP Hybrid Server)// Windows / Winsock2 + std::thread version// Uses sockaddr_in instead of getaddrinfo// Author: GPT-5 (2025)#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <ws2tcpip.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <thread>#include <vector>#include <mutex>#pragma comment(lib, "Ws2_32.lib")#define TCP_PORT 5000#define UDP_PORT 6000#define BUF_SIZE 1024struct Client {    SOCKET sock;    std::string name;    std::string ip;    std::string udp_port;    bool active;};std::vector<Client> clients;std::mutex clients_mtx;// 🔹 Helper: check if number is balancedbool is_balanced(int n) {    char s[32];    sprintf(s, "%d", n);    int len = (int)strlen(s);    int sum_even = 0, sum_odd = 0;    for (int i = 0; i < len; i++) {        int digit = s[i] - '0';        if ((i + 1) % 2 == 0)            sum_even += digit;        else            sum_odd += digit;    }    return sum_even == sum_odd;}int next_balanced(int n) {    while (true) {        n++;        if (is_balanced(n)) return n;    }}// 🔹 Broadcast to all clients except onevoid broadcast(const std::string& msg, SOCKET exclude) {    std::lock_guard<std::mutex> lock(clients_mtx);    for (auto& c : clients) {        if (c.active && c.sock != exclude) {            send(c.sock, msg.c_str(), (int)msg.size(), 0);        }    }}// 🔹 Handle a single TCP client connectionvoid handle_client(SOCKET client_sock) {    char buf[BUF_SIZE];    int recv_len = recv(client_sock, buf, sizeof(buf) - 1, 0);    if (recv_len <= 0) {        closesocket(client_sock);        return;    }    buf[recv_len] = '\0';    // Expect: REGISTER <name> <udp_port>    char cmd[50], name[100], udp_port[10];    if (sscanf(buf, "%s %s %s", cmd, name, udp_port) != 3) {        printf("[TCP] Invalid REGISTER message: %s\n", buf);        closesocket(client_sock);        return;    }    struct sockaddr_in addr;    int len = sizeof(addr);    getpeername(client_sock, (struct sockaddr*)&addr, &len);    char* ip = inet_ntoa(addr.sin_addr);    Client new_client;    new_client.name = name;    new_client.ip = ip;    new_client.udp_port = udp_port;    new_client.sock = client_sock;    new_client.active = true;    {        std::lock_guard<std::mutex> lock(clients_mtx);        clients.push_back(new_client);    }    printf("[TCP] Registered %s @ %s:%s\n", name, ip, udp_port);    // Send list of existing peers to the new client    {        std::lock_guard<std::mutex> lock(clients_mtx);        for (auto& c : clients) {            if (c.active && c.sock != client_sock) {                char msg[BUF_SIZE];                sprintf(msg, "NEW %s %s %s\n",                    c.name.c_str(), c.ip.c_str(), c.udp_port.c_str());                send(client_sock, msg, (int)strlen(msg), 0);            }        }    }    // Broadcast to others that a new client joined    char join_msg[BUF_SIZE];    sprintf(join_msg, "NEW %s %s %s\n", name, ip, udp_port);    broadcast(join_msg, client_sock);    // Tell the client to switch to UDP    const char* go_msg = "SWITCH_UDP\n";    send(client_sock, go_msg, (int)strlen(go_msg), 0);    // Close TCP connection    closesocket(client_sock);}// 🔹 UDP handler (shared by all clients)void udp_thread(SOCKET udp_sock) {    char buf[BUF_SIZE];    struct sockaddr_in client;    int clen = sizeof(client);    while (true) {        int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&client, &clen);        if (r <= 0) continue;        buf[r] = '\0';        int n = atoi(buf);        printf("[UDP] Received %d from %s:%d\n",            n, inet_ntoa(client.sin_addr), ntohs(client.sin_port));        if (n == 0) {            printf("[UDP] Client session ended.\n");            continue;        }        int balanced = next_balanced(n);        char reply[64];        sprintf(reply, "%d", balanced);        sendto(udp_sock, reply, (int)strlen(reply), 0, (struct sockaddr*)&client, clen);    }}int main() {    WSADATA wsa;    if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {        printf("WSAStartup failed.\n");        return 1;    }    // ---- TCP SETUP ----    SOCKET tcp_listen = socket(AF_INET, SOCK_STREAM, 0);    if (tcp_listen == INVALID_SOCKET) {        printf("TCP socket failed.\n");        WSACleanup();        return 1;    }    struct sockaddr_in server, client;    server.sin_family = AF_INET;    server.sin_port = htons(TCP_PORT);    server.sin_addr.s_addr = INADDR_ANY;    if (bind(tcp_listen, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {        printf("TCP bind failed: %d\n", WSAGetLastError());        closesocket(tcp_listen);        WSACleanup();        return 1;    }    if (listen(tcp_listen, 5) == SOCKET_ERROR) {        printf("TCP listen failed.\n");        closesocket(tcp_listen);        WSACleanup();        return 1;    }    printf("[TCP] Server listening on port %d...\n", TCP_PORT);    // ---- UDP SETUP ----    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    if (udp_sock == INVALID_SOCKET) {        printf("UDP socket failed.\n");        closesocket(tcp_listen);        WSACleanup();        return 1;    }    struct sockaddr_in udp_addr;    udp_addr.sin_family = AF_INET;    udp_addr.sin_port = htons(UDP_PORT);    udp_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(udp_sock, (struct sockaddr*)&udp_addr, sizeof(udp_addr)) == SOCKET_ERROR) {        printf("UDP bind failed: %d\n", WSAGetLastError());        closesocket(tcp_listen);        closesocket(udp_sock);        WSACleanup();        return 1;    }    printf("[UDP] Listening on port %d...\n", UDP_PORT);    // Start UDP thread    std::thread udpThread(udp_thread, udp_sock);    udpThread.detach();    // Accept clients via TCP    while (true) {        int clen = sizeof(client);        SOCKET client_sock = accept(tcp_listen, (struct sockaddr*)&client, &clen);        if (client_sock == INVALID_SOCKET) {            printf("Accept failed: %d\n", WSAGetLastError());            continue;        }        std::thread(handle_client, client_sock).detach();    }    closesocket(tcp_listen);    closesocket(udp_sock);    WSACleanup();    return 0;}Enunt: Să se genereze o pereche de programe client-server care sa respecte cerintele de mai jos:1. (1p) Serverul si Clientul primesc IP-ul și porturile TCP din linia de comandă:2. (1p) Serverul creeazā un socket TCP și ascultă conexiuni.3. (1p) Serverul TCP deserveste concurent Clientii.4. (3p) In comunicarea cu Serverul, Clientul primește de la Server:- un șir de caractere (text)- o comandă: UPPER, LOWER, REVERSE(UPPER + convertește șirul la majuscule, LOWER + convertește șirul la litere mici, REVERSE + inversează șirul)și trimite rezultatul calculului înapoi Serverului TCP.5. (1p) Apoi, Serverul si Clientul devin o pereche de programe emițător-receptor UDP care ruleaza pe portul UDP transmisanterior de catre server.6. (1p) Serverul trimite Clientului un șir de caractere.7. (1p) Clientul caspunde Serverului cu textul FOUND dacă șirul apare ca subșir în oricare din șirurile de paractere primiteanterior prin TCP sau NOT FOUND dacă nu apare.Nota: toate sicurile se citesc de la tastatura.(1p) oficiuExemplu:Text: Hello WorldComanda (UPPER/LOWER/REVERSE): REVERSERaspuns TCP: dlrow olleHText de verificat UDP: WorldRaspuns UDP: FOUNDclient.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <thread>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#pragma comment(lib, "Ws2_32.lib")#define BUF_SIZE 1024int main(int argc, char* argv[]) {    if (argc < 3) {        printf("Usage: %s <SERVER_IP> <TCP_PORT>\n", argv[0]);        return 1;    }    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    const char* server_ip = argv[1];    int port = atoi(argv[2]);    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    SOCKADDR_IN serv{};    serv.sin_family = AF_INET;    serv.sin_port = htons(port);    serv.sin_addr.s_addr = inet_addr(server_ip);    if (connect(tcp_sock, (SOCKADDR*)&serv, sizeof(serv)) == SOCKET_ERROR) {        printf("Connection failed.\n");        return 1;    }    printf("[Client] Connected to server.\n");    char text[BUF_SIZE], command[BUF_SIZE], buffer[BUF_SIZE];    int r;    // Step 1: Receive text and command    r = recv(tcp_sock, buffer, BUF_SIZE - 1, 0);    if (r <= 0) {        printf("Connection closed.\n");        closesocket(tcp_sock);        return 0;    }    buffer[r] = '\0';    sscanf(buffer, "%[^\n]\n%s", text, command);    printf("[Client] Received text: '%s'\n", text);    printf("[Client] Command: '%s'\n", command);    // Step 2: Process string    if (_stricmp(command, "UPPER") == 0) {        for (int i = 0; text[i]; i++) text[i] = toupper(text[i]);    }    else if (_stricmp(command, "LOWER") == 0) {        for (int i = 0; text[i]; i++) text[i] = tolower(text[i]);    }    else if (_stricmp(command, "REVERSE") == 0) {        int len = (int)strlen(text);        for (int i = 0; i < len / 2; i++) {            char tmp = text[i];            text[i] = text[len - 1 - i];            text[len - 1 - i] = tmp;        }    }    // Step 3: Send processed string back    send(tcp_sock, text, (int)strlen(text), 0);    printf("[Client] Sent result: %s\n", text);    // Step 4: Receive UDP port    r = recv(tcp_sock, buffer, BUF_SIZE - 1, 0);    buffer[r] = '\0';    int udp_port = atoi(buffer);    printf("[Client] Switching to UDP port %d\n", udp_port);    closesocket(tcp_sock);    // Step 5: Start UDP socket    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    SOCKADDR_IN myaddr{};    myaddr.sin_family = AF_INET;    myaddr.sin_addr.s_addr = INADDR_ANY;    myaddr.sin_port = htons(udp_port);    bind(udp_sock, (SOCKADDR*)&myaddr, sizeof(myaddr));    char udp_msg[BUF_SIZE];    SOCKADDR_IN server_udp{};    int slen = sizeof(server_udp);    server_udp.sin_family = AF_INET;    server_udp.sin_addr.s_addr = inet_addr(server_ip);    server_udp.sin_port = htons(udp_port);    // Step 6: Receive search text    r = recvfrom(udp_sock, udp_msg, BUF_SIZE - 1, 0, (SOCKADDR*)&server_udp, &slen);    udp_msg[r] = '\0';    printf("[Client][UDP] Received: %s\n", udp_msg);    // Step 7: Check substring    char* found = strstr(text, udp_msg);    const char* response = (found ? "FOUND" : "NOT FOUND");    sendto(udp_sock, response, (int)strlen(response), 0, (SOCKADDR*)&server_udp, sizeof(server_udp));    printf("[Client][UDP] Sent: %s\n", response);    closesocket(udp_sock);    WSACleanup();    return 0;}server.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <thread>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#pragma comment(lib, "Ws2_32.lib")#define BUF_SIZE 1024// Convert string according to commandvoid process_string(char* text, const char* cmd) {    if (_stricmp(cmd, "UPPER") == 0) {        for (int i = 0; text[i]; i++) text[i] = toupper(text[i]);    }    else if (_stricmp(cmd, "LOWER") == 0) {        for (int i = 0; text[i]; i++) text[i] = tolower(text[i]);    }    else if (_stricmp(cmd, "REVERSE") == 0) {        int len = (int)strlen(text);        for (int i = 0; i < len / 2; i++) {            char tmp = text[i];            text[i] = text[len - 1 - i];            text[len - 1 - i] = tmp;        }    }}void handle_client(SOCKET client_sock, SOCKADDR_IN client_addr) {    char buffer[BUF_SIZE];    int udp_port;    printf("[Server] Connected client: %s:%d\n",        inet_ntoa(client_addr.sin_addr),        ntohs(client_addr.sin_port));    // Step 1: Get text and command from user (for this client)    char text[BUF_SIZE], command[BUF_SIZE];    printf("\nEnter text to send to this client: ");    fgets(text, BUF_SIZE, stdin);    text[strcspn(text, "\n")] = 0;    printf("Enter command (UPPER/LOWER/REVERSE): ");    fgets(command, BUF_SIZE, stdin);    command[strcspn(command, "\n")] = 0;    // Step 2: Send both text and command    sprintf(buffer, "%s\n%s\n", text, command);    send(client_sock, buffer, (int)strlen(buffer), 0);    // Step 3: Receive processed string from client    int r = recv(client_sock, buffer, BUF_SIZE - 1, 0);    if (r > 0) {        buffer[r] = '\0';        printf("[Server] Result from client: %s\n", buffer);    }    // Step 4: Ask server-side for UDP port to use    printf("\nEnter UDP port for communication with this client: ");    scanf("%d", &udp_port);    getchar(); // clear newline    // Step 5: Send UDP port to client (over TCP)    sprintf(buffer, "%d", udp_port);    send(client_sock, buffer, (int)strlen(buffer), 0);    closesocket(client_sock);    printf("[Server] TCP phase done. Switching to UDP...\n");    // Step 6: UDP phase    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    SOCKADDR_IN udp_addr{};    udp_addr.sin_family = AF_INET;    udp_addr.sin_port = htons(udp_port);    udp_addr.sin_addr.s_addr = INADDR_ANY;    if (bind(udp_sock, (SOCKADDR*)&udp_addr, sizeof(udp_addr)) < 0) {        printf("UDP bind failed\n");        closesocket(udp_sock);        return;    }    char udp_text[BUF_SIZE];    printf("Enter UDP text to send for substring check: ");    fgets(udp_text, BUF_SIZE, stdin);    udp_text[strcspn(udp_text, "\n")] = 0;    SOCKADDR_IN client_udp{};    client_udp.sin_family = AF_INET;    client_udp.sin_port = htons(udp_port);    client_udp.sin_addr = client_addr.sin_addr;    sendto(udp_sock, udp_text, (int)strlen(udp_text), 0,        (SOCKADDR*)&client_udp, sizeof(client_udp));    // Step 7: Wait for response    int clen = sizeof(client_udp);    r = recvfrom(udp_sock, buffer, BUF_SIZE - 1, 0, (SOCKADDR*)&client_udp, &clen);    if (r > 0) {        buffer[r] = '\0';        printf("[Server][UDP] Client replied: %s\n", buffer);    }    closesocket(udp_sock);    printf("[Server] UDP phase ended for this client.\n");}int main(int argc, char* argv[]) {    if (argc < 3) {        printf("Usage: %s <IP> <TCP_PORT>\n", argv[0]);        return 1;    }    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    const char* server_ip = argv[1];    int port = atoi(argv[2]);    SOCKET listen_sock = socket(AF_INET, SOCK_STREAM, 0);    SOCKADDR_IN server_addr{};    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = inet_addr(server_ip);    server_addr.sin_port = htons(port);    if (bind(listen_sock, (SOCKADDR*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {        printf("Bind failed\n");        return 1;    }    listen(listen_sock, 5);    printf("Server listening on %s:%d...\n", server_ip, port);    while (1) {        SOCKADDR_IN client_addr{};        int len = sizeof(client_addr);        SOCKET client_sock = accept(listen_sock, (SOCKADDR*)&client_addr, &len);        if (client_sock == INVALID_SOCKET)            continue;        std::thread(handle_client, client_sock, client_addr).detach();    }    closesocket(listen_sock);    WSACleanup();    return 0;}--TERMINALCLIENT.CPP#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <stdio.h>#include <string>#include <thread>#include <ctype.h>#pragma comment(lib, "Ws2_32.lib")#define BUF_SIZE 1024void process_text(char* text, const char* cmd) {    if (_stricmp(cmd, "UPPER") == 0) {        for (int i = 0; text[i]; i++) text[i] = toupper(text[i]);    }    else if (_stricmp(cmd, "LOWER") == 0) {        for (int i = 0; text[i]; i++) text[i] = tolower(text[i]);    }    else if (_stricmp(cmd, "REVERSE") == 0) {        int len = (int)strlen(text);        for (int i = 0; i < len / 2; i++) {            char tmp = text[i];            text[i] = text[len - 1 - i];            text[len - 1 - i] = tmp;        }    }}void udp_listener(const char* server_ip, int udp_port, const char* last_texts[], int count) {    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    sockaddr_in local{};    local.sin_family = AF_INET;    local.sin_port = htons(udp_port);    local.sin_addr.s_addr = INADDR_ANY;    if (bind(udp_sock, (sockaddr*)&local, sizeof(local)) == SOCKET_ERROR) {        printf("Failed to bind UDP port %d\n", udp_port);        closesocket(udp_sock);        return;    }    printf("[Client] Waiting for UDP message on port %d...\n", udp_port);    char buf[BUF_SIZE];    sockaddr_in from;    int fromlen = sizeof(from);    int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);    if (r <= 0) {        closesocket(udp_sock);        return;    }    buf[r] = 0;    printf("[Client] UDP received text to check: '%s'\n", buf);    bool found = false;    for (int i = 0; i < count; i++) {        if (strstr(last_texts[i], buf)) {            found = true;            break;        }    }    const char* reply = found ? "FOUND" : "NOT FOUND";    sendto(udp_sock, reply, (int)strlen(reply), 0, (sockaddr*)&from, fromlen);    printf("[Client] Sent UDP reply: %s\n", reply);    closesocket(udp_sock);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    char server_ip[32];    char port_str[16];    printf("Enter server IP: ");    scanf("%31s", server_ip);    printf("Enter server TCP port: ");    scanf("%15s", port_str);    getchar(); // consume newline    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serv{};    serv.sin_family = AF_INET;    serv.sin_port = htons((u_short)atoi(port_str));    inet_pton(AF_INET, server_ip, &serv.sin_addr);    if (connect(s, (sockaddr*)&serv, sizeof(serv)) == SOCKET_ERROR) {        printf("Connection failed!\n");        return 1;    }    printf("Connected to server.\n");    char buf[BUF_SIZE];    int r = recv(s, buf, sizeof(buf) - 1, 0);    if (r <= 0) return 0;    buf[r] = 0;    char text[BUF_SIZE], cmd[BUF_SIZE];    sscanf(buf, "%[^\n]\n%[^\n]", text, cmd);    printf("Received text: %s\n", text);    printf("Command: %s\n", cmd);    process_text(text, cmd);    send(s, text, (int)strlen(text), 0);    const char* prev_texts[1] = { text };    // KEEP CLIENT ALIVE for UDP phase    udp_listener(server_ip, 6000, prev_texts, 1);    printf("UDP communication done. Closing client.\n");    closesocket(s);    WSACleanup();    return 0;}SERVER.CPP#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <ws2tcpip.h>#include <stdio.h>#include <string>#include <thread>#include <mutex>#pragma comment(lib, "Ws2_32.lib")#define BUF_SIZE 1024std::mutex io_mutex;void handle_client(SOCKET client_sock, sockaddr_in client_addr) {    char buf[BUF_SIZE];    int r;    {        std::lock_guard<std::mutex> lock(io_mutex);        printf("\n[+] Client connected: %s:%d\n",            inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));    }    char text[BUF_SIZE];    char cmd[BUF_SIZE];    {        std::lock_guard<std::mutex> lock(io_mutex);        printf("Enter text for client %s:%d: ",            inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));        fgets(text, sizeof(text), stdin);        text[strcspn(text, "\n")] = 0;        printf("Enter command (UPPER/LOWER/REVERSE): ");        fgets(cmd, sizeof(cmd), stdin);        cmd[strcspn(cmd, "\n")] = 0;    }    // Send text + command to client    sprintf(buf, "%s\n%s\n", text, cmd);    send(client_sock, buf, (int)strlen(buf), 0);    // Receive processed result    r = recv(client_sock, buf, sizeof(buf) - 1, 0);    if (r > 0) {        buf[r] = 0;        std::lock_guard<std::mutex> lock(io_mutex);        printf("[Server <- %s] TCP result: %s\n",            inet_ntoa(client_addr.sin_addr), buf);    }    // ---- UDP PHASE ----    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);    sockaddr_in udp_client{};    udp_client.sin_family = AF_INET;    udp_client.sin_port = htons(6000); // fixed UDP port for all clients    udp_client.sin_addr = client_addr.sin_addr;    char search[BUF_SIZE];    {        std::lock_guard<std::mutex> lock(io_mutex);        printf("Enter UDP text to check for client %s: ",            inet_ntoa(client_addr.sin_addr));        fgets(search, sizeof(search), stdin);        search[strcspn(search, "\n")] = 0;    }    // Send search text    sendto(udp_sock, search, (int)strlen(search), 0,        (sockaddr*)&udp_client, sizeof(udp_client));    // Receive reply    sockaddr_in from;    int fromlen = sizeof(from);    r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0,        (sockaddr*)&from, &fromlen);    if (r > 0) {        buf[r] = 0;        std::lock_guard<std::mutex> lock(io_mutex);        printf("[Server <- %s] UDP reply: %s\n",            inet_ntoa(client_addr.sin_addr), buf);    }    closesocket(udp_sock);    closesocket(client_sock);    {        std::lock_guard<std::mutex> lock(io_mutex);        printf("[-] Client disconnected: %s\n", inet_ntoa(client_addr.sin_addr));    }}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    char port_str[16];    printf("Enter TCP port for server: ");    scanf("%15s", port_str);    getchar(); // remove newline    SOCKET listen_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in server{};    server.sin_family = AF_INET;    server.sin_port = htons((u_short)atoi(port_str));    server.sin_addr.s_addr = INADDR_ANY;    bind(listen_sock, (sockaddr*)&server, sizeof(server));    listen(listen_sock, 5);    printf("\nServer listening on TCP port %s...\n", port_str);    while (true) {        sockaddr_in client{};        int clen = sizeof(client);        SOCKET cs = accept(listen_sock, (sockaddr*)&client, &clen);        if (cs == INVALID_SOCKET) continue;        std::thread(handle_client, cs, client).detach();    }    closesocket(listen_sock);    WSACleanup();    return 0;}find waldo, o tabla (matrix?!) in server si undeva sa afla waldo. clientii trebe sa ghicească periodic unde e waldo. prin udp. ti se dau pozitii probabile inde e waldo ca tease si numa una e buna tu cand ii trimiti pozitia ca guess el returneaza distanta Manhattan pana acolo unde e waldo si dupa un tcp care trimite best guess la toti clientii si la fimal sa inchida conexiunea.server.cpp// server.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#include <mutex>#include <vector>#include <time.h>#pragma comment(lib, "Ws2_32.lib")#define BUF_SIZE 512#define GRID_SIZE 10#define TCP_PORT 7001#define UDP_PORT 7002struct Player {    SOCKET tcp_sock;    sockaddr_in udp_addr;    char name[32];    bool active;};std::vector<Player> players;std::mutex mtx;int waldo_x, waldo_y;SOCKET udp_sock;int manhattan(int x1, int y1, int x2, int y2) {    return abs(x1 - x2) + abs(y1 - y2);}void udp_listener() {    char buf[BUF_SIZE];    sockaddr_in from;    int fromlen = sizeof(from);    while (true) {        int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);        if (r <= 0) continue;        buf[r] = 0;        int gx, gy;        if (sscanf(buf, "%d %d", &gx, &gy) == 2) {            int dist = manhattan(waldo_x, waldo_y, gx, gy);            // Find player            char pname[32] = "Unknown";            {                std::lock_guard<std::mutex> lock(mtx);                for (auto& p : players) {                    if (ntohs(p.udp_addr.sin_port) == ntohs(from.sin_port) &&                        p.udp_addr.sin_addr.s_addr == from.sin_addr.s_addr) {                        strcpy(pname, p.name);                        break;                    }                }            }            printf("[Server] %s guessed (%d,%d) -> DIST %d\n", pname, gx, gy, dist);            // Send distance back            char reply[64];            sprintf(reply, "DIST %d", dist);            sendto(udp_sock, reply, (int)strlen(reply), 0, (sockaddr*)&from, fromlen);            if (dist == 0) {                // Player found Waldo                printf("[Server] 🎉 Waldo found by %s!\n", pname);                char msg[128];                sprintf(msg, "WINNER %s\n", pname);                std::lock_guard<std::mutex> lock(mtx);                for (auto& p : players) {                    send(p.tcp_sock, msg, (int)strlen(msg), 0);                    closesocket(p.tcp_sock);                }                printf("[Server] Game over. Exiting...\n");                closesocket(udp_sock);                exit(0);            }        }    }}void handle_client(SOCKET client_sock) {    char buf[BUF_SIZE];    int n = recv(client_sock, buf, sizeof(buf) - 1, 0);    if (n <= 0) {        closesocket(client_sock);        return;    }    buf[n] = 0;    char name[32];    int udp_port;    if (sscanf(buf, "REGISTER %s %d", name, &udp_port) != 2) {        closesocket(client_sock);        return;    }    sockaddr_in addr;    int len = sizeof(addr);    getpeername(client_sock, (sockaddr*)&addr, &len);    Player p{};    strcpy(p.name, name);    p.tcp_sock = client_sock;    p.active = true;    p.udp_addr.sin_family = AF_INET;    p.udp_addr.sin_addr = addr.sin_addr;    p.udp_addr.sin_port = htons((u_short)udp_port);    {        std::lock_guard<std::mutex> lock(mtx);        players.push_back(p);    }    printf("[Server] Player connected: %s (%s:%d)\n",        name, inet_ntoa(addr.sin_addr), udp_port);    const char* msg = "You are registered. Start guessing via UDP!\n";    send(client_sock, msg, (int)strlen(msg), 0);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    srand((unsigned)time(NULL));    waldo_x = rand() % GRID_SIZE;    waldo_y = rand() % GRID_SIZE;    printf("[Server] Waldo hidden at (%d,%d)\n", waldo_x, waldo_y);    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serv{};    serv.sin_family = AF_INET;    serv.sin_port = htons(TCP_PORT);    serv.sin_addr.s_addr = INADDR_ANY;    bind(tcp_sock, (sockaddr*)&serv, sizeof(serv));    listen(tcp_sock, 5);    udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in udp_addr{};    udp_addr.sin_family = AF_INET;    udp_addr.sin_port = htons(UDP_PORT);    udp_addr.sin_addr.s_addr = INADDR_ANY;    bind(udp_sock, (sockaddr*)&udp_addr, sizeof(udp_addr));    std::thread(udp_listener).detach();    printf("[Server] Ready! (TCP:%d UDP:%d)\n", TCP_PORT, UDP_PORT);    while (true) {        sockaddr_in caddr;        int clen = sizeof(caddr);        SOCKET client = accept(tcp_sock, (sockaddr*)&caddr, &clen);        if (client == INVALID_SOCKET) continue;        std::thread(handle_client, client).detach();    }    closesocket(tcp_sock);    WSACleanup();    return 0;}client.cpp// client.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#include <atomic>#pragma comment(lib, "Ws2_32.lib")#define BUF_SIZE 512#define SERVER_IP "10.66.148.73"#define SERVER_TCP_PORT 7001#define SERVER_UDP_PORT 7002std::atomic<bool> running(true);void udp_listener(SOCKET udp_sock) {    char buf[BUF_SIZE];    sockaddr_in from;    int fromlen = sizeof(from);    while (running) {        int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);        if (r <= 0) continue;        buf[r] = 0;        printf("[UDP] %s\n", buf);        if (strstr(buf, "DIST 0")) {            printf("🎯 You found Waldo!\n");        }    }}void tcp_listener(SOCKET tcp_sock) {    char buf[BUF_SIZE];    while (running) {        int n = recv(tcp_sock, buf, sizeof(buf) - 1, 0);        if (n <= 0) break;        buf[n] = 0;        printf("[TCP] %s\n", buf);        if (strstr(buf, "WINNER")) {            printf("🏁 Game over!\n");            running = false;            break;        }    }}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serv{};    serv.sin_family = AF_INET;    serv.sin_port = htons(SERVER_TCP_PORT);    serv.sin_addr.s_addr = inet_addr(SERVER_IP);    if (connect(tcp_sock, (sockaddr*)&serv, sizeof(serv)) == SOCKET_ERROR) {        printf("❌ TCP connection failed.\n");        return 1;    }    char name[32];    printf("Enter your player name: ");    scanf("%31s", name);    int udp_port;    printf("Enter your UDP port (unique, e.g. 8001, 8002...): ");    scanf("%d", &udp_port);    // One UDP socket for both send and receive    SOCKET udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in local{};    local.sin_family = AF_INET;    local.sin_port = htons(udp_port);    local.sin_addr.s_addr = INADDR_ANY;    bind(udp_sock, (sockaddr*)&local, sizeof(local));    // Register player    char regmsg[64];    sprintf(regmsg, "REGISTER %s %d", name, udp_port);    send(tcp_sock, regmsg, (int)strlen(regmsg), 0);    char buf[BUF_SIZE];    int n = recv(tcp_sock, buf, sizeof(buf) - 1, 0);    if (n > 0) {        buf[n] = 0;        printf("[TCP] %s\n", buf);    }    // Start listeners    std::thread(udp_listener, udp_sock).detach();    std::thread(tcp_listener, tcp_sock).detach();    sockaddr_in server_udp{};    server_udp.sin_family = AF_INET;    server_udp.sin_port = htons(SERVER_UDP_PORT);    server_udp.sin_addr.s_addr = inet_addr(SERVER_IP);    printf("Start guessing! Enter coordinates (x y):\n");    while (running) {        int x, y;        if (scanf("%d %d", &x, &y) != 2) break;        char msg[64];        sprintf(msg, "%d %d", x, y);        sendto(udp_sock, msg, (int)strlen(msg), 0, (sockaddr*)&server_udp, sizeof(server_udp));    }    closesocket(udp_sock);    closesocket(tcp_sock);    WSACleanup();    return 0;}server.CPP// server.cpp#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <stdlib.h>#include <thread>#include <mutex>#include <vector>#include <time.h>#pragma comment(lib, "Ws2_32.lib")#define BUF_SIZE 512#define GRID_SIZE 10#define TCP_PORT 7001#define UDP_PORT 7002#define NUM_HINTS 5  // number of "probable" positions shown to each playerstruct Player {    SOCKET tcp_sock;    sockaddr_in udp_addr;    char name[32];    bool active;};std::vector<Player> players;std::mutex mtx;int waldo_x, waldo_y;SOCKET udp_sock;// Manhattan distance calculationint manhattan(int x1, int y1, int x2, int y2) {    return abs(x1 - x2) + abs(y1 - y2);}// Handle incoming UDP guessesvoid udp_listener() {    char buf[BUF_SIZE];    sockaddr_in from;    int fromlen = sizeof(from);    while (true) {        int r = recvfrom(udp_sock, buf, sizeof(buf) - 1, 0, (sockaddr*)&from, &fromlen);        if (r <= 0) continue;        buf[r] = 0;        int gx, gy;        if (sscanf(buf, "%d %d", &gx, &gy) == 2) {            int dist = manhattan(waldo_x, waldo_y, gx, gy);            // Find player name based on UDP info            char pname[32] = "Unknown";            {                std::lock_guard<std::mutex> lock(mtx);                for (auto& p : players) {                    if (ntohs(p.udp_addr.sin_port) == ntohs(from.sin_port) &&                        p.udp_addr.sin_addr.s_addr == from.sin_addr.s_addr) {                        strcpy(pname, p.name);                        break;                    }                }            }            printf("[Server] %s guessed (%d,%d) -> DIST %d\n", pname, gx, gy, dist);            // Send distance back to client            char reply[64];            sprintf(reply, "DIST %d", dist);            sendto(udp_sock, reply, (int)strlen(reply), 0, (sockaddr*)&from, fromlen);            // If player found Waldo            if (dist == 0) {                printf("[Server] 🎉 Waldo found by %s!\n", pname);                char msg[128];                sprintf(msg, "WINNER %s\n", pname);                std::lock_guard<std::mutex> lock(mtx);                for (auto& p : players) {                    send(p.tcp_sock, msg, (int)strlen(msg), 0);                    closesocket(p.tcp_sock);                }                printf("[Server] Game over. Exiting...\n");                closesocket(udp_sock);                exit(0);            }        }    }}// Handle new TCP client connectionvoid handle_client(SOCKET client_sock) {    char buf[BUF_SIZE];    int n = recv(client_sock, buf, sizeof(buf) - 1, 0);    if (n <= 0) { closesocket(client_sock); return; }    buf[n] = 0;    char name[32];    int udp_port;    if (sscanf(buf, "REGISTER %s %d", name, &udp_port) != 2) {        closesocket(client_sock);        return;    }    sockaddr_in addr;    int len = sizeof(addr);    getpeername(client_sock, (sockaddr*)&addr, &len);    Player p{};    strcpy(p.name, name);    p.tcp_sock = client_sock;    p.active = true;    p.udp_addr.sin_family = AF_INET;    p.udp_addr.sin_addr = addr.sin_addr;    p.udp_addr.sin_port = htons((u_short)udp_port);    {        std::lock_guard<std::mutex> lock(mtx);        players.push_back(p);    }    printf("[Server] Player connected: %s (%s:%d)\n",        name, inet_ntoa(addr.sin_addr), udp_port);    // --- Build and send hint list (one real Waldo position, rest random) ---    char hint_msg[256] = "";    strcat(hint_msg, "Possible Waldo positions:\n");    // Pick a random index to insert the REAL Waldo    int real_pos = rand() % NUM_HINTS;    for (int i = 0; i < NUM_HINTS; i++) {        int hx, hy;        if (i == real_pos) {            hx = waldo_x;            hy = waldo_y;        }        else {            do {                hx = rand() % GRID_SIZE;                hy = rand() % GRID_SIZE;            } while (hx == waldo_x && hy == waldo_y); // ensure not duplicate        }        char pos[32];        sprintf(pos, "(%d,%d)%s", hx, hy, (i == NUM_HINTS - 1 ? "" : ", "));        strcat(hint_msg, pos);    }    strcat(hint_msg, "\nTry guessing with UDP!\n");    send(client_sock, hint_msg, (int)strlen(hint_msg), 0);}int main() {    WSADATA wsa;    WSAStartup(MAKEWORD(2, 2), &wsa);    srand((unsigned)time(NULL));    waldo_x = rand() % GRID_SIZE;    waldo_y = rand() % GRID_SIZE;    printf("[Server] Waldo hidden at (%d,%d)\n", waldo_x, waldo_y);    // TCP socket setup    SOCKET tcp_sock = socket(AF_INET, SOCK_STREAM, 0);    sockaddr_in serv{};    serv.sin_family = AF_INET;    serv.sin_port = htons(TCP_PORT);    serv.sin_addr.s_addr = INADDR_ANY;    bind(tcp_sock, (sockaddr*)&serv, sizeof(serv));    listen(tcp_sock, 5);    // UDP socket setup    udp_sock = socket(AF_INET, SOCK_DGRAM, 0);    sockaddr_in udp_addr{};    udp_addr.sin_family = AF_INET;    udp_addr.sin_port = htons(UDP_PORT);    udp_addr.sin_addr.s_addr = INADDR_ANY;    bind(udp_sock, (sockaddr*)&udp_addr, sizeof(udp_addr));    std::thread(udp_listener).detach();    printf("[Server] Ready! (TCP:%d UDP:%d)\n", TCP_PORT, UDP_PORT);    while (true) {        sockaddr_in caddr;        int clen = sizeof(caddr);        SOCKET client = accept(tcp_sock, (sockaddr*)&caddr, &clen);        if (client == INVALID_SOCKET) continue;        std::thread(handle_client, client).detach();    }    closesocket(tcp_sock);    WSACleanup();    return 0;}// C++ Program to demonstrate how to create// a vector of pairs#include <bits/stdc++.h>using namespace std;int main() {      // Creating vector of pairs of type    // string and int    vector<pair<int,string>> v;        // Insert pairs in vector    v.push_back(make_pair(1, "Geeks"));    v.push_back(make_pair(2, "Geeksfor"));    v.push_back(make_pair(3, "GeeksforGeeks"));        for(auto i: v)        cout << i.first << " " << i.second      	<< endl;   return 0;}#define _WINSOCK_DEPRECATED_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#include <winsock2.h>#include <windows.h>#include <stdio.h>#include <thread>#include <vector>#include <mutex>#include <string>#pragma comment(lib, "Ws2_32.lib")#define TCP_PORT 7001#define BUF_SIZE 512struct Student {    SOCKET sock;    sockaddr_in addr;    int udp_port;    char name[32];};struct Room {    char name[32];    bool free;};std::vector<Student> students;std::vector<Room> rooms = {    {"A101", true},    {"A102", false},    {"B201", true},    {"B202", false},    {"C301", true}};std::mutex mtx;void broadcast(const char* msg) {    std::lock_guard<std::mutex> lock(mtx);    for (auto& s : students)        send(s.sock, msg, (int)strlen(msg), 0);}void handle_student(SOCKET csock) {    char buf[BUF_SIZE];    int n = recv(csock, buf, sizeof(buf) - 1, 0);    if (n <= 0) return;    buf[n] = 0;    // Expected format: REGISTER <name>students search for an mpty room in a uni building a server coordinates the serach while students also coordinate with eachother each student program i=opens a tcp to the server to join the search sending udp port to comm withother peer participating over the same tcp session the sever also provides a list of andidate room name that might be free. students the iter